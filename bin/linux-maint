#!/usr/bin/env bash
# linux-maint - CLI entrypoint for Linux_Maint_Scripts

set -euo pipefail

# If running from a git checkout, prefer repo paths automatically.
SCRIPT_DIR="$(cd -- "$(dirname -- "${BASH_SOURCE[0]}")" && pwd)"
REPO_ROOT="$(cd -- "$SCRIPT_DIR/.." && pwd)"

PREFIX="${PREFIX:-/usr/local}"
SBIN="$PREFIX/sbin"
LIBEXEC="$PREFIX/libexec/linux_maint"
SHARE="$PREFIX/share/linux_maint"

REPO_MONITORS="$REPO_ROOT/monitors"
REPO_LIB="$REPO_ROOT/lib/linux_maint.sh"
REPO_WRAPPER="$REPO_ROOT/run_full_health_monitor.sh"

# installed defaults
wrapper="$SBIN/run_full_health_monitor.sh"
preflight="$LIBEXEC/preflight_check.sh"
validate="$LIBEXEC/config_validate.sh"

if [[ -d "$REPO_MONITORS" && -f "$REPO_LIB" ]]; then
  # repo mode
  export LINUX_MAINT_LIB="${LINUX_MAINT_LIB:-$REPO_LIB}"
  export LM_LOCKDIR="${LM_LOCKDIR:-/tmp}"
  export LM_LOGFILE="${LM_LOGFILE:-/tmp/linux_maint.log}"
  wrapper="$REPO_WRAPPER"
  preflight="$REPO_MONITORS/preflight_check.sh"
  validate="$REPO_MONITORS/config_validate.sh"
fi

MODE="installed"
[[ "$wrapper" == "$REPO_WRAPPER" ]] && MODE="repo"
REPO_LOG_DIR="$REPO_ROOT/.logs"
REPO_STATUS_FILE="$REPO_LOG_DIR/last_status_full"
REPO_LATEST_LOG="$REPO_LOG_DIR/full_health_monitor_latest.log"
REPO_SUMMARY_LATEST="$REPO_LOG_DIR/full_health_monitor_summary_latest.log"
INST_SUMMARY_LATEST="/var/log/health/full_health_monitor_summary_latest.log"


need_root_for(){
  local cmd="$1"
  if [[ "${EUID:-$(id -u)}" -ne 0 ]]; then
    echo "ERROR: linux-maint $cmd requires root (installed mode)." >&2
    case "$cmd" in
      run)
        echo "Hint: sudo linux-maint run" >&2
        echo "      (or run the wrapper directly: sudo /usr/local/sbin/run_full_health_monitor.sh)" >&2
        ;;
      status)
        echo "Hint: sudo linux-maint status" >&2
        ;;
      logs)
        echo "Hint: sudo linux-maint logs 200" >&2
        ;;
      preflight)
        echo "Hint: sudo linux-maint preflight" >&2
        ;;
      validate)
        echo "Hint: sudo linux-maint validate" >&2
        ;;
      *)
        echo "Hint: sudo linux-maint $cmd" >&2
        ;;
    esac
    exit 1
  fi
}


validate_ssh_opts(){
  # Reject obviously dangerous shell metacharacters.
  # NOTE: LM_SSH_OPTS is split into argv for ssh; this check reduces the risk of accidental injection.
  local s="${LM_SSH_OPTS:-}"
  [[ -z "$s" ]] && return 0

  # Disallow shell metacharacters.
  # Newline/carriage-return checks are done separately with ANSI-C escapes.
  if printf '%s' "$s" | grep -Eq '[;&|`<>]|\$\(|\$\{'; then
    echo "ERROR: unsafe characters detected in --ssh-opts / LM_SSH_OPTS" >&2
    echo "LM_SSH_OPTS=$s" >&2
    exit 2
  fi
  case "$s" in
    *$'\n'*|*$'\r'*)
      echo "ERROR: unsafe characters detected in --ssh-opts / LM_SSH_OPTS" >&2
      echo "LM_SSH_OPTS=$s" >&2
      exit 2
      ;;
  esac
}



# ---- run() flags parsing (CLI-first, env-compatible) ----
# Maps:
#   --group G        -> LM_GROUP
#   --hosts a,b      -> LM_SERVERLIST (temp file)
#   --exclude a,b    -> LM_EXCLUDED (temp file)
#   --parallel N     -> LM_MAX_PARALLEL
#   --local-only     -> LM_LOCAL_ONLY=true
#   --ssh-opts "..." -> LM_SSH_OPTS
#   --dry-run        -> print resolved hosts and exit
#
_run_tmpfiles=()
cleanup_tmpfiles(){
  for f in "${_run_tmpfiles[@]:-}"; do rm -f "$f" 2>/dev/null || true; done
}
trap cleanup_tmpfiles EXIT

make_list_tmpfile(){
  local csv="$1" prefix="$2"
  local f
  f="$(mktemp "/tmp/linux_maint_${prefix}.XXXXXX")"
  _run_tmpfiles+=("$f")
  # split on comma and whitespace
  echo "$csv" | tr ',' '\n' | awk '{gsub(/^[ \t]+|[ \t]+$/,"",$0); if($0!="") print $0}' > "$f"
  echo "$f"
}

parse_run_args(){
  DRY_RUN=0
  DEBUG=0
  LIMIT=0
  SHUFFLE=0

  while [[ $# -gt 0 ]]; do
    case "$1" in
      --group)
        LM_GROUP="$2"; export LM_GROUP; shift 2;;
      --hosts)
        tmpf="$(make_list_tmpfile "$2" hosts)"; LM_SERVERLIST="$tmpf"; export LM_SERVERLIST; shift 2;;
      --exclude)
        tmpf="$(make_list_tmpfile "$2" excluded)"; LM_EXCLUDED="$tmpf"; export LM_EXCLUDED; shift 2;;
      --parallel)
        LM_MAX_PARALLEL="$2"; export LM_MAX_PARALLEL; shift 2;;
      --local-only)
        LM_LOCAL_ONLY="true"; export LM_LOCAL_ONLY; shift 1;;
      --ssh-opts)
        LM_SSH_OPTS="$2"; export LM_SSH_OPTS; shift 2;;
      --limit)
        LIMIT="$2"; shift 2;;
      --shuffle)
        SHUFFLE=1; shift 1;;
      --debug|--print-env)
        DEBUG=1; shift 1;;
      --dry-run)
        DRY_RUN=1; shift 1;;
      -h|--help)
        echo "Usage: linux-maint run [--group G] [--hosts h1,h2] [--exclude h3,h4] [--parallel N] [--local-only] [--ssh-opts '...'] [--limit N] [--shuffle] [--debug|--print-env] [--dry-run]"
        exit 0;;
      *)
        echo "Unknown run flag: $1" >&2
        exit 2;;
    esac
  done
}


usage(){
  cat <<EOF2
Usage: linux-maint <command> [args]

Commands:
  run [flags]         Run the full package (wrapper)
  status [--only S] [--host P] [--monitor P] [--match-mode M] [--tail N]  Show last run status + filtered summary lines
  diff [--json]       Show diff since last run (uses wrapper diff state)
  validate            Validate config file formats (best-effort)
  preflight           Run preflight checks
  version             Print installed BUILD_INFO (if present)
  install [args]      Run ./install.sh (pass-through)
  uninstall [args]    Run ./install.sh --uninstall (pass-through)
  make-tarball        Build offline release tarball (tools/make_tarball.sh)
  logs [n]            Tail latest wrapper log (default n=200)
  init [--minimal]    Install /etc/linux_maint templates (from repo checkout)
  doctor [--json]     Diagnose installation/config/state permissions
  deps                Print required/optional dependency manifest by monitor (offline-friendly)
  verify-install      Verify installation layout, permissions, and systemd wiring (best-effort)
  pack-logs [--out DIR]  Create a support bundle tar.gz (logs, config redacted, meta)
  explain reason <token>  Explain a reason= token (from docs/REASONS.md)
  explain status <S>      Explain a status value (OK/WARN/CRIT/UNKNOWN/SKIP)
  help                Show this help

Environment:
  PREFIX=/usr/local             installation prefix override
  LINUX_MAINT_LIB=...           override library path (useful in repo mode)
  LM_LOCKDIR=/tmp               override lock dir (useful when not root)
  LM_LOGFILE=/tmp/linux_maint.log override default log file
EOF2
}

cmd="${1:-help}"; shift || true

case "$cmd" in
  help|-h|--help)
    usage
    ;;

  run)
    if [[ "$MODE" == "installed" ]]; then
      need_root_for run
    fi
    parse_run_args "$@"
    validate_ssh_opts

    if [[ "${DEBUG:-0}" -eq 1 ]]; then
      echo "=== linux-maint run debug ==="
      echo "MODE=${MODE}"
      echo "wrapper=${wrapper}"
      echo "LM_GROUP=${LM_GROUP:-}"
      echo "LM_HOSTS_DIR=${LM_HOSTS_DIR:-}"
      echo "LM_SERVERLIST=${LM_SERVERLIST:-}"
      echo "LM_EXCLUDED=${LM_EXCLUDED:-}"
      echo "LM_MAX_PARALLEL=${LM_MAX_PARALLEL:-}"
      echo "LM_LOCAL_ONLY=${LM_LOCAL_ONLY:-}"
      echo "LM_SSH_OPTS=${LM_SSH_OPTS:-}"
      echo "LIMIT=${LIMIT:-0}"
      echo "SHUFFLE=${SHUFFLE:-0}"
      echo "DRY_RUN=${DRY_RUN:-0}"
      echo "============================="
    fi

    if [[ "${DRY_RUN:-0}" -eq 1 ]]; then
      if [[ -n "${LM_GROUP:-}" ]]; then
        gf="${LM_HOSTS_DIR:-/etc/linux_maint/hosts.d}/${LM_GROUP}.txt"
        [[ -f "$gf" ]] || echo "NOTE: LM_GROUP=$LM_GROUP but group file not found: $gf (will fall back)" >&2
      fi

      # best-effort host resolution using library if available
      if [[ -f "${LINUX_MAINT_LIB:-/usr/local/lib/linux_maint.sh}" ]]; then
        # shellcheck disable=SC1090
        . "${LINUX_MAINT_LIB:-/usr/local/lib/linux_maint.sh}" >/dev/null 2>&1 || true
        if command -v lm_hosts >/dev/null 2>&1; then
          mapfile -t _hosts < <(lm_hosts)
          if [[ "${SHUFFLE:-0}" -eq 1 ]]; then
            mapfile -t _hosts < <(printf '%s\n' "${_hosts[@]}" | shuf)
          fi
          if [[ "${LIMIT:-0}" -gt 0 ]]; then
            mapfile -t _hosts < <(printf '%s\n' "${_hosts[@]}" | head -n "${LIMIT}")
          fi

          echo "Resolved hosts (${#_hosts[@]}):"
          printf '%s\n' "${_hosts[@]}"
          exit 0
        fi
      fi
      echo "DRY RUN requested, but cannot resolve hosts (library not available)." >&2
      exit 0
    fi

    # In installed mode, try sudo -n first. In repo mode, just run.
    if [[ "$wrapper" == "$SBIN"/* ]]; then
      exec sudo -n "$wrapper" 2>/dev/null || exec "$wrapper"
    else
      exec bash "$wrapper"
    fi
    ;;


  diff)
    # Show diff of monitor= lines since last run.
    # Uses the same state file as the wrapper: last_summary_monitor_lines.log
    JSON=0
    if [[ "${1:-}" == "--json" ]]; then JSON=1; shift; fi

    if [[ "$MODE" == "repo" ]]; then
      DIFF_STATE_DIR="${LM_NOTIFY_STATE_DIR:-${LM_STATE_DIR:-$REPO_LOG_DIR}}"
      SUMMARY_LATEST="$REPO_SUMMARY_LATEST"
    else
      DIFF_STATE_DIR="${LM_NOTIFY_STATE_DIR:-${LM_STATE_DIR:-/var/lib/linux_maint}}"
      SUMMARY_LATEST="$INST_SUMMARY_LATEST"
    fi
    PREV_SUMMARY="$DIFF_STATE_DIR/last_summary_monitor_lines.log"

    echo "diff_state_dir=$DIFF_STATE_DIR"
    echo "diff_prev=$PREV_SUMMARY"
    echo "diff_cur=$CUR_SUMMARY"
    CUR_SUMMARY="$SUMMARY_LATEST"

    if [[ ! -f "$CUR_SUMMARY" ]]; then
      echo "No current summary file: $CUR_SUMMARY" >&2
      echo "Run linux-maint run first." >&2
      exit 1
    fi
    if [[ ! -f "$PREV_SUMMARY" ]]; then
      echo "No previous diff state file: $PREV_SUMMARY" >&2
      echo "The wrapper writes this after each run (best-effort). Typically you need to run linux-maint run twice to get a useful diff." >&2
      exit 1
    fi

    if [[ "$MODE" == "repo" ]]; then
      diff_tool="$REPO_ROOT/tools/summary_diff.py"
    else
      diff_tool="$LIBEXEC/summary_diff.py"
    fi
    if [[ ! -x "$diff_tool" ]]; then
      # In installed mode, tools/ may not exist; try a system python module not available; fallback to error.
      echo "Diff tool not found/executable: $diff_tool" >&2
      echo "Hint: ensure summary_diff.py is installed (expected at $LIBEXEC/summary_diff.py)" >&2
      exit 1
    fi

    if [[ "$JSON" -eq 1 ]]; then
      exec python3 "$diff_tool" "$PREV_SUMMARY" "$CUR_SUMMARY" --json
    else
      exec python3 "$diff_tool" "$PREV_SUMMARY" "$CUR_SUMMARY"
    fi
    ;;
  logs)
    if [[ "$MODE" == "installed" ]]; then
      need_root_for logs
    fi
        n="${1:-200}"
        if [[ "$MODE" == "repo" ]]; then
          mkdir -p "$REPO_LOG_DIR"
          [[ -f "$REPO_LATEST_LOG" ]] || { echo "No repo log yet: $REPO_LATEST_LOG"; exit 1; }
          tail -n "$n" "$REPO_LATEST_LOG"
        else
          exec sudo -n tail -n "$n" /var/log/health/full_health_monitor_latest.log 2>/dev/null || tail -n "$n" /var/log/health/full_health_monitor_latest.log
        fi
    ;;

  version)
    if [[ -f "$SHARE/BUILD_INFO" ]]; then
      cat "$SHARE/BUILD_INFO"
    else
      echo "BUILD_INFO not found at $SHARE/BUILD_INFO"
      exit 1
    fi
    ;;

  preflight)
    if [[ "$MODE" == "installed" ]]; then
      need_root_for preflight
    fi
    exec bash "$preflight"
    ;;

  validate)
    if [[ "$MODE" == "installed" ]]; then
      need_root_for validate
    fi
    exec bash "$validate"
    ;;

  status)
    if [[ "$MODE" == "installed" ]]; then
      need_root_for status
    fi

    ONLY=""
    TAIL_N=200
    VERBOSE=0
    QUIET=0
    PROB_N=20
    JSON=0
    LAST_N=0
    HOST_FILTER=""
    MONITOR_FILTER=""
    MATCH_MODE="contains"


    while [[ $# -gt 0 ]]; do
      case "$1" in
        --only) ONLY="$2"; shift 2;;
        --tail) TAIL_N="$2"; shift 2;;
        --verbose) VERBOSE=1; shift 1;;
        --quiet) QUIET=1; shift 1;;
        --json) JSON=1; shift 1;;
        --host) HOST_FILTER="$2"; shift 2;;
        --monitor) MONITOR_FILTER="$2"; shift 2;;
        --match-mode) MATCH_MODE="$2"; shift 2;;
        --problems) PROB_N="$2"; shift 2;;
        --last) LAST_N="$2"; shift 2;;
        -h|--help)
          echo "Usage: linux-maint status [--only OK|WARN|CRIT|UNKNOWN|SKIP] [--host PATTERN] [--monitor PATTERN] [--match-mode contains|exact|regex] [--tail N] [--verbose] [--quiet] [--json] [--problems N (max 100)] [--last N]"
          exit 0;;
        *) echo "Unknown status flag: $1" >&2; exit 2;;
      esac
    done

    case "$MATCH_MODE" in
      contains|exact|regex) ;;
      *)
        echo "ERROR: invalid --match-mode '$MATCH_MODE' (use contains|exact|regex)" >&2
        exit 2
        ;;
    esac

    # Validate/cap PROB_N (default 20, max 100)
    if [[ ! "$PROB_N" =~ ^[0-9]+$ ]]; then
      PROB_N=20
    JSON=0

    elif (( PROB_N > 100 )); then
      PROB_N=100
    elif (( PROB_N < 0 )); then
      PROB_N=0
    fi

    # History mode: show last N wrapper runs (best-effort)
    if [[ "${LAST_N:-0}" -gt 0 ]]; then
      if [[ "$MODE" == "repo" ]]; then
        log_dir="$REPO_LOG_DIR"
      else
        log_dir="/var/log/health"
      fi
      echo "=== Last ${LAST_N} runs ==="
      # shellcheck disable=SC2012
      ls -1t "$log_dir"/full_health_monitor_summary_[0-9][0-9][0-9][0-9]-[0-9][0-9]-[0-9][0-9]_[0-9][0-9][0-9][0-9][0-9][0-9].log 2>/dev/null | head -n "$LAST_N" | while read -r f; do
        ts="$(basename "$f" | sed -E "s/^full_health_monitor_summary_([0-9-]+)_(\\d+)[.]log$/\1T\2/")"
        totals="$(awk '/^monitor=/{for(i=1;i<=NF;i++) if($i ~ /^status=/){split($i,a,"="); s=a[2]; c[s]++}} END{printf("CRIT=%d WARN=%d UNKNOWN=%d SKIP=%d OK=%d",c["CRIT"]+0,c["WARN"]+0,c["UNKNOWN"]+0,c["SKIP"]+0,c["OK"]+0)}' "$f" 2>/dev/null)"
        echo "$ts $totals file=$f"
      done
      exit 0
    fi

    if [[ "$JSON" -eq 1 ]]; then
      # JSON mode: emit a single JSON object and exit.
      status_file=""
      if [[ "$MODE" == "repo" ]]; then
        status_file="$REPO_STATUS_FILE"
      else
        status_file="/var/log/health/last_status_full"
      fi

      summary_file=""
      if [[ "$MODE" == "repo" ]]; then
        summary_file="$REPO_SUMMARY_LATEST"
      else
        summary_file="$INST_SUMMARY_LATEST"
      fi

      python3 - "$MODE" "$status_file" "$summary_file" "$ONLY" "$PROB_N" "$HOST_FILTER" "$MONITOR_FILTER" "$MATCH_MODE" <<'PY'
import json, os, re, sys

mode, status_path, summary_path, only, limit, host_filter, monitor_filter, match_mode = sys.argv[1:9]
limit=int(limit)

def read_kv(path):
    d={}
    if not path or not os.path.exists(path):
        return d
    with open(path,'r',encoding='utf-8',errors='ignore') as f:
        for line in f:
            line=line.strip()
            if not line or '=' not in line:
                continue
            k,v=line.split('=',1)
            d[k]=v
    return d

def get_kv(line, key):
    m=re.search(rf"\b{re.escape(key)}=([^ ]+)", line)
    return m.group(1) if m else None

def matched(value, flt):
    if not flt:
        return True
    if match_mode == 'contains':
        return flt in value
    if match_mode == 'exact':
        return value == flt
    try:
        return re.search(flt, value) is not None
    except re.error as e:
        print(f"ERROR: invalid regex for --match-mode regex: {e}", file=sys.stderr)
        sys.exit(2)

status=read_kv(status_path)

counts={}
problems=[]
if summary_path and os.path.exists(summary_path):
    with open(summary_path,'r',encoding='utf-8',errors='ignore') as f:
        for line in f:
            line=line.strip()
            if not line.startswith('monitor='):
                continue
            st=get_kv(line,'status') or 'UNKNOWN'
            host=get_kv(line,'host') or ''
            monitor=get_kv(line,'monitor') or ''
            if only and st != only:
                continue
            if not matched(host, host_filter):
                continue
            if not matched(monitor, monitor_filter):
                continue
            counts[st]=counts.get(st,0)+1
            if st!='OK':
                mon=monitor or 'unknown_monitor'
                reason=get_kv(line,'reason')
                entry={'status':st,'monitor':mon,'host':host}
                if reason:
                    entry['reason']=reason
                problems.append(entry)

sev_order={'CRIT':0,'WARN':1,'UNKNOWN':2,'SKIP':3,'OK':4}
problems.sort(key=lambda e: sev_order.get(e.get('status','UNKNOWN'), 9))

out={
    'mode': mode,
    'last_status': status,
    'summary_file': summary_path if summary_path and os.path.exists(summary_path) else None,
    'totals': {k: counts.get(k,0) for k in ['CRIT','WARN','UNKNOWN','SKIP','OK']},
    'problems': problems[:limit],
}
print(json.dumps(out, indent=2, sort_keys=True))
PY
      exit 0
    fi
    if [[ "$QUIET" -eq 0 ]]; then

    if [[ "$MODE" == "repo" ]]; then
      echo "=== Mode ==="
      echo "repo"
      echo "repo_root: $REPO_ROOT"
      echo "linux_maint_lib: ${LINUX_MAINT_LIB:-}"
      echo "logs: $REPO_LOG_DIR"
      echo ""; echo "=== Last run status ==="
      if [[ -f "$REPO_STATUS_FILE" ]]; then
        cat "$REPO_STATUS_FILE"
      else
        echo "No status file: $REPO_STATUS_FILE"
      fi
    else
      status_file="/var/log/health/last_status_full"
      echo "=== Mode ==="
      echo "installed"
      echo "prefix: $PREFIX"
      echo ""; echo "=== Installed paths ==="
      echo "wrapper: $SBIN/run_full_health_monitor.sh"
      echo "libexec: $LIBEXEC"
      echo "build_info: $SHARE/BUILD_INFO"
      [[ -f "$SHARE/BUILD_INFO" ]] && { echo ""; cat "$SHARE/BUILD_INFO"; }
      echo ""; echo "=== Last run status ==="
      if [[ -f "$status_file" ]]; then
        cat "$status_file"
      else
        echo "No status file: $status_file"
      fi
    fi

    fi

    # Default: compact summary (hide OK). Use --verbose to show full tail of summary file.
    VERBOSE=${VERBOSE:-0}

    if [[ "$QUIET" -eq 0 ]]; then
      echo ""; echo "=== Summary (compact) ==="
    fi
    summary_file=""
    if [[ "$MODE" == "repo" ]]; then
      summary_file="$REPO_SUMMARY_LATEST"
    else
      summary_file="$INST_SUMMARY_LATEST"
    fi

    if [[ -f "$summary_file" ]]; then
      if [[ "$VERBOSE" -eq 1 ]]; then
        echo "(verbose; last $TAIL_N lines from: $summary_file)"
        if [[ -n "$ONLY" || -n "$HOST_FILTER" || -n "$MONITOR_FILTER" ]]; then
          python3 - "$summary_file" "$TAIL_N" "$ONLY" "$HOST_FILTER" "$MONITOR_FILTER" "$MATCH_MODE" <<'PY'
import re, sys

path, tail_n, only, host_filter, monitor_filter, match_mode = sys.argv[1:7]
tail_n=int(tail_n)

def get_kv(line, key):
    m=re.search(rf"\b{re.escape(key)}=([^ ]+)", line)
    return m.group(1) if m else None

def matched(value, flt):
    if not flt:
        return True
    if match_mode == 'contains':
        return flt in value
    if match_mode == 'exact':
        return value == flt
    try:
        return re.search(flt, value) is not None
    except re.error as e:
        print(f"ERROR: invalid regex for --match-mode regex: {e}", file=sys.stderr)
        sys.exit(2)

matched=[]
with open(path, 'r', encoding='utf-8', errors='ignore') as f:
    for line in f:
        line=line.strip()
        if not line.startswith('monitor='):
            continue
        st=get_kv(line,'status') or 'UNKNOWN'
        host=get_kv(line,'host') or ''
        monitor=get_kv(line,'monitor') or ''
        if only and st != only:
            continue
        if not matched(host, host_filter):
            continue
        if not matched(monitor, monitor_filter):
            continue
        matched.append(line)

for line in matched[-tail_n:]:
    print(line)
PY
        else
          tail -n "$TAIL_N" "$summary_file" || true
        fi
      else
        [[ "$QUIET" -eq 0 ]] && echo "(from: $summary_file)"
        python3 - "$summary_file" "$ONLY" "$PROB_N" "$HOST_FILTER" "$MONITOR_FILTER" "$MATCH_MODE" <<'PY'
import re, sys
path, only, limit, host_filter, monitor_filter, match_mode = sys.argv[1:7]
limit=int(limit)

# Example line:
# monitor=config_validate host=localhost status=WARN node=localhost warn=1 crit=0 reason=...

def get_kv(line, key):
    m=re.search(rf"\b{re.escape(key)}=([^ ]+)", line)
    return m.group(1) if m else None

def matched(value, flt):
    if not flt:
        return True
    if match_mode == 'contains':
        return flt in value
    if match_mode == 'exact':
        return value == flt
    try:
        return re.search(flt, value) is not None
    except re.error as e:
        print(f"ERROR: invalid regex for --match-mode regex: {e}", file=sys.stderr)
        sys.exit(2)

counts={}
problems=[]
with open(path, 'r', encoding='utf-8', errors='ignore') as f:
    for line in f:
        line=line.strip()
        if not line:
            continue
        st=get_kv(line,'status') or 'UNKNOWN'
        host=get_kv(line,'host') or ''
        monitor=get_kv(line,'monitor') or ''
        if only and st != only:
            continue
        if not matched(host, host_filter):
            continue
        if not matched(monitor, monitor_filter):
            continue
        counts[st]=counts.get(st,0)+1
        if st == 'OK':
            continue
        mon=monitor or 'unknown_monitor'
        reason=get_kv(line,'reason')
        # Format D: "STATUS monitor reason=..." (reason only if exists)
        if reason:
            problems.append(f"{st} {mon} host={host} reason={reason}")
        else:
            problems.append(f"{st} {mon} host={host}")

order=['CRIT','WARN','UNKNOWN','SKIP','OK']
print('totals: ' + ' '.join(f"{k}={counts.get(k,0)}" for k in order))

if problems:
    print("\nproblems:")
    sev_order={'CRIT':0,'WARN':1,'UNKNOWN':2,'SKIP':3}
    problems.sort(key=lambda s: sev_order.get(s.split(' ',1)[0], 9))
    for l in problems[:limit]:
        print(l)
else:
    print('\nproblems: none (all OK)')
PY
      fi
    else
      echo "No summary file: $summary_file"
      echo "Possible reasons:"
      echo "- linux-maint has not been run yet"
      echo "- wrapper ran with a different LOG_DIR/SUMMARY_DIR"
      echo "- permission issue creating/writing in /var/log/health (try sudo)"
      echo "Tips:"
      echo "- Run: sudo linux-maint run"
      echo "- Or inspect latest wrapper log: sudo linux-maint logs 200"
      echo "- Or run: sudo linux-maint doctor"
      echo "Falling back to grepping latest wrapper log"
      log="/var/log/health/full_health_monitor_latest.log"
      [[ "$MODE" == "repo" ]] && log="$REPO_LATEST_LOG"
      if [[ -f "$log" ]]; then
        grep -E " status=(WARN|CRIT|UNKNOWN)|SKIP:|SUMMARY_RESULT|FINAL_STATUS_SUMMARY|^\\[.*\\] monitor=" "$log" | tail -n 120 || true
      else
        echo "No log: $log"
      fi
    fi
    ;;

  install)
    exec sudo ./install.sh "$@"
    ;;

  uninstall)
    exec sudo ./install.sh --uninstall "$@"
    ;;

  make-tarball)
    exec ./tools/make_tarball.sh "$@"
    ;;

  init)
    if [[ "$MODE" == "installed" ]]; then
      need_root_for init
    fi

    INIT_MINIMAL=0
    case "${1:-}" in
      --minimal) INIT_MINIMAL=1; shift ;;
      "") ;;
      *) echo "Unknown init flag: $1" >&2; exit 2 ;;
    esac

    CFG_DIR="${LM_CFG_DIR:-/etc/linux_maint}"
    # Prefer repo templates in repo mode; in installed mode use PREFIX share templates.
    SRC_DIR="$REPO_ROOT/etc/linux_maint"
    if [[ "$MODE" == "installed" ]]; then
      ALT="$SHARE/templates/linux_maint"
      [[ -d "$ALT" ]] && SRC_DIR="$ALT"
    fi
    if [[ -z "$SRC_DIR" || ! -d "$SRC_DIR" ]]; then
      echo "ERROR: templates not found at $SRC_DIR" >&2
      echo "Run init from a git checkout:" >&2
      echo "  git clone https://github.com/ShenhavHezi/linux_Maint_Scripts.git" >&2
      echo "  cd linux_Maint_Scripts" >&2
      echo "  sudo ./bin/linux-maint init" >&2
      exit 1
    fi

    sudo mkdir -p "$CFG_DIR"
    if [[ "$INIT_MINIMAL" -eq 0 ]]; then
      sudo mkdir -p "$CFG_DIR/baselines" "$CFG_DIR/baselines/ports" "$CFG_DIR/baselines/configs" "$CFG_DIR/baselines/users" "$CFG_DIR/baselines/sudoers"
    fi

    if [[ "$INIT_MINIMAL" -eq 1 ]]; then
      init_templates=(
        "$SRC_DIR/servers.txt.example"
        "$SRC_DIR/excluded.txt.example"
        "$SRC_DIR/services.txt.example"
      )
    else
      shopt -s nullglob
      init_templates=("$SRC_DIR"/*.example)
    fi

    for f in "${init_templates[@]}"; do
      [[ -f "$f" ]] || continue
      base="$(basename "$f" .example)"
      dest="$CFG_DIR/$base"
      if [[ -e "$dest" ]]; then
        echo "keep:   $dest (exists)"
      else
        sudo install -m 0644 "$f" "$dest"
        echo "create: $dest"
      fi
    done

    echo ""
    echo "Next steps:"
    echo "  - Edit $CFG_DIR/servers.txt"
    echo "  - Run: sudo linux-maint doctor"
    if [[ "$INIT_MINIMAL" -eq 1 ]]; then
      echo "  - Optional later: run 'sudo linux-maint init' to install full optional templates"
    fi
    ;;





  explain)
    sub="${1:-}"; shift || true
    case "$sub" in
      reason)
        token="${1:-}"
        if [[ -z "$token" ]]; then
          echo "Usage: linux-maint explain reason <token>" >&2
          exit 2
        fi
        f="$REPO_ROOT/docs/REASONS.md"
        if [[ ! -f "$f" ]]; then
          # installed mode: docs may be under share
          for alt in \
            "$SHARE/docs/REASONS.md" \
            "$PREFIX/share/linux_Maint_Scripts/docs/REASONS.md" \
            "$PREFIX/share/linux-maint/docs/REASONS.md" \
            "/usr/share/linux_Maint_Scripts/docs/REASONS.md" \
            "/usr/share/linux-maint/docs/REASONS.md" \
            "/usr/share/linux_maint/docs/REASONS.md" \
          ; do
            if [[ -f "$alt" ]]; then f="$alt"; break; fi
          done
        fi
        if [[ ! -f "$f" ]]; then
          echo "ERROR: reasons doc not found: $f" >&2
          exit 1
        fi
        # Look for a bullet line that contains `- token â€” ...` under any section.
        # Print the matching line(s) plus the section header immediately above.
        awk -v tok="$token" '
          BEGIN{sec=""; found=0}
          /^### /{sec=$0}
          $0 ~ "- `"tok"`" {
            if (sec!="") {print sec}
            print $0
            found=1
          }
          END{exit(found?0:1)}
        ' "$f" && exit 0

        # Fallback: substring search
        if grep -n -i -F "$token" "$f" >/dev/null 2>&1; then
          echo "No exact token match; showing closest lines:" >&2
          grep -n -i -F "$token" "$f" | head -n 20
          exit 0
        fi
        echo "Unknown reason token: $token" >&2
        exit 1
        ;;

      status)
        st="${1:-}"
        if [[ -z "$st" ]]; then
          echo "Usage: linux-maint explain status <OK|WARN|CRIT|UNKNOWN|SKIP>" >&2
          exit 2
        fi
        case "$st" in
          OK) echo "OK: check succeeded; no action required." ;;
          WARN) echo "WARN: potential issue; attention suggested." ;;
          CRIT) echo "CRIT: actionable failure; immediate attention required." ;;
          UNKNOWN) echo "UNKNOWN: check could not be completed reliably (missing tool/permission/unexpected error)." ;;
          SKIP) echo "SKIP: check intentionally did not run (missing optional config/baseline/unsupported environment)." ;;
          *) echo "Unknown status: $st" >&2; exit 2 ;;
        esac
        ;;

      *)
        echo "Usage: linux-maint explain <reason|status> ..." >&2
        exit 2
        ;;
    esac
    ;;


  pack-logs)
    OUT=""
    if [[ "${1:-}" == "--out" ]]; then
      OUT="${2:-}"; shift 2 || true
    fi

    # Default output directory:
    # - repo mode: repo root
    # - installed: current directory
    if [[ -z "$OUT" ]]; then
      if [[ "$MODE" == "repo" ]]; then
        OUT="$REPO_ROOT"
      else
        OUT="."
      fi
    fi

    # Determine log dir for mode
    if [[ "$MODE" == "repo" ]]; then
      _logdir="$REPO_LOG_DIR"
      _repo_root="$REPO_ROOT"
    else
      _logdir="${LOG_DIR:-/var/log/health}"
      _repo_root=""
    fi

    # Use best-effort state dir (where notify/summary diff stores state)
    _state_dir="${LM_NOTIFY_STATE_DIR:-${LM_STATE_DIR:-/var/lib/linux_maint}}"

    OUTDIR="$OUT" LOG_DIR="$_logdir" CFG_DIR="${LM_CFG_DIR:-/etc/linux_maint}" STATE_DIR="$_state_dir" REPO_ROOT="$_repo_root" \
      ./tools/pack_logs.sh
    ;;
  verify-install)
    echo "=== linux-maint verify-install ==="
    echo "mode=$MODE"
    echo "prefix=$PREFIX"
    echo "wrapper=$wrapper"
    echo "lib=${LINUX_MAINT_LIB:-/usr/local/lib/linux_maint.sh}"

    fail=0

    check_file() {
      local label="$1" path="$2"
      if [[ -e "$path" ]]; then
        echo "OK: $label: $path"
      else
        echo "MISSING: $label: $path" >&2
        fail=1
      fi
    }

    check_exec() {
      local label="$1" path="$2"
      if [[ -x "$path" ]]; then
        echo "OK: $label: $path"
      elif [[ -e "$path" ]]; then
        echo "NOT EXECUTABLE: $label: $path" >&2
        fail=1
      else
        echo "MISSING: $label: $path" >&2
        fail=1
      fi
    }

    check_writable_dir() {
      local label="$1" path="$2"
      if [[ -d "$path" ]]; then
        if ( : > "$path/.linux_maint_write_test" ) 2>/dev/null; then
          rm -f "$path/.linux_maint_write_test" 2>/dev/null || true
          echo "OK: writable $label: $path"
        else
          echo "WARN: not writable $label: $path" >&2
        fi
      else
        echo "WARN: missing dir $label: $path" >&2
      fi
    }

    # Core files
    check_exec "wrapper" "$wrapper"
    check_file "library" "${LINUX_MAINT_LIB:-/usr/local/lib/linux_maint.sh}"

    if [[ "$MODE" == "repo" ]]; then
      check_file "monitors dir" "$REPO_MONITORS"
      check_file "tools dir" "$REPO_ROOT/tools"
    else
      check_file "libexec" "$LIBEXEC"
    fi

    echo "== Config =="
    CFG_DIR="${LM_CFG_DIR:-/etc/linux_maint}"
    echo "cfg_dir=$CFG_DIR"
    if [[ -d "$CFG_DIR" ]]; then
      check_file "servers" "$CFG_DIR/servers.txt"
      check_file "excluded" "$CFG_DIR/excluded.txt"
      check_file "services" "$CFG_DIR/services.txt"
    else
      echo "WARN: config dir missing: $CFG_DIR" >&2
    fi

    echo "== Writable locations =="
    check_writable_dir "lockdir" "${LM_LOCKDIR:-/var/lock}"
    check_writable_dir "state" "${LM_STATE_DIR:-/var/lib/linux_maint}"
    check_writable_dir "logs" "${LOG_DIR:-/var/log/health}"

    echo "== Version =="
    "$0" version || true

    echo "== systemd (best-effort) =="
    if command -v systemctl >/dev/null 2>&1; then
      # If unit files exist, report basic state; do not fail if systemd is not running.
      svc="/usr/lib/systemd/system/linux-maint.service"
      tmr="/usr/lib/systemd/system/linux-maint.timer"
      if [[ -f "$svc" || -f "$tmr" ]]; then
        [[ -f "$svc" ]] && echo "OK: unit file: $svc" || echo "WARN: missing unit file: $svc" >&2
        [[ -f "$tmr" ]] && echo "OK: unit file: $tmr" || echo "WARN: missing unit file: $tmr" >&2
        systemctl is-enabled linux-maint.timer >/dev/null 2>&1 && echo "OK: timer enabled" || echo "INFO: timer not enabled (or systemd unavailable)"
        systemctl is-active linux-maint.timer >/dev/null 2>&1 && echo "OK: timer active" || echo "INFO: timer not active (or systemd unavailable)"
      else
        echo "INFO: systemd unit files not present (ok if not installed with --with-timer)"
      fi
    else
      echo "INFO: systemctl not found"
    fi

    if [[ "$fail" -ne 0 ]]; then
      echo "verify-install FAIL" >&2
      exit 1
    fi

    echo "verify-install ok"
    ;;
  doctor)
    if [[ "$MODE" == "installed" ]]; then
      need_root_for doctor
    fi

    DOCTOR_JSON=0
    case "${1:-}" in
      --json) DOCTOR_JSON=1; shift ;;
      "") ;;
      *) echo "Unknown doctor flag: $1" >&2; exit 2 ;;
    esac

    CFG_DIR="${LM_CFG_DIR:-/etc/linux_maint}"

    if [[ "$DOCTOR_JSON" -eq 1 ]]; then
      MODE="$MODE" PREFIX="$PREFIX" WRAPPER="$wrapper" LIBEXEC="$LIBEXEC" LINUX_MAINT_LIB="${LINUX_MAINT_LIB:-/usr/local/lib/linux_maint.sh}" CFG_DIR="$CFG_DIR" python3 - <<'PYJSON'
import json
import os
import pathlib
import shutil

mode = os.environ.get("MODE", "")
prefix = os.environ.get("PREFIX", "")
wrapper = os.environ.get("WRAPPER", "")
libexec = os.environ.get("LIBEXEC", "")
lib = os.environ.get("LINUX_MAINT_LIB", "")
cfg_dir = os.environ.get("CFG_DIR", "/etc/linux_maint")

cfg_path = pathlib.Path(cfg_dir)


def has_cmd(cmd: str) -> bool:
    return shutil.which(cmd) is not None


def active_hosts_count(path: pathlib.Path) -> int:
    if not path.is_file():
        return 0
    count = 0
    for raw in path.read_text(errors="ignore").splitlines():
        line = raw.strip()
        if not line or line.startswith("#"):
            continue
        count += 1
    return count


config_files = ["servers.txt", "excluded.txt", "services.txt", "emails.txt"]
config = {
    "dir_exists": cfg_path.is_dir(),
    "files": {name: (cfg_path / name).exists() for name in config_files},
    "hosts_configured": active_hosts_count(cfg_path / "servers.txt"),
}

gates = [
    ("cert_monitor", "certs.txt"),
    ("network_monitor", "network_targets.txt"),
    ("ports_baseline_monitor", "ports_baseline.txt"),
    ("config_drift_monitor", "config_paths.txt"),
    ("user_monitor", "baseline_users.txt"),
    ("user_monitor", "baseline_sudoers.txt"),
    ("backup_check", "backup_targets.csv"),
]
monitor_gates = []
for mon, fn in gates:
    p = cfg_path / fn
    monitor_gates.append(
        {
            "monitor": mon,
            "path": str(p),
            "present": p.exists() and p.stat().st_size > 0,
        }
    )

dep_hints = [
    ("awk", "gawk"),
    ("sed", "sed"),
    ("grep", "grep"),
    ("df", "coreutils"),
    ("find", "findutils"),
    ("timeout", "coreutils"),
    ("curl", "curl"),
    ("openssl", "openssl"),
    ("ssh", "openssh-clients"),
    ("systemctl", "systemd"),
]
dependencies = [{"cmd": c, "present": has_cmd(c), "hint": h} for c, h in dep_hints]

writable_paths = ["/var/log/health", "/var/log/inventory", "/var/lib/linux_maint", "/var/lock"]
writable_locations = []
for d in writable_paths:
    p = pathlib.Path(d)
    writable_locations.append(
        {
            "path": d,
            "exists": p.is_dir(),
            "writable": p.is_dir() and os.access(d, os.W_OK),
        }
    )

result = {
    "mode": mode,
    "prefix": prefix,
    "wrapper": wrapper,
    "libexec": libexec,
    "lib": lib,
    "cfg_dir": cfg_dir,
    "config": config,
    "monitor_gates": monitor_gates,
    "dependencies": dependencies,
    "writable_locations": writable_locations,
    "next_actions": [
        "linux-maint verify-install",
        "sudo linux-maint init",
        "sudo linux-maint preflight",
        "sudo linux-maint run",
        "linux-maint pack-logs --out .",
    ],
}

print(json.dumps(result, sort_keys=True))
PYJSON
      exit 0
    fi

    echo "=== linux-maint doctor ==="
    echo "mode=$MODE"
    echo "prefix=$PREFIX"
    echo "wrapper=$wrapper"
    echo "libexec=$LIBEXEC"
    echo "lib=${LINUX_MAINT_LIB:-/usr/local/lib/linux_maint.sh}"
    echo "cfg_dir=$CFG_DIR"

    echo "== Files =="
    for path in "$wrapper" "${LINUX_MAINT_LIB:-/usr/local/lib/linux_maint.sh}"; do
      if [[ -e "$path" ]]; then ls -la "$path"; else echo "MISSING: $path"; fi
    done
    if [[ "$MODE" == "installed" ]]; then
      [[ -d "$LIBEXEC" ]] && ls -ld "$LIBEXEC" || echo "MISSING: $LIBEXEC"
    else
      [[ -d "$REPO_MONITORS" ]] && ls -ld "$REPO_MONITORS" || echo "MISSING: $REPO_MONITORS"
    fi

    echo "== Config presence =="
    if [[ -d "$CFG_DIR" ]]; then
      for f in "$CFG_DIR/servers.txt" "$CFG_DIR/excluded.txt" "$CFG_DIR/services.txt" "$CFG_DIR/emails.txt"; do
        [[ -e "$f" ]] && echo "OK: $f" || echo "MISSING: $f"
      done

      if [[ ! -s "$CFG_DIR/servers.txt" ]]; then
        echo "WARN: servers.txt missing/empty" >&2
      else
        n_hosts=$(grep -c -vE '^\s*(#|$)' "$CFG_DIR/servers.txt" 2>/dev/null || echo 0)
        echo "hosts_configured=$n_hosts"
        if [[ "$n_hosts" -eq 0 ]]; then
          echo "WARN: servers.txt has no active hosts (only comments/blank lines)" >&2
        fi
      fi

      if [[ -f "$CFG_DIR/services.txt" && ! -s "$CFG_DIR/services.txt" ]]; then
        echo "WARN: services.txt is empty; service monitor may be ineffective" >&2
      fi
    else
      echo "MISSING: config dir $CFG_DIR" >&2
      echo "Tip: sudo linux-maint init" >&2
    fi

    echo "== Monitor gates (what may SKIP) =="
    [[ -s "$CFG_DIR/certs.txt" ]] || echo "SKIP gate: cert_monitor -> missing/empty $CFG_DIR/certs.txt"
    [[ -s "$CFG_DIR/network_targets.txt" ]] || echo "SKIP gate: network_monitor -> missing/empty $CFG_DIR/network_targets.txt"
    [[ -s "$CFG_DIR/ports_baseline.txt" ]] || echo "SKIP gate: ports_baseline_monitor -> missing/empty $CFG_DIR/ports_baseline.txt"
    [[ -s "$CFG_DIR/config_paths.txt" ]] || echo "SKIP gate: config_drift_monitor -> missing/empty $CFG_DIR/config_paths.txt"
    [[ -s "$CFG_DIR/baseline_users.txt" ]] || echo "SKIP gate: user_monitor -> missing/empty $CFG_DIR/baseline_users.txt"
    [[ -s "$CFG_DIR/baseline_sudoers.txt" ]] || echo "SKIP gate: user_monitor -> missing/empty $CFG_DIR/baseline_sudoers.txt"
    [[ -s "$CFG_DIR/backup_targets.csv" ]] || echo "SKIP gate: backup_check -> missing/empty $CFG_DIR/backup_targets.csv"

    echo "== Dependencies (best-effort) =="
    need_cmd() {
      local cmd="$1" pkg_hint="$2"
      if command -v "$cmd" >/dev/null 2>&1; then
        echo "OK: $cmd"
      else
        echo "WARN: missing command: $cmd" >&2
        [[ -n "$pkg_hint" ]] && echo "  hint: install package: $pkg_hint" >&2
      fi
    }

    need_cmd awk "gawk"
    need_cmd sed "sed"
    need_cmd grep "grep"
    need_cmd df "coreutils"
    need_cmd find "findutils"
    need_cmd timeout "coreutils"
    need_cmd curl "curl"
    need_cmd openssl "openssl"
    need_cmd ssh "openssh-clients"
    need_cmd systemctl "systemd"

    echo "== systemd (best-effort) =="
    if command -v systemctl >/dev/null 2>&1; then
      for unit in linux-maint.timer linux-maint.service; do
        if systemctl list-unit-files --no-legend "$unit" 2>/dev/null | grep -q "^$unit"; then
          echo "UNIT: $unit"
          systemctl is-enabled "$unit" 2>/dev/null || true
          systemctl is-active "$unit" 2>/dev/null || true
        else
          echo "INFO: unit not installed: $unit"
        fi
      done
      echo "-- timers (linux-maint) --"
      systemctl list-timers --all --no-pager 2>/dev/null | grep -E "linux-maint\.timer|NEXT|^$" || true
    else
      echo "INFO: systemctl not found"
    fi

    echo "== Can write state/logs? =="
    for d in /var/log/health /var/log/inventory /var/lib/linux_maint /var/lock; do
      if [[ -d "$d" ]]; then
        if touch "$d/.lm_write_test" 2>/dev/null; then rm -f "$d/.lm_write_test"; echo "OK: writable $d"; else echo "WARN: not writable $d"; fi
      else
        echo "WARN: missing dir $d" >&2
      fi
    done

    echo "== Next recommended actions =="
    echo "- linux-maint verify-install"
    echo "- sudo linux-maint init      # if config is missing"
    echo "- sudo linux-maint preflight"
    echo "- sudo linux-maint run"
    echo "- linux-maint pack-logs --out .  # create bundle for export"
    ;;

  deps)
    if [[ "$MODE" == "installed" ]]; then
      need_root_for deps
    fi

    has_cmd() { command -v "$1" >/dev/null 2>&1 && echo yes || echo no; }

    echo "=== linux-maint deps ==="
    echo "mode=$MODE"
    echo "format: monitor|required|optional|available_required|available_optional"

    # monitor|required_cmds(optional space-separated)|optional_cmds(space-separated)
    while IFS='|' read -r mon req opt; do
      [[ -z "$mon" ]] && continue
      req_avail=0; req_total=0
      opt_avail=0; opt_total=0

      for c in $req; do
        req_total=$((req_total+1))
        [[ "$(has_cmd "$c")" == "yes" ]] && req_avail=$((req_avail+1))
      done
      for c in $opt; do
        opt_total=$((opt_total+1))
        [[ "$(has_cmd "$c")" == "yes" ]] && opt_avail=$((opt_avail+1))
      done

      echo "monitor=$mon|required=${req:-none}|optional=${opt:-none}|available_required=${req_avail}/${req_total}|available_optional=${opt_avail}/${opt_total}"
    done <<'EOF_DEPS'
preflight_check|awk sed grep df timeout ssh|curl openssl
config_validate|awk sed grep|none
health_monitor|awk sed grep ps df|none
inode_monitor|awk sed grep df|none
disk_trend_monitor|awk sed grep df|none
network_monitor|awk sed grep|curl
service_monitor|awk sed grep|systemctl
ntp_drift_monitor|awk sed grep|chronyc ntpq
patch_monitor|awk sed grep|apt yum dnf zypper
storage_health_monitor|awk sed grep|smartctl nvme
kernel_events_monitor|awk sed grep|journalctl dmesg
cert_monitor|awk sed grep|openssl
nfs_mount_monitor|awk sed grep|showmount
ports_baseline_monitor|awk sed grep|ss netstat
config_drift_monitor|awk sed grep|sha256sum md5sum
user_monitor|awk sed grep|id getent
backup_check|awk sed grep|none
inventory_export|awk sed grep hostname|ip lsblk lscpu
EOF_DEPS
    ;;


  *)
    echo "Unknown command: $cmd" >&2
    usage
    exit 2
    ;;
esac
