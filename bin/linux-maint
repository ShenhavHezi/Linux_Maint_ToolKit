#!/usr/bin/env bash
# linux-maint - CLI entrypoint for Linux_Maint_Scripts

set -euo pipefail

# Prefer a writable temp dir when creating tmp files.
TMPDIR="${TMPDIR:-/tmp}"
TUI_MENU_RC=0

# If any command requests JSON, disable color and progress globally.
for arg in "$@"; do
  if [[ "$arg" == "--json" ]]; then
    export LM_NO_COLOR=1
    export LM_PROGRESS=0
    export LM_HOST_PROGRESS=0
    break
  fi
done

# Color handling (opt-out via NO_COLOR/LM_NO_COLOR or --no-color)
LM_COLOR="${LM_COLOR:-1}"
color_enabled() {
  if [[ -n "${NO_COLOR:-}" || -n "${LM_NO_COLOR:-}" ]]; then
    return 1
  fi
  case "${LM_FORCE_COLOR:-${FORCE_COLOR:-}}" in
    1|true|TRUE|yes|YES|on|ON) return 0 ;;
  esac
  [[ "$LM_COLOR" -eq 1 ]] && [[ -t 1 ]]
}
if color_enabled; then
  C_RESET=$'\033[0m'
  C_BOLD=$'\033[1m'
  C_RED=$'\033[31m'
  C_YELLOW=$'\033[33m'
  C_GREEN=$'\033[32m'
  C_CYAN=$'\033[36m'
else
  C_RESET=""; C_BOLD=""; C_RED=""; C_YELLOW=""; C_GREEN=""; C_CYAN=""
fi

section() {
  local text="$1"
  if color_enabled; then
    echo "=== ${C_CYAN}${text}${C_RESET} ==="
  else
    echo "=== ${text} ==="
  fi
}

hint_line() {
  local text="$1"
  if color_enabled; then
    echo "${C_YELLOW}Hint:${C_RESET} $text"
  else
    echo "Hint: $text"
  fi
}

tip_line() {
  local text="$1"
  if color_enabled; then
    echo "${C_YELLOW}Tip:${C_RESET} $text"
  else
    echo "Tip: $text"
  fi
}

get_default_monitors(){
  local file="$wrapper"
  [[ -f "$file" ]] || return 1
  awk '
    BEGIN{in_block=0}
    /^declare -a scripts=\(/ {in_block=1; next}
    in_block==1 {
      if ($0 ~ /\)/) {exit}
      gsub(/#.*/, "", $0)
      if ($0 ~ /"/) {
        gsub(/"/, "", $0)
        gsub(/^[ \t]+|[ \t]+$/, "", $0)
        if ($0 != "") print $0
      }
    }
  ' "$file"
}

normalize_monitor_list(){
  local csv="$1"
  echo "$csv" | tr ',' '\n' | awk '
    {gsub(/^[ \t]+|[ \t]+$/, "", $0)}
    $0=="" {next}
    /\.sh$/ {print; next}
    {print $0 ".sh"}
  '
}

filter_monitors_only_skip(){
  local only_csv="$1"
  local skip_csv="$2"
  local list

  if [[ -n "$only_csv" ]]; then
    list="$(normalize_monitor_list "$only_csv")"
  else
    list="$(get_default_monitors 2>/dev/null || true)"
    if [[ -z "$list" ]]; then
      local scripts_dir=""
      if [[ "$MODE" == "repo" && -d "$REPO_MONITORS" ]]; then
        scripts_dir="$REPO_MONITORS"
      elif [[ -d "$LIBEXEC" ]]; then
        scripts_dir="$LIBEXEC"
      elif [[ -d "$REPO_MONITORS" ]]; then
        scripts_dir="$REPO_MONITORS"
      fi
      if [[ -n "$scripts_dir" ]]; then
        list="$(find "$scripts_dir" -maxdepth 1 -type f -name '*.sh' -printf '%f\n' 2>/dev/null | sort)"
      fi
    fi
  fi

  if [[ -n "$skip_csv" ]]; then
    local skip_list
    skip_list="$(normalize_monitor_list "$skip_csv")"
    list="$(printf '%s\n' "$list" | awk -v skip="$skip_list" '
      BEGIN{
        n=split(skip, s, "\n")
        for(i=1;i<=n;i++){ if(s[i]!="") skipset[s[i]]=1 }
      }
      {if(!skipset[$0]) print}
    ')"
  fi

  printf '%s\n' "$list"
}

available_monitors(){
  local scripts_dir=""
  if [[ "$MODE" == "repo" && -d "$REPO_MONITORS" ]]; then
    scripts_dir="$REPO_MONITORS"
  elif [[ -d "$LIBEXEC" ]]; then
    scripts_dir="$LIBEXEC"
  elif [[ -d "$REPO_MONITORS" ]]; then
    scripts_dir="$REPO_MONITORS"
  fi
  [[ -n "$scripts_dir" ]] || return 1
  find "$scripts_dir" -maxdepth 1 -type f -name '*.sh' -printf '%f\n' 2>/dev/null | sort
}

suggest_monitors(){
  local needle="$1"
  local avail="$2"
  if command -v python3 >/dev/null 2>&1; then
    MONITORS_LIST="$avail" python3 - "$needle" <<'PY'
import difflib
import os
import sys

needle = sys.argv[1].strip().lower()
choices = [l.strip() for l in os.environ.get("MONITORS_LIST","").splitlines() if l.strip()]
choices_base = [c[:-3] if c.endswith(".sh") else c for c in choices]
uniq = []
seen = set()
for c in choices_base:
    if c not in seen:
        uniq.append(c)
        seen.add(c)

matches = difflib.get_close_matches(needle, uniq, n=5, cutoff=0.45)
for m in matches:
    print(m)
PY
  else
    printf '%s\n' "$avail" | awk -v n="$needle" 'BEGIN{IGNORECASE=1} index($0,n){print $0}' | head -n 5
  fi
}

validate_monitor_list(){
  local list="$1"
  local avail
  avail="$(available_monitors 2>/dev/null || true)"
  [[ -n "$avail" ]] || return 0

  local -A known=()
  while IFS= read -r m; do
    [[ -n "$m" ]] || continue
    known["$m"]=1
    known["${m%.sh}"]=1
  done <<< "$avail"

  local missing=()
  while IFS= read -r m; do
    [[ -n "$m" ]] || continue
    if [[ -z "${known[$m]:-}" && -z "${known[${m%.sh}]:-}" ]]; then
      missing+=("$m")
    fi
  done <<< "$list"

  if [[ "${#missing[@]}" -gt 0 ]]; then
    echo "ERROR: unknown monitor(s): ${missing[*]}" >&2
    echo "Available monitors:" >&2
    printf '%s\n' "$avail" | sed 's/^/  - /' >&2
    for m in "${missing[@]}"; do
      local sug
      sug="$(suggest_monitors "$m" "$avail" | tr '\n' ' ' | sed 's/[[:space:]]*$//')"
      if [[ -n "$sug" ]]; then
        echo "Did you mean (for $m): $sug" >&2
      fi
    done
    return 2
  fi
  return 0
}

detect_tui_backend(){
  if [[ -n "${LM_TUI_BACKEND:-}" ]]; then
    case "$LM_TUI_BACKEND" in
      gum|dialog|whiptail)
        if command -v "$LM_TUI_BACKEND" >/dev/null 2>&1; then
          echo "$LM_TUI_BACKEND"
          return 0
        fi
        return 1
        ;;
      *)
        return 1
        ;;
    esac
  fi
  if command -v gum >/dev/null 2>&1; then
    echo "gum"
    return 0
  fi
  if command -v dialog >/dev/null 2>&1; then
    echo "dialog"
    return 0
  fi
  if command -v whiptail >/dev/null 2>&1; then
    echo "whiptail"
    return 0
  fi
  return 1
}

tui_gum_banner(){
  TUI_BANNER_WIDTH="${TUI_BANNER_WIDTH:-100}"
  local accent="#9ca3af"
  case "${TUI_ANIM_TICK:-0}" in
    1) accent="#60a5fa" ;;
    2) accent="#34d399" ;;
  esac
  local logo
  logo="$(cat <<'EOF'
+--------------------------------------------------------------------------------------------------+
|                                                                                                  |
|      _     _                  __  __       _       _                                             |
|     | |   (_)_ __  _   ___  _|  \/  | __ _(_)_ __ | |_                                           |
|     | |   | | '_ \| | | \ \/ / |\/| |/ _` | | '_ \| __|                                          |
|     | |___| | | | | |_| |>  <| |  | | (_| | | | | | |_                                           |
|     |_____|_|_| |_|\__,_/_/\_\_|  |_|\__,_|_|_| |_|\__|                                          |
|                                                                                 .--.             |
|                                                                                |o_o |            |
|                                                                                |:_/ |            |
|                                                                               //   \ \           |
|                                                                              (|     | )          |
|                                                                             /'\_   _/`\          |
|                                                                             \___)=(___/          |
|                                                                                                  |
|                           LinuxMaint â€¢ System Automation & Health Framework                      |
|                                                                                                  |
+--------------------------------------------------------------------------------------------------+
EOF
)"
  gum style --border none --foreground "#60a5fa" \
    --padding "0 0" --margin "1 1" --align center \
    "$logo" >&2
}

tui_gum_hint(){
  local msg="${1:-Use arrows + Enter. Esc to go back.}"
  gum style --foreground "#9ca3af" --margin "0 2" "$msg" >&2
}

tui_gum_header(){
  local title="${1:-Linux Maint ToolKit}"
  local subtitle="${2:-Menu}"
  gum style --border normal --border-foreground "#1f2937" --foreground "#f9fafb" \
    --padding "0 2" --margin "1 1" --align left --width 110 \
    "$(gum style --bold --foreground "#f9fafb" "$title")" \
    "$(gum style --foreground "#9ca3af" "$subtitle")" >&2
}

tui_latest_log_path(){
  if [[ "$MODE" == "repo" ]]; then
    echo "$REPO_LATEST_LOG"
  else
    echo "/var/log/health/full_health_monitor_latest.log"
  fi
}

tui_gum_status_overview(){
  local status_json overall ok warn crit unk skip summary_file
  status_json="$(NO_COLOR=1 "$0" status --json 2>/dev/null || true)"
  overall="UNKNOWN"
  ok=0; warn=0; crit=0; unk=0; skip=0; summary_file=""
  if [[ -n "$status_json" ]]; then
    while IFS='=' read -r k v; do
      case "$k" in
        overall) overall="$v" ;;
        ok) ok="$v" ;;
        warn) warn="$v" ;;
        crit) crit="$v" ;;
        unknown) unk="$v" ;;
        skip) skip="$v" ;;
        summary) summary_file="$v" ;;
      esac
    done < <(STATUS_JSON="$status_json" python3 - <<'PY'
import json
import os
import sys

raw = os.environ.get("STATUS_JSON", "")
if not raw:
    sys.exit(0)
try:
    data = json.loads(raw)
except Exception:
    sys.exit(0)

totals = data.get("totals", {}) or {}
def g(k):
    try:
        return int(totals.get(k, 0) or 0)
    except Exception:
        return 0

ok = g("OK")
warn = g("WARN")
crit = g("CRIT")
unk = g("UNKNOWN")
skip = g("SKIP")

if crit > 0:
    overall = "CRIT"
elif warn > 0:
    overall = "WARN"
elif unk > 0:
    overall = "UNKNOWN"
elif ok > 0:
    overall = "OK"
else:
    overall = "UNKNOWN"

summary = data.get("summary_file") or ""

print(f"overall={overall}")
print(f"ok={ok}")
print(f"warn={warn}")
print(f"crit={crit}")
print(f"unknown={unk}")
print(f"skip={skip}")
print(f"summary={summary}")
PY
    )
  fi

  local color="#60a5fa"
  case "$overall" in
    CRIT) color="#ef4444" ;;
    WARN) color="#f59e0b" ;;
    OK) color="#22c55e" ;;
    UNKNOWN) color="#93c5fd" ;;
  esac

  local log_file log_lines
  log_file="$(tui_latest_log_path)"
  if [[ -f "$log_file" ]]; then
    log_lines="$(tail -n 3 "$log_file" 2>/dev/null | sed 's/^/  /')"
  else
    log_lines="  (no log yet: $log_file)"
  fi

  local overall_line totals_line body
  overall_line="$(gum style --bold --foreground "$color" "Overall: $overall")"
  totals_line="$(gum style --foreground "#e5e7eb" "OK:$ok  WARN:$warn  CRIT:$crit  UNKNOWN:$unk  SKIP:$skip")"
  body="$(gum join --vertical "$overall_line" "$totals_line")"

  gum style --border thick --border-foreground "$color" --padding "1 3" \
    --margin "0 1" --width 110 "$body" >&2
}

tui_menu_prompt(){
  local prompt="$1"
  shift || true
  if [[ "$TUI_BACKEND" == "gum" ]]; then
    local -a items=()
    local -a raw=()
    local -a plain=()
    local -a tags=()
    local -a descs=()
    local max_len=0
    local max_tag=0
    while [[ $# -gt 0 ]]; do
      local tag="$1"
      local desc="$2"
      shift 2
      tags+=("$tag")
      descs+=("$desc")
      local tag_len=${#tag}
      if [[ "$tag_len" -gt "$max_tag" ]]; then
        max_tag="$tag_len"
      fi
    done
    for i in "${!tags[@]}"; do
      local tag="${tags[$i]}"
      local desc="${descs[$i]}"
      local padded_tag
      padded_tag="$(printf '%-*s' "$max_tag" "$tag")"
      local plain_line="${padded_tag}: ${desc}"
      plain+=("$plain_line")
      local len=${#plain_line}
      if [[ "$len" -gt "$max_len" ]]; then
        max_len="$len"
      fi
      local color
      color="$(tui_tag_color "$tag")"
      local colored_tag
      colored_tag="$(gum style --bold --foreground "$color" "$padded_tag")"
      raw+=("${colored_tag}: ${desc}")
    done
    if [[ "${TUI_MENU_STYLE:-full}" == "full" ]]; then
      tui_gum_banner
    else
      tui_gum_header "Linux Maint ToolKit" "$prompt"
    fi
    printf '\n' >&2
    tui_gum_hint "Use arrows + Enter. Esc to go back."
    local banner_w="${TUI_BANNER_WIDTH:-100}"
    local i=0
    for line in "${raw[@]}"; do
      local plain_line="${plain[$i]}"
      local pad_len=$(( (banner_w - ${#plain_line}) / 2 ))
      [[ "$pad_len" -lt 0 ]] && pad_len=0
      local line_pad
      line_pad="$(printf '%*s' "$pad_len" '')"
      items+=("${line_pad}${line}")
      i=$((i+1))
    done
    gum choose --header "" --height 16 --cursor "> " \
      --cursor-prefix "> " --selected-prefix "* " --unselected-prefix "  " \
      --show-help=false "${items[@]}"
  elif [[ "$TUI_BACKEND" == "dialog" ]]; then
    local -a menu_items=()
    local max_tag=0
    local -a tags=()
    local -a descs=()
    while [[ $# -gt 0 ]]; do
      local tag="$1"
      local desc="$2"
      shift 2
      tags+=("$tag")
      descs+=("$desc")
      local tag_len=${#tag}
      if [[ "$tag_len" -gt "$max_tag" ]]; then
        max_tag="$tag_len"
      fi
    done
    for i in "${!tags[@]}"; do
      local tag="${tags[$i]}"
      local desc="${descs[$i]}"
      local padded_tag
      padded_tag="$(printf '%-*s' "$max_tag" "$tag")"
      menu_items+=("$padded_tag" "$desc")
    done
    dialog --clear --backtitle "$TUI_BACKTITLE" --title "$TUI_TITLE" \
      --menu "$prompt" 20 78 12 "${menu_items[@]}" 3>&1 1>&2 2>&3
  else
    whiptail --title "$TUI_TITLE" --menu "$prompt" 20 78 12 "$@" 3>&1 1>&2 2>&3
  fi
}

tui_menu_prompt_safe(){
  local prompt="$1"
  shift || true
  local out rc
  TUI_MENU_RC=0
  set +e
  out="$(tui_menu_prompt "$prompt" "$@")"
  rc=$?
  set -e
  TUI_MENU_RC="$rc"
  printf '%s' "$out"
  return 0
}

tui_tag_color(){
  case "$1" in
    run) echo "#22c55e" ;;
    reports|report|trend|runtimes|status|dashboard) echo "#60a5fa" ;;
    tools|check|summary|diff|history|runindex|metrics_prom|metrics_json|pack_logs) echo "#38bdf8" ;;
    diagnostics|doctor|selfcheck|logslive|logs) echo "#f59e0b" ;;
    config|monitors) echo "#a78bfa" ;;
    help|quickref|faq|reasons|monitors_matrix|explain_reason|explain_monitor|explain_status) echo "#93c5fd" ;;
    exit|back) echo "#9ca3af" ;;
    *) echo "#93c5fd" ;;
  esac
}

tui_input(){
  local prompt="$1"
  local placeholder="${2:-}"
  local out rc
  TUI_INPUT_RC=0
  set +e
  if [[ "$TUI_BACKEND" == "gum" ]]; then
    out="$(gum input --prompt "$prompt: " --placeholder "$placeholder")"
    rc=$?
  elif [[ "$TUI_BACKEND" == "dialog" ]]; then
    out="$(dialog --clear --backtitle "$TUI_BACKTITLE" --title "$TUI_TITLE" \
      --inputbox "$prompt" 10 70 "$placeholder" 3>&1 1>&2 2>&3)"
    rc=$?
  else
    out="$(whiptail --title "$TUI_TITLE" --inputbox "$prompt" 10 70 "$placeholder" 3>&1 1>&2 2>&3)"
    rc=$?
  fi
  set -e
  TUI_INPUT_RC="$rc"
  printf '%s' "$out"
  return 0
}

tui_view_file(){
  local title="$1"
  local file="$2"
  if [[ -f "$file" ]]; then
    tui_textbox "$title" "$file"
  else
    tui_msgbox "File not found: $file"
  fi
}

tui_msgbox(){
  local msg="$1"
  if [[ "$TUI_BACKEND" == "gum" ]]; then
    gum style --border normal --border-foreground "#3b82f6" --padding "1 3" --margin "1 1" \
      --foreground "#f9fafb" "$msg" >&2
    read -r -p "Press Enter to continue..." _ </dev/tty
  elif [[ "$TUI_BACKEND" == "dialog" ]]; then
    dialog --clear --backtitle "$TUI_BACKTITLE" --title "$TUI_TITLE" \
      --msgbox "$msg" 10 70
  else
    whiptail --title "$TUI_TITLE" --msgbox "$msg" 10 70
  fi
}

tui_yesno(){
  local msg="$1"
  if [[ "$TUI_BACKEND" == "gum" ]]; then
    gum confirm "$msg"
  elif [[ "$TUI_BACKEND" == "dialog" ]]; then
    dialog --clear --backtitle "$TUI_BACKTITLE" --title "$TUI_TITLE" \
      --yesno "$msg" 10 70
  else
    whiptail --title "$TUI_TITLE" --yesno "$msg" 10 70
  fi
}

tui_textbox(){
  local title="$1"
  local file="$2"
  if [[ "$TUI_BACKEND" == "gum" ]]; then
    gum style --bold --foreground "#f9fafb" "$title" >&2
    gum pager < "$file" || true
  elif [[ "$TUI_BACKEND" == "dialog" ]]; then
    dialog --clear --backtitle "$TUI_BACKTITLE" --title "$title" \
      --textbox "$file" 22 90
  else
    whiptail --title "$title" --textbox "$file" 22 90
  fi
}

tui_colorize_file(){
  local in="$1"
  local out="$2"
  python3 - "$in" "$out" <<'PY'
import re
import sys

src, dst = sys.argv[1:3]
colors = {
    "CRIT": "\033[31m",
    "WARN": "\033[33m",
    "OK": "\033[32m",
    "UNKNOWN": "\033[34m",
    "SKIP": "\033[90m",
}
reset = "\033[0m"
status_re = re.compile(r"\b(CRIT|WARN|OK|UNKNOWN|SKIP)\b")
error_re = re.compile(r"^\s*ERROR\b", re.IGNORECASE)
warn_re = re.compile(r"^\s*WARN\b", re.IGNORECASE)

with open(src, "r", encoding="utf-8", errors="ignore") as f, open(dst, "w", encoding="utf-8") as o:
    for line in f:
        line = status_re.sub(lambda m: colors.get(m.group(1), "") + m.group(1) + reset, line)
        if error_re.search(line):
            line = "\033[31m" + line.rstrip("\n") + reset + "\n"
        elif warn_re.search(line):
            line = "\033[33m" + line.rstrip("\n") + reset + "\n"
        o.write(line)
PY
}

tui_run_cmd(){
  local title="$1"
  shift || true
  local out
  out="$(mktemp -p "$TMPDIR" linux_maint_menu.XXXXXX)"
  set +e
  NO_COLOR=1 "$@" >"$out" 2>&1
  local rc=$?
  set -e
  local label="$title"
  local view_file="$out"
  if [[ $rc -ne 0 ]]; then
    label="$title (exit $rc)"
  fi
  if [[ "$TUI_BACKEND" == "gum" ]]; then
    local colored
    colored="$(mktemp -p "$TMPDIR" linux_maint_menu_color.XXXXXX)"
    tui_colorize_file "$out" "$colored"
    view_file="$colored"
  fi
  tui_textbox "$label" "$view_file"
  rm -f "$out"
  [[ -n "${colored:-}" ]] && rm -f "$colored"
  return $rc
}

tui_run_live(){
  local title="$1"
  shift || true
  if [[ "$TUI_BACKEND" == "gum" ]]; then
    clear
    tui_gum_header "Linux Maint ToolKit" "$title"
    tui_gum_hint "Live output. Press Ctrl+C to stop."
    set +e
    env LM_PROGRESS=1 LM_PROGRESS_MODE=plain LM_PROGRESS_FORCE=1 LM_PROGRESS_WIDTH=32 "$@"
    local rc=$?
    set -e
    return $rc
  fi
  if [[ "$TUI_BACKEND" == "dialog" ]]; then
    dialog --clear --backtitle "$TUI_BACKTITLE" --title "$title" \
      --programbox "$title" 22 90 env NO_COLOR=1 LM_PROGRESS=1 LM_PROGRESS_MODE=plain LM_PROGRESS_FORCE=1 LM_PROGRESS_WIDTH=32 "$@" || true
    return 0
  fi
  tui_run_cmd "$title" "$@"
}

tui_tail_logs(){
  local log_file
  log_file="$(tui_latest_log_path)"
  if [[ ! -f "$log_file" ]]; then
    tui_msgbox "No log yet: $log_file"
    return 1
  fi
  if [[ "$TUI_BACKEND" == "dialog" ]]; then
    dialog --clear --backtitle "$TUI_BACKTITLE" --title "Live log tail" \
      --tailbox "$log_file" 22 90 || true
    return 0
  fi
  if [[ "$TUI_BACKEND" == "gum" ]]; then
    clear
    tui_gum_header "Linux Maint ToolKit" "Live log tail"
    tui_gum_hint "Press Ctrl+C to stop tail and return."
  else
    echo "Press Ctrl+C to stop tail and return."
  fi
  set +e
  tail -n 200 -f "$log_file"
  set -e
}

tui_gum_dashboard(){
  local refresh_secs="${LM_TUI_DASH_REFRESH:-0}"
  [[ "$refresh_secs" =~ ^[0-9]+$ ]] || refresh_secs=0
  while true; do
    local status_json
    status_json="$(NO_COLOR=1 "$0" status --json --problems 8 --reasons 6 2>/dev/null || true)"
    clear
    tui_gum_header "Linux Maint ToolKit" "Dashboard"
    tui_gum_status_overview

    local problems_csv reasons_csv
    problems_csv="$(STATUS_JSON="$status_json" python3 - <<'PY'
import json, os, sys
raw = os.environ.get("STATUS_JSON", "")
if not raw:
    sys.exit(0)
try:
    data = json.loads(raw)
except Exception:
    sys.exit(0)
rows = data.get("problems") or []
for row in rows[:8]:
    status = row.get("status","")
    monitor = row.get("monitor","")
    host = row.get("host","")
    reason = row.get("reason","")
    for v in (status, monitor, host, reason):
        if v is None:
            v = ""
    reason = str(reason).replace("|","/").replace("\n"," ")
    monitor = str(monitor).replace("|","/")
    host = str(host).replace("|","/")
    status = str(status).replace("|","/")
    print(f"{status}|{monitor}|{host}|{reason}")
PY
)"

    reasons_csv="$(STATUS_JSON="$status_json" python3 - <<'PY'
import json, os, sys
raw = os.environ.get("STATUS_JSON", "")
if not raw:
    sys.exit(0)
try:
    data = json.loads(raw)
except Exception:
    sys.exit(0)
rows = data.get("reason_rollup") or []
for row in rows[:6]:
    reason = row.get("reason","")
    count = row.get("count","")
    if reason is None:
        reason = ""
    reason = str(reason).replace("|","/").replace("\n"," ")
    print(f"{reason}|{count}")
PY
)"

    local problems_table reasons_table
    if [[ -n "$problems_csv" ]]; then
      problems_table="$(printf '%s\n' "$problems_csv" | gum table --separator "|" \
        --columns "Status,Monitor,Host,Reason" --border rounded --print \
        --border.foreground "#1f2937" --header.foreground "#93c5fd")"
    else
      problems_table="$(gum style --foreground "#9ca3af" "No problems detected.")"
    fi
    if [[ -n "$reasons_csv" ]]; then
      reasons_table="$(printf '%s\n' "$reasons_csv" | gum table --separator "|" \
        --columns "Reason,Count" --border rounded --print \
        --border.foreground "#1f2937" --header.foreground "#93c5fd")"
    else
      reasons_table="$(gum style --foreground "#9ca3af" "No top reasons yet.")"
    fi

    gum style --bold --foreground "#f9fafb" --margin "1 2" "Top problems" >&2
    echo "$problems_table" >&2
    gum style --bold --foreground "#f9fafb" --margin "1 2" "Top reasons" >&2
    echo "$reasons_table" >&2

    if [[ "$refresh_secs" -gt 0 ]]; then
      tui_gum_hint "Press r to refresh, q/Enter to return. Auto-refresh: ${refresh_secs}s."
    else
      tui_gum_hint "Press r to refresh, q/Enter to return. Auto-refresh: off."
    fi
    if [[ "$refresh_secs" -gt 0 ]]; then
      read -r -t "$refresh_secs" -n 1 key </dev/tty || true
    else
      read -r -n 1 key </dev/tty
    fi
    if [[ -n "${key:-}" ]]; then
      if [[ "$key" == $'\n' || "$key" == "q" || "$key" == "Q" || "$key" == $'\e' ]]; then
        break
      fi
      if [[ "$key" == "r" || "$key" == "R" ]]; then
        continue
      fi
    fi
  done
}

run_menu_run(){
  while true; do
    local choice
    choice="$(tui_menu_prompt_safe "Run actions" \
      run "Run full checks (live output)" \
      plan "Plan only (no execution)" \
      back "Back to main")"
    local rc=$TUI_MENU_RC
    if [[ $rc -ne 0 || -z "${choice:-}" ]]; then
      break
    fi
    choice="${choice#"${choice%%[! ]*}"}"
    choice="${choice%%:*}"
    case "$choice" in
      run)
        if tui_yesno "Run full checks now?"; then
          tui_run_live "linux-maint run" "$0" run
        fi
        ;;
      plan)
        tui_run_cmd "linux-maint run --plan" "$0" run --plan
        ;;
      back)
        break
        ;;
    esac
  done
}

run_menu_reports(){
  while true; do
    local choice
    choice="$(tui_menu_prompt_safe "Reports" \
      dashboard "Styled status overview" \
      status "Show status (table)" \
      report "Show report (short)" \
      trend "Show trend (last 10)" \
      runtimes "Show runtimes (last 10)" \
      back "Back to main")"
    local rc=$TUI_MENU_RC
    if [[ $rc -ne 0 || -z "${choice:-}" ]]; then
      break
    fi
    choice="${choice#"${choice%%[! ]*}"}"
    choice="${choice%%:*}"
    case "$choice" in
      dashboard)
        if [[ "$TUI_BACKEND" == "gum" ]]; then
          tui_gum_dashboard
        else
          tui_run_cmd "linux-maint status --table" "$0" status --table
        fi
        ;;
      status)
        tui_run_cmd "linux-maint status --table" "$0" status --table
        ;;
      report)
        tui_run_cmd "linux-maint report --short --no-trend" "$0" report --short --no-trend
        ;;
      trend)
        tui_run_cmd "linux-maint trend --last 10" "$0" trend --last 10
        ;;
      runtimes)
        tui_run_cmd "linux-maint runtimes --last 10" "$0" runtimes --last 10
        ;;
      back)
        break
        ;;
    esac
  done
}

run_menu_tools(){
  while true; do
    local choice
    choice="$(tui_menu_prompt_safe "Tools & automation" \
      check "Preflight + validate + expected SKIPs" \
      summary "One-line summary" \
      diff "Diff since last run" \
      history "Run history (table)" \
      runindex "Run index stats" \
      metrics_prom "Metrics (Prometheus text)" \
      metrics_json "Metrics (JSON)" \
      pack_logs "Support bundle (redacted)" \
      back "Back to main")"
    local rc=$TUI_MENU_RC
    if [[ $rc -ne 0 || -z "${choice:-}" ]]; then
      break
    fi
    choice="${choice#"${choice%%[! ]*}"}"
    choice="${choice%%:*}"
    case "$choice" in
      check)
        tui_run_cmd "linux-maint check" "$0" check
        ;;
      summary)
        tui_run_cmd "linux-maint summary" "$0" summary --no-color
        ;;
      diff)
        tui_run_cmd "linux-maint diff" "$0" diff
        ;;
      history)
        tui_run_cmd "linux-maint history --table" "$0" history --table
        ;;
      runindex)
        tui_run_cmd "linux-maint run-index --stats" "$0" run-index --stats
        ;;
      metrics_prom)
        tui_run_cmd "linux-maint metrics --prom" "$0" metrics --prom
        ;;
      metrics_json)
        tui_run_cmd "linux-maint metrics --json" "$0" metrics --json
        ;;
      pack_logs)
        if tui_yesno "Create redacted support bundle in /tmp?"; then
          tui_run_cmd "linux-maint pack-logs --out /tmp --redact" "$0" pack-logs --out /tmp --redact
        fi
        ;;
      back)
        break
        ;;
    esac
  done
}

run_menu_help(){
  while true; do
    local choice
    choice="$(tui_menu_prompt_safe "Help & docs" \
      quickref "Quick reference" \
      faq "FAQ" \
      reasons "Reasons catalog" \
      monitors "Monitors matrix" \
      explain_reason "Explain reason token" \
      explain_monitor "Explain monitor" \
      explain_status "Explain status" \
      back "Back to main")"
    local rc=$TUI_MENU_RC
    if [[ $rc -ne 0 || -z "${choice:-}" ]]; then
      break
    fi
    choice="${choice#"${choice%%[! ]*}"}"
    choice="${choice%%:*}"
    case "$choice" in
      quickref)
        tui_view_file "Quick reference" "$REPO_ROOT/docs/QUICK_REFERENCE.md"
        ;;
      faq)
        tui_view_file "FAQ" "$REPO_ROOT/docs/FAQ.md"
        ;;
      reasons)
        tui_view_file "Reasons" "$REPO_ROOT/docs/REASONS.md"
        ;;
      monitors)
        tui_view_file "Monitors matrix" "$REPO_ROOT/docs/MONITORS_MATRIX.md"
        ;;
      explain_reason)
        local token
        token="$(tui_input "Reason token" "e.g. disk_full")"
        if [[ "$TUI_INPUT_RC" -eq 0 && -n "$token" ]]; then
          tui_run_cmd "linux-maint explain reason $token" "$0" explain reason "$token"
        fi
        ;;
      explain_monitor)
        local mon
        mon="$(tui_input "Monitor name" "e.g. service_monitor")"
        if [[ "$TUI_INPUT_RC" -eq 0 && -n "$mon" ]]; then
          tui_run_cmd "linux-maint explain monitor $mon" "$0" explain monitor "$mon"
        fi
        ;;
      explain_status)
        local s
        s="$(tui_menu_prompt_safe "Pick status" \
          OK "Healthy" \
          WARN "Warning" \
          CRIT "Critical" \
          UNKNOWN "Unknown" \
          SKIP "Skipped" \
          back "Back")"
        if [[ "$TUI_MENU_RC" -eq 0 && -n "$s" ]]; then
          s="${s#"${s%%[! ]*}"}"
          s="${s%%:*}"
          if [[ "$s" != "back" ]]; then
            tui_run_cmd "linux-maint explain status $s" "$0" explain status "$s"
          fi
        fi
        ;;
      back)
        break
        ;;
    esac
  done
}

run_menu_diagnostics(){
  while true; do
    local choice
    choice="$(tui_menu_prompt_safe "Diagnostics" \
      logslive "Live log tail (stream)" \
      logs "Tail latest log" \
      doctor "Doctor (diagnose)" \
      selfcheck "Self-check (safe)" \
      back "Back to main")"
    local rc=$TUI_MENU_RC
    if [[ $rc -ne 0 || -z "${choice:-}" ]]; then
      break
    fi
    choice="${choice#"${choice%%[! ]*}"}"
    choice="${choice%%:*}"
    case "$choice" in
      logslive)
        tui_tail_logs
        ;;
      logs)
        tui_run_cmd "linux-maint logs 200" "$0" logs 200
        ;;
      doctor)
        tui_run_cmd "linux-maint doctor" "$0" doctor
        ;;
      selfcheck)
        tui_run_cmd "linux-maint self-check" "$0" self-check
        ;;
      back)
        break
        ;;
    esac
  done
}

run_menu_config(){
  while true; do
    local choice
    choice="$(tui_menu_prompt_safe "Config & inventory" \
      config "Show config" \
      monitors "List monitors" \
      back "Back to main")"
    local rc=$TUI_MENU_RC
    if [[ $rc -ne 0 || -z "${choice:-}" ]]; then
      break
    fi
    choice="${choice#"${choice%%[! ]*}"}"
    choice="${choice%%:*}"
    case "$choice" in
      config)
        tui_run_cmd "linux-maint config" "$0" config
        ;;
      monitors)
        tui_run_cmd "linux-maint list-monitors" "$0" list-monitors
        ;;
      back)
        break
        ;;
    esac
  done
}

run_menu(){
  if ! [[ -t 1 && -t 2 ]]; then
    echo "ERROR: linux-maint menu requires an interactive TTY" >&2
    exit 1
  fi

  TUI_BACKEND="$(detect_tui_backend || true)"
  if [[ -z "$TUI_BACKEND" ]]; then
    echo "ERROR: install gum, dialog, or whiptail to use linux-maint menu" >&2
    exit 1
  fi

  TUI_TITLE="linux-maint menu"
  TUI_BACKTITLE="Linux Maint ToolKit"

  if [[ "$MODE" == "installed" && $EUID -ne 0 ]]; then
    tui_msgbox "Some actions (run/doctor/summary) require root.\nRe-run with: sudo linux-maint menu"
  fi

  TUI_ANIM_TICK=0
  while true; do
    TUI_MENU_STYLE="full"
    choice="$(tui_menu_prompt_safe "Select an action" \
      run "Run / plan" \
      reports "Status / report / trend / runtimes" \
      tools "Tools & automation" \
      diagnostics "Logs / doctor / self-check" \
      config "Config / monitors" \
      help "Help & docs" \
      exit "Exit")"
    rc=$TUI_MENU_RC
    if [[ $rc -ne 0 || -z "${choice:-}" ]]; then
      break
    fi
    choice="${choice#"${choice%%[! ]*}"}"
    choice="${choice%%:*}"
    case "$choice" in
      run)
        TUI_MENU_STYLE="compact"
        run_menu_run
        ;;
      reports)
        TUI_MENU_STYLE="compact"
        run_menu_reports
        ;;
      tools)
        TUI_MENU_STYLE="compact"
        run_menu_tools
        ;;
      diagnostics)
        TUI_MENU_STYLE="compact"
        run_menu_diagnostics
        ;;
      config)
        TUI_MENU_STYLE="compact"
        run_menu_config
        ;;
      help)
        TUI_MENU_STYLE="compact"
        run_menu_help
        ;;
      exit)
        break
        ;;
    esac
    if [[ "$TUI_BACKEND" == "gum" ]]; then
      TUI_ANIM_TICK=$(( (TUI_ANIM_TICK + 1) % 3 ))
    fi
  done

  if [[ "$TUI_BACKEND" == "dialog" ]]; then
    clear
  fi
}

resolve_run_hosts(){
  local -a _hosts=()
  if [[ -f "${LINUX_MAINT_LIB:-/usr/local/lib/linux_maint.sh}" ]]; then
    # shellcheck disable=SC1090
    . "${LINUX_MAINT_LIB:-/usr/local/lib/linux_maint.sh}" >/dev/null 2>&1 || true
    if command -v lm_hosts >/dev/null 2>&1; then
      mapfile -t _hosts < <(lm_hosts)
    fi
  fi
  if [[ "${#_hosts[@]}" -eq 0 ]]; then
    _hosts=("localhost")
  fi
  if [[ "${SHUFFLE:-0}" -eq 1 ]]; then
    mapfile -t _hosts < <(printf '%s\n' "${_hosts[@]}" | shuf)
  fi
  if [[ "${LIMIT:-0}" -gt 0 ]]; then
    mapfile -t _hosts < <(printf '%s\n' "${_hosts[@]}" | head -n "${LIMIT}")
  fi
  printf '%s\n' "${_hosts[@]}"
}

# If running from a git checkout, prefer repo paths automatically.
SCRIPT_DIR="$(cd -- "$(dirname -- "${BASH_SOURCE[0]}")" && pwd)"
REPO_ROOT="$(cd -- "$SCRIPT_DIR/.." && pwd)"

PREFIX="${PREFIX:-/usr/local}"
SBIN="$PREFIX/sbin"
LIBEXEC="$PREFIX/libexec/linux_maint"
SHARE="$PREFIX/share/linux_maint"

REPO_MONITORS="$REPO_ROOT/monitors"
REPO_LIB="$REPO_ROOT/lib/linux_maint.sh"
REPO_WRAPPER="$REPO_ROOT/run_full_health_monitor.sh"

# installed defaults
wrapper="$SBIN/run_full_health_monitor.sh"
preflight="$LIBEXEC/preflight_check.sh"
validate="$LIBEXEC/config_validate.sh"

if [[ -d "$REPO_MONITORS" && -f "$REPO_LIB" ]]; then
  # repo mode
  export LINUX_MAINT_LIB="${LINUX_MAINT_LIB:-$REPO_LIB}"
  export LM_LOCKDIR="${LM_LOCKDIR:-/tmp}"
  export LM_LOGFILE="${LM_LOGFILE:-/tmp/linux_maint.log}"
  wrapper="$REPO_WRAPPER"
  preflight="$REPO_MONITORS/preflight_check.sh"
  validate="$REPO_MONITORS/config_validate.sh"
fi

MODE="installed"
[[ "$wrapper" == "$REPO_WRAPPER" ]] && MODE="repo"
REPO_LOG_DIR="$REPO_ROOT/.logs"
REPO_STATUS_FILE="$REPO_LOG_DIR/last_status_full"
REPO_LATEST_LOG="$REPO_LOG_DIR/full_health_monitor_latest.log"
REPO_SUMMARY_LATEST="$REPO_LOG_DIR/full_health_monitor_summary_latest.log"
INST_SUMMARY_LATEST="/var/log/health/full_health_monitor_summary_latest.log"


need_root_for(){
  local cmd="$1"
  if [[ "${EUID:-$(id -u)}" -ne 0 ]]; then
    if color_enabled; then
      echo "${C_RED}ERROR:${C_RESET} linux-maint $cmd requires root (installed mode)." >&2
    else
      echo "ERROR: linux-maint $cmd requires root (installed mode)." >&2
    fi
    case "$cmd" in
      run)
        hint_line "sudo linux-maint run" >&2
        echo "      (or run the wrapper directly: sudo /usr/local/sbin/run_full_health_monitor.sh)" >&2
        ;;
      status)
        hint_line "sudo linux-maint status" >&2
        ;;
      logs)
        hint_line "sudo linux-maint logs 200" >&2
        ;;
      preflight)
        hint_line "sudo linux-maint preflight" >&2
        ;;
      validate)
        hint_line "sudo linux-maint validate" >&2
        ;;
      *)
        hint_line "sudo linux-maint $cmd" >&2
        ;;
    esac
    exit 1
  fi
}


validate_ssh_opts(){
  # Reject obviously dangerous shell metacharacters.
  # NOTE: LM_SSH_OPTS is split into argv for ssh; this check reduces the risk of accidental injection.
  local s="${LM_SSH_OPTS:-}"
  [[ -z "$s" ]] && return 0

  # Disallow shell metacharacters.
  # Newline/carriage-return checks are done separately with ANSI-C escapes.
  if printf '%s' "$s" | grep -Eq '[;&|`<>]|\$\(|\$\{'; then
    echo "ERROR: unsafe characters detected in --ssh-opts / LM_SSH_OPTS" >&2
    echo "LM_SSH_OPTS=$s" >&2
    exit 2
  fi
  case "$s" in
    *$'\n'*|*$'\r'*)
      echo "ERROR: unsafe characters detected in --ssh-opts / LM_SSH_OPTS" >&2
      echo "LM_SSH_OPTS=$s" >&2
      exit 2
      ;;
  esac
}


expected_skips(){
  local cfg="${1:-/etc/linux_maint}"
  echo "Expected SKIPs (missing optional config):"
  local any=0
  if [[ ! -s "$cfg/network_targets.txt" ]]; then echo "- network_monitor (missing:$cfg/network_targets.txt)"; any=1; fi
  if [[ ! -s "$cfg/certs.txt" ]]; then echo "- cert_monitor (missing:$cfg/certs.txt)"; any=1; fi
  if [[ ! -s "$cfg/ports_baseline.txt" ]]; then echo "- ports_baseline_monitor (missing:$cfg/ports_baseline.txt)"; any=1; fi
  if [[ ! -s "$cfg/config_paths.txt" ]]; then echo "- config_drift_monitor (missing:$cfg/config_paths.txt)"; any=1; fi
  if [[ ! -s "$cfg/baseline_users.txt" || ! -s "$cfg/baseline_sudoers.txt" ]]; then
    local miss=()
    [[ ! -s "$cfg/baseline_users.txt" ]] && miss+=("$cfg/baseline_users.txt")
    [[ ! -s "$cfg/baseline_sudoers.txt" ]] && miss+=("$cfg/baseline_sudoers.txt")
    local IFS=,
    echo "- user_monitor (missing:${miss[*]})"
    any=1
  fi
  if [[ ! -s "$cfg/backup_targets.csv" ]]; then echo "- backup_check (missing:$cfg/backup_targets.csv)"; any=1; fi
  if [[ "$any" -eq 0 ]]; then
    echo "- none (all optional config present)"
  fi
}

expected_skips_text(){
  local cfg="${1:-/etc/linux_maint}"
  local out
  out="$(expected_skips "$cfg")"
  if printf '%s\n' "$out" | grep -q 'none (all optional config present)'; then
    return 1
  fi
  printf '%s\n' "$out"
  return 0
}

json_escape(){
  local s="$1"
  s="${s//\\/\\\\}"
  s="${s//\"/\\\"}"
  s="${s//$'\r'/\\r}"
  s="${s//$'\t'/\\t}"
  s="${s//$'\n'/\\n}"
  printf '%s' "$s"
}

expected_skips_json(){
  local cfg="${1:-/etc/linux_maint}"
  local first=1
  echo -n '['

  add_skip(){
    local mon="$1" missing_val="$2"
    local mon_esc missing_esc
    mon_esc="$(json_escape "$mon")"
    missing_esc="$(json_escape "$missing_val")"
    if [[ "$first" -eq 0 ]]; then echo -n ','; fi
    first=0
    printf '{"monitor":"%s","missing":"%s"}' "$mon_esc" "$missing_esc"
  }

  if [[ ! -s "$cfg/network_targets.txt" ]]; then add_skip "network_monitor" "$cfg/network_targets.txt"; fi
  if [[ ! -s "$cfg/certs.txt" ]]; then add_skip "cert_monitor" "$cfg/certs.txt"; fi
  if [[ ! -s "$cfg/ports_baseline.txt" ]]; then add_skip "ports_baseline_monitor" "$cfg/ports_baseline.txt"; fi
  if [[ ! -s "$cfg/config_paths.txt" ]]; then add_skip "config_drift_monitor" "$cfg/config_paths.txt"; fi
  if [[ ! -s "$cfg/baseline_users.txt" || ! -s "$cfg/baseline_sudoers.txt" ]]; then
    local miss=()
    [[ ! -s "$cfg/baseline_users.txt" ]] && miss+=("$cfg/baseline_users.txt")
    [[ ! -s "$cfg/baseline_sudoers.txt" ]] && miss+=("$cfg/baseline_sudoers.txt")
    local IFS=,
    add_skip "user_monitor" "missing:${miss[*]}"
  fi
  if [[ ! -s "$cfg/backup_targets.csv" ]]; then add_skip "backup_check" "$cfg/backup_targets.csv"; fi

  echo -n ']'
}

reason_next_steps(){
  local tok="$1"
  case "$tok" in
    missing_dependency)
      echo "Next steps:"
      echo "- Install the required command on the runner/host."
      echo "- See: linux-maint deps"
      ;;
    missing_optional_cmd)
      echo "Next steps:"
      echo "- Install the optional tool if you need this monitor."
      echo "- Otherwise treat this as expected SKIP."
      ;;
    ssh_unreachable)
      echo "Next steps:"
      echo "- Verify DNS/keys/firewall and LM_SSH_OPTS."
      echo "- Try: ssh <host> from the runner."
      ;;
    service_failed|failed_units)
      echo "Next steps:"
      echo "- Check: systemctl status <unit> and recent journal logs."
      echo "- Restart or fix the failing unit."
      ;;
    service_inactive)
      echo "Next steps:"
      echo "- Enable/start the unit if it is expected to be active."
      ;;
    timeout|runtime_exceeded)
      echo "Next steps:"
      echo "- Increase MONITOR_TIMEOUT_SECS or per-monitor timeouts."
      echo "- Re-run linux-maint run or the specific monitor."
      ;;
    config_missing)
      echo "Next steps:"
      echo "- Run: sudo linux-maint init"
      echo "- Populate the missing config file and re-run."
      ;;
    baseline_missing)
      echo "Next steps:"
      echo "- Generate baseline: linux-maint baseline <ports|configs|users|sudoers> --update"
      ;;
    security_updates_pending|updates_pending)
      echo "Next steps:"
      echo "- Apply your distro update workflow, then re-check."
      ;;
    timer_missing|timer_disabled|timer_inactive)
      echo "Next steps:"
      echo "- Install/enable linux-maint.timer (installed mode)."
      ;;
    permission_denied)
      echo "Next steps:"
      echo "- Ensure the runner has access to logs/state and required commands."
      ;;
    *)
      echo "Next steps:"
      echo "- See docs/REASONS.md and docs/troubleshooting.md for guidance."
      ;;
  esac
}


# ---- run() flags parsing (CLI-first, env-compatible) ----
# Maps:
#   --group G        -> LM_GROUP
#   --hosts a,b      -> LM_SERVERLIST (temp file)
#   --exclude a,b    -> LM_EXCLUDED (temp file)
#   --parallel N     -> LM_MAX_PARALLEL
#   --local-only     -> LM_LOCAL_ONLY=true
#   --ssh-opts "..." -> LM_SSH_OPTS
#   --only a,b       -> LM_MONITORS filtered list (by monitor name)
#   --skip a,b       -> LM_MONITORS filtered list (exclude monitor name)
#   --dry-run        -> print resolved hosts and exit
#   --strict         -> fail if any monitor emits malformed summary lines
#
_run_tmpfiles=()
cleanup_tmpfiles(){
  for f in "${_run_tmpfiles[@]:-}"; do rm -f "$f" 2>/dev/null || true; done
}
trap cleanup_tmpfiles EXIT

make_list_tmpfile(){
  local csv="$1" prefix="$2"
  local f
  f="$(mktemp -p "$TMPDIR" "linux_maint_${prefix}.XXXXXX")"
  _run_tmpfiles+=("$f")
  # split on comma and whitespace
  echo "$csv" | tr ',' '\n' | awk '{gsub(/^[ \t]+|[ \t]+$/,"",$0); if($0!="") print $0}' > "$f"
  echo "$f"
}

parse_run_args(){
  DRY_RUN=0
  DEBUG=0
  LIMIT=0
  SHUFFLE=0
  RUN_ONLY=""
  RUN_SKIP=""
  PLAN_ONLY=0
  RUN_JSON=0

  while [[ $# -gt 0 ]]; do
    case "$1" in
      --group)
        LM_GROUP="$2"; export LM_GROUP; shift 2;;
      --hosts)
        tmpf="$(make_list_tmpfile "$2" hosts)"; LM_SERVERLIST="$tmpf"; export LM_SERVERLIST; shift 2;;
      --exclude)
        tmpf="$(make_list_tmpfile "$2" excluded)"; LM_EXCLUDED="$tmpf"; export LM_EXCLUDED; shift 2;;
      --parallel)
        LM_MAX_PARALLEL="$2"; export LM_MAX_PARALLEL; shift 2;;
      --local-only)
        LM_LOCAL_ONLY="true"; export LM_LOCAL_ONLY; shift 1;;
      --ssh-opts)
        LM_SSH_OPTS="$2"; export LM_SSH_OPTS; shift 2;;
      --only)
        RUN_ONLY="$2"; shift 2;;
      --skip)
        RUN_SKIP="$2"; shift 2;;
      --plan)
        PLAN_ONLY=1; shift 1;;
      --json)
        RUN_JSON=1; shift 1;;
      --limit)
        LIMIT="$2"; shift 2;;
      --shuffle)
        SHUFFLE=1; shift 1;;
      --progress)
        LM_PROGRESS=1; export LM_PROGRESS; shift 1;;
      --no-progress)
        LM_PROGRESS=0; export LM_PROGRESS; shift 1;;
      --debug|--print-env)
        DEBUG=1; shift 1;;
      --dry-run)
        DRY_RUN=1; PLAN_ONLY=1; shift 1;;
      --strict)
        LM_STRICT=1; export LM_STRICT; shift 1;;
      -h|--help)
        command_usage run
        exit 0;;
      *)
        echo "Unknown run flag: $1" >&2
        exit 2;;
    esac
  done
}


usage(){
  cat <<EOF
Usage: linux-maint <command> [args]

${C_CYAN}Quick start${C_RESET}:
  (installed mode; after install.sh)
  sudo linux-maint init
  sudo linux-maint run
  sudo linux-maint status

${C_CYAN}Common commands${C_RESET}:
  run [flags]            Run the full wrapper
  menu                   Interactive terminal UI (TUI)
  list-monitors [flags]  List available monitors and config requirements
  lint-summary <file>    Validate summary/monitor lines against contract
  status [flags]         Show last run status and summary
  report [flags]         Unified report (status + trend + runtimes)
  doctor [flags]         Diagnose installation/config/state
  self-check [flags]     Quick validation (safe without sudo)
  summary                One-line summary (cron/dashboards)
  metrics --json|--prom  Snapshot status+trend+runtimes (JSON) or Prometheus text
  check [--json]         Run config_validate + preflight + show expected skips

${C_CYAN}Analysis / reporting${C_RESET}:
  trend [flags]         Aggregate severity/reason trends
  runtimes [flags]      Show per-monitor runtimes
  export --json|--csv   Export a single payload (summary_result/hosts + rows)
  history [flags]       Show recent runs (run index; faster than log scan)
  run-index [flags]     Inspect or prune the run index
  logs [n]              Tail latest wrapper log (default n=200)
  diff [--json]         Show diff since last run (uses wrapper diff state)

${C_CYAN}Setup / maintenance${C_RESET}:
  init [flags]           Install /etc/linux_maint templates (from repo checkout)
  config [flags]         Show effective config (merged from /etc/linux_maint)
  tune dark-site         Apply recommended dark-site defaults to linux-maint.conf
  baseline <...> [flags] Capture or preview baselines
  preflight              Run preflight checks
  validate               Validate config file formats (best-effort)
  check                  Run config_validate + preflight + show expected skips
  deps                   Print required/optional dependency manifest by monitor
  verify-install         Verify installation layout and systemd wiring (best-effort)
  pack-logs [flags]      Create a support bundle tar.gz (logs, config redacted, meta)

${C_CYAN}Release / packaging${C_RESET}:
  version                Print installed BUILD_INFO (if present)
  make-tarball           Build offline release tarball (tools/make_tarball.sh)
  verify-release         Verify release tarball integrity (tools/verify_release.sh)
  install [args]         Run ./install.sh (pass-through)
  uninstall [args]       Run ./install.sh --uninstall (pass-through)

${C_CYAN}Help${C_RESET}:
  help [command]          Show help for a command (shortcut for usage)
  explain reason <token>  Explain a reason= token (from docs/REASONS.md)
  explain monitor <name>  Explain a monitor (purpose, deps, common reasons)
  explain status <S>      Explain a status value (OK/WARN/CRIT/UNKNOWN/SKIP)
  help                    Show this help

${C_CYAN}Environment${C_RESET}:
  LM_PROGRESS=0         disable progress bar during run
  NO_COLOR=1            disable colored output
  LM_LOCAL_ONLY=true    force local-only mode (CI/testing)
  LM_DARK_SITE=true     enable conservative offline defaults
  LM_TUI_BACKEND=gum    force menu UI backend (gum|dialog|whiptail)

${C_CYAN}Examples${C_RESET}:
  linux-maint run --group prod --parallel 10 --progress
  linux-maint run --only service_monitor,ntp_drift_monitor
  linux-maint run --skip inventory_export,backup_check
  NO_COLOR=1 linux-maint run --local-only --plan
  NO_COLOR=1 linux-maint run --local-only --plan --json
  linux-maint status --only WARN --reasons 5
  linux-maint report --short --no-trend
  NO_COLOR=1 linux-maint report --compact
  linux-maint check --json
  linux-maint trend --last 10
  NO_COLOR=1 linux-maint trend --last 10 --json
  linux-maint diff
  NO_COLOR=1 linux-maint diff --json
  linux-maint pack-logs --out /tmp --redact
  linux-maint list-monitors
  linux-maint lint-summary /var/log/health/full_health_monitor_summary_latest.log
  linux-maint menu

${C_CYAN}Tips${C_RESET}:
  See docs/README.md for full docs and flag details
  linux-maint help <command>
  NO_COLOR=1 linux-maint report
EOF
}

command_usage(){
  local c="${1:-}"
  case "$c" in
    ""|help|-h|--help)
      usage; return 0;;
    run)
      cat <<EOF
Usage: linux-maint run [flags]

Key flags:
  --group G            use /etc/linux_maint/groups.d/G
  --hosts a,b          ad-hoc host list
  --exclude a,b        exclude hosts
  --parallel N         max parallel SSH
  --local-only         run checks locally only
  --ssh-opts "..."     override SSH options
  --only a,b           run only selected monitors (names with/without _monitor)
  --skip a,b           skip selected monitors
  --plan               show resolved hosts/monitors without executing
  --json               with --plan, emit JSON
  --dry-run            alias for --plan
  --strict             fail if any monitor emits malformed summary lines
  --progress|--no-progress  progress bar control

Examples:
  linux-maint run --group prod --parallel 10 --progress
  linux-maint run --only service_monitor,ntp_drift_monitor
  linux-maint run --skip inventory_export,backup_check
  NO_COLOR=1 linux-maint run --local-only --plan
  NO_COLOR=1 linux-maint run --local-only --plan --json
EOF
      ;;
    menu)
      echo "Usage: linux-maint menu";;
    list-monitors)
      echo "Usage: linux-maint list-monitors [--json]";;
    lint-summary)
      echo "Usage: linux-maint lint-summary <summary_or_log_file> [--json]";;
    status)
      cat <<'EOF'
Usage: linux-maint status [flags]

Filters:
  --only OK|WARN|CRIT|UNKNOWN|SKIP
  --host PATTERN            filter by host
  --monitor PATTERN         filter by monitor
  --match-mode contains|exact|regex
  --since 15m|2h|1d|30s     recent artifacts only

Output:
  --summary                one-line summary
  --json                   machine JSON
  --prom                   Prometheus textfile format
  --table                  table output
  --group-by host|monitor|reason
  --top N                  limit group-by rows (requires --group-by)
  --problems N             cap problem list (max 100)
  --reasons N              top reasons rollup (max 20)
  --strict                 fail if summary lines are malformed
EOF
      ;;
    report)
      cat <<'EOF'
Usage: linux-maint report [flags]

Output:
  --short        one-screen summary
  --compact      minimal output
  --table        table formatting
  --json         machine JSON
  --redact       redact secrets in human output only
  --no-trend     suppress trend section
  --no-slow      suppress slow monitors
  --no-reasons   suppress reason rollup
  --no-problems  suppress problem list

Examples:
  linux-maint report --short --no-trend
  NO_COLOR=1 linux-maint report --compact
EOF
      ;;
    metrics)
      echo "Usage: linux-maint metrics --json|--prom";;
    config)
      echo "Usage: linux-maint config [--json] [--sources] [--lint]";;
    doctor)
      echo "Usage: linux-maint doctor [--json] [--compact] [--fix] [--fix-deps] [--fix-deps-optional] [--yes] [--dry-run]";;
    self-check)
      echo "Usage: linux-maint self-check [--json] [--compact]";;
    check)
      echo "Usage: linux-maint check [--json]";;
    history)
      cat <<'EOF'
Usage: linux-maint history [flags]

  --last N      number of runs (default 10)
  --json        machine JSON
  --table       table output
  --compact     one-line latest run
EOF
      ;;
    run-index)
      cat <<'EOF'
Usage: linux-maint run-index [flags]

  --stats            show run index stats (default)
  --prune            prune to last N entries (default keep=200)
  --keep N           number of entries to retain
  --json             machine JSON
EOF
      ;;
    summary)
      echo "Usage: linux-maint summary [--no-color]";;
    trend)
      cat <<'EOF'
Usage: linux-maint trend [--last N] [--since DATE] [--until DATE] [--json|--csv|--export csv|json] [--redact]

Examples:
  linux-maint trend --last 10
  NO_COLOR=1 linux-maint trend --last 10 --json
EOF
      ;;
    runtimes)
      echo "Usage: linux-maint runtimes [--last N] [--json]";;
    export)
      echo "Usage: linux-maint export --json|--csv";;
    init)
      echo "Usage: linux-maint init [--minimal] [--force]";;
    tune)
      echo "Usage: linux-maint tune dark-site";;
    baseline)
      cat <<'EOF'
Usage: linux-maint baseline <ports|configs|users|sudoers> [flags]

  --update      write baseline
  --diff        show changes vs baseline
  --show        print baseline contents
  --local-only  no SSH
  --progress|--no-progress
EOF
      ;;
    preflight)
      echo "Usage: linux-maint preflight";;
    validate)
      echo "Usage: linux-maint validate";;
    deps)
      echo "Usage: linux-maint deps";;
    verify-install)
      echo "Usage: linux-maint verify-install";;
    pack-logs)
      cat <<'EOF'
Usage: linux-maint pack-logs [flags]

  --out DIR            output directory
  --redact|--no-redact redact sensitive data
  --progress|--no-progress
  --hash               include SHA256 manifest
EOF
      ;;
    version)
      echo "Usage: linux-maint version";;
    make-tarball)
      echo "Usage: linux-maint make-tarball";;
    verify-release)
      echo "Usage: linux-maint verify-release <tarball> --sums <SHA256SUMS>";;
    install)
      echo "Usage: linux-maint install [args]";;
    uninstall)
      echo "Usage: linux-maint uninstall [args]";;
    diff)
      cat <<'EOF'
Usage: linux-maint diff [--json]

Examples:
  linux-maint diff
  NO_COLOR=1 linux-maint diff --json
EOF
      ;;
    logs)
      echo "Usage: linux-maint logs [n]";;
    explain)
      echo "Usage: linux-maint explain <reason|status|monitor> ...";;
    *)
      echo "Unknown command: $c" >&2
      usage
      return 2;;
  esac
}

cmd="${1:-help}"; shift || true

case "$cmd" in
  help|-h|--help)
    if [[ -n "${1:-}" ]]; then
      command_usage "$1"
    else
      usage
    fi
    ;;

  menu)
    run_menu
    ;;

  run)
    if [[ "$MODE" == "installed" ]]; then
      need_root_for run
    fi
    parse_run_args "$@"
    validate_ssh_opts

    if [[ -n "${RUN_ONLY:-}" ]]; then
      validate_monitor_list "$(normalize_monitor_list "$RUN_ONLY")" || exit $?
    fi
    if [[ -n "${RUN_SKIP:-}" ]]; then
      validate_monitor_list "$(normalize_monitor_list "$RUN_SKIP")" || exit $?
    fi

    if [[ -n "${RUN_ONLY:-}" || -n "${RUN_SKIP:-}" ]]; then
      mapfile -t _monitors < <(filter_monitors_only_skip "${RUN_ONLY:-}" "${RUN_SKIP:-}")
      if [[ "${#_monitors[@]}" -eq 0 ]]; then
        echo "ERROR: monitor filter produced empty list" >&2
        exit 2
      fi
      export LM_MONITORS="${_monitors[*]}"
    fi
    if [[ -n "${LM_MONITORS:-}" ]]; then
      read -r -a _lm_list <<< "${LM_MONITORS}"
      validate_monitor_list "$(printf '%s\n' "${_lm_list[@]}")" || exit $?
    fi
    if [[ "${RUN_JSON:-0}" -eq 1 && "${PLAN_ONLY:-0}" -ne 1 ]]; then
      echo "ERROR: --json is only supported with --plan/--dry-run" >&2
      exit 2
    fi

    if [[ "${DEBUG:-0}" -eq 1 ]]; then
      echo "=== linux-maint run debug ==="
      echo "MODE=${MODE}"
      echo "wrapper=${wrapper}"
      echo "LM_GROUP=${LM_GROUP:-}"
      echo "LM_HOSTS_DIR=${LM_HOSTS_DIR:-}"
      echo "LM_SERVERLIST=${LM_SERVERLIST:-}"
      echo "LM_EXCLUDED=${LM_EXCLUDED:-}"
      echo "LM_MAX_PARALLEL=${LM_MAX_PARALLEL:-}"
      echo "LM_LOCAL_ONLY=${LM_LOCAL_ONLY:-}"
      echo "LM_MONITORS=${LM_MONITORS:-}"
      echo "LM_SSH_OPTS=${LM_SSH_OPTS:-}"
      echo "LIMIT=${LIMIT:-0}"
      echo "SHUFFLE=${SHUFFLE:-0}"
      echo "PLAN_ONLY=${PLAN_ONLY:-0}"
      echo "DRY_RUN=${DRY_RUN:-0}"
      echo "RUN_JSON=${RUN_JSON:-0}"
      echo "============================="
    fi

    if [[ "${PLAN_ONLY:-0}" -eq 1 ]]; then
      if [[ -n "${LM_GROUP:-}" ]]; then
        gf="${LM_HOSTS_DIR:-/etc/linux_maint/hosts.d}/${LM_GROUP}.txt"
        [[ -f "$gf" ]] || echo "NOTE: LM_GROUP=$LM_GROUP but group file not found: $gf (will fall back)" >&2
      fi

      mapfile -t _hosts < <(resolve_run_hosts)
      local_monitors=""
      if [[ -n "${LM_MONITORS:-}" ]]; then
        read -r -a _lm_list <<< "${LM_MONITORS}"
        local_monitors="$(printf '%s\n' "${_lm_list[@]}")"
      else
        local_monitors="$(get_default_monitors 2>/dev/null || true)"
        if [[ -z "$local_monitors" ]]; then
          local_monitors="$(available_monitors 2>/dev/null || true)"
        fi
      fi

      if [[ "${RUN_JSON:-0}" -eq 1 ]]; then
        printf '{'
        printf '"mode":"%s",' "$MODE"
        if [[ "${LM_LOCAL_ONLY:-false}" == "true" ]]; then
          printf '"local_only":true,'
        else
          printf '"local_only":false,'
        fi
        printf '"parallel":%s,' "${LM_MAX_PARALLEL:-0}"
        if [[ -n "${LM_GROUP:-}" ]]; then
          printf '"group":"%s",' "$(json_escape "$LM_GROUP")"
        else
          printf '"group":null,'
        fi
        printf '"limit":%s,' "${LIMIT:-0}"
        printf '"shuffle":%s,' "$([[ "${SHUFFLE:-0}" -eq 1 ]] && echo true || echo false)"
        printf '"hosts":['
        first=1
        for h in "${_hosts[@]}"; do
          [[ "$first" -eq 0 ]] && printf ','
          first=0
          printf '"%s"' "$(json_escape "$h")"
        done
        printf '],"monitors":['
        first=1
        while IFS= read -r m; do
          [[ -z "$m" ]] && continue
          [[ "$first" -eq 0 ]] && printf ','
          first=0
          printf '"%s"' "$(json_escape "$m")"
        done <<< "$local_monitors"
        printf ']}\n'
        exit 0
      fi

      if [[ -t 1 ]]; then
        section "run plan"
        echo "mode=${MODE} local_only=${LM_LOCAL_ONLY:-false} parallel=${LM_MAX_PARALLEL:-0}"
        [[ -n "${LM_GROUP:-}" ]] && echo "group=${LM_GROUP}"
        echo ""
      fi
      echo "Resolved hosts (${#_hosts[@]}):"
      printf '%s\n' "${_hosts[@]}"
      if [[ -t 1 ]]; then
        echo ""
        echo "Monitors ($(printf '%s\n' "$local_monitors" | sed '/^$/d' | wc -l | tr -d ' ')):"
      fi
      if [[ -n "$local_monitors" ]]; then
        printf '%s\n' "$local_monitors"
      fi
      exit 0
    fi

    # Run wrapper (installed or repo mode) and print a short footer when interactive.
    if [[ "$wrapper" == "$SBIN"/* ]]; then
      "$wrapper"
    else
      bash "$wrapper"
    fi
    rc=$?
    if [[ -t 1 ]]; then
      echo ""
      echo "Run complete (exit_code=$rc)"
      if [[ "$MODE" == "repo" ]]; then
        echo "Summary: $REPO_SUMMARY_LATEST"
        echo "Log: $REPO_LATEST_LOG"
      else
        echo "Summary: $INST_SUMMARY_LATEST"
        echo "Log: /var/log/health/full_health_monitor_latest.log"
      fi
      echo "Next: linux-maint report"
      echo "Tip: linux-maint status --reasons 5"
      echo "If WARN/CRIT: linux-maint doctor"
    fi
    exit $rc
    ;;

  list-monitors)
    LIST_JSON=0
    while [[ $# -gt 0 ]]; do
      case "$1" in
        --json) LIST_JSON=1; shift 1;;
        -h|--help)
          command_usage list-monitors
          exit 0;;
        *) echo "Unknown list-monitors flag: $1" >&2; exit 2;;
      esac
    done
    avail="$(available_monitors 2>/dev/null || true)"
    if [[ -z "$avail" ]]; then
      echo "ERROR: monitors directory not found" >&2
      exit 1
    fi
    MONITORS_LIST="$avail" python3 - "$LIST_JSON" <<'PY'
import json
import os
import sys

json_mode = sys.argv[1] == "1"
monitors = [l.strip() for l in os.environ.get("MONITORS_LIST", "").splitlines() if l.strip()]

meta = {
    "preflight_check": ("Preflight readiness checks (deps/SSH/config).", [] , False),
    "config_validate": ("Validate config file formats and hygiene.", ["linux-maint.conf"], False),
    "health_monitor": ("Core host health (cpu/mem/disk/load).", [], False),
    "filesystem_readonly_monitor": ("Detect read-only filesystems.", [], False),
    "resource_monitor": ("Process resource hotspots (CPU/mem).", [], False),
    "inode_monitor": ("Inode usage checks.", [], False),
    "disk_trend_monitor": ("Disk growth trend check.", [], False),
    "network_monitor": ("Network reachability/latency checks.", ["network_targets.txt"], True),
    "service_monitor": ("Service status checks.", ["services.txt"], False),
    "timer_monitor": ("systemd timer status checks.", [], False),
    "last_run_age_monitor": ("Age of last run (wrapper status).", [], False),
    "ntp_drift_monitor": ("NTP drift checks.", [], False),
    "patch_monitor": ("Security updates check.", [], False),
    "storage_health_monitor": ("Storage health (SMART/bad blocks).", [], False),
    "kernel_events_monitor": ("Kernel error/oom events scan.", [], False),
    "log_spike_monitor": ("Log spike detection.", [], False),
    "cert_monitor": ("Certificate expiry checks.", ["certs.txt"], True),
    "nfs_mount_monitor": ("NFS mount presence/health.", [], False),
    "ports_baseline_monitor": ("Open ports baseline drift.", ["ports_baseline.txt"], True),
    "config_drift_monitor": ("Config drift vs baseline.", ["config_paths.txt"], True),
    "user_monitor": ("User/sudoers baseline drift.", ["baseline_users.txt","baseline_sudoers.txt"], True),
    "backup_check": ("Backup target freshness checks.", ["backup_targets.csv"], True),
    "inventory_export": ("Inventory snapshot exporter.", [], False),
}

rows = []
for m in monitors:
    name = m[:-3] if m.endswith(".sh") else m
    desc, cfg, optional = meta.get(name, ("(no description)", [], False))
    rows.append({
        "monitor": name,
        "description": desc,
        "config_files": cfg,
        "config_optional": bool(optional),
    })

if json_mode:
    print(json.dumps({"monitors": rows}, indent=2, sort_keys=True))
    raise SystemExit(0)

mon_w = max(len(r["monitor"]) for r in rows) if rows else 7
cfg_w = max(len(",".join(r["config_files"])) for r in rows) if rows else 6
print(f"{'MONITOR':<{mon_w}} {'CONFIG':<{cfg_w}} REQUIRED DESCRIPTION")
for r in rows:
    cfg = ",".join(r["config_files"])
    req = "no" if r["config_optional"] else ("yes" if cfg else "no")
    print(f"{r['monitor']:<{mon_w}} {cfg:<{cfg_w}} {req:<8} {r['description']}")
PY
    ;;

  lint-summary)
    summary_path="${1:-}"
    shift || true
    LINT_JSON=0
    while [[ $# -gt 0 ]]; do
      case "$1" in
        --json) LINT_JSON=1; shift 1;;
        -h|--help)
          command_usage lint-summary
          exit 0;;
        *) echo "Unknown lint-summary flag: $1" >&2; exit 2;;
      esac
    done
    if [[ -z "$summary_path" ]]; then
      command_usage lint-summary >&2
      exit 2
    fi
    if [[ ! -f "$summary_path" ]]; then
      echo "ERROR: summary file not found: $summary_path" >&2
      exit 1
    fi
    REPO_ROOT="$REPO_ROOT" SHARE="$SHARE" python3 - "$summary_path" "$LINT_JSON" <<'PY'
import json
import os
import re
import sys
from collections import defaultdict

path = sys.argv[1]
json_mode = sys.argv[2] == "1"

ALLOWED_STATUSES = {"OK", "WARN", "CRIT", "UNKNOWN", "SKIP"}
REASON_RE = re.compile(r"^[a-z0-9_]+$")

def find_repo_root():
    env_root = os.environ.get("REPO_ROOT")
    if env_root and os.path.exists(env_root):
        return env_root
    return os.path.abspath(os.path.join(os.path.dirname(__file__), ".."))

def load_allowed_reasons():
    repo_root = find_repo_root()
    candidates = [
        os.path.join(repo_root, "docs", "REASONS.md"),
        os.path.join(os.environ.get("SHARE", ""), "docs", "REASONS.md"),
        os.path.join(os.environ.get("SHARE", ""), "REASONS.md"),
    ]
    allow_candidates = [
        os.path.join(repo_root, "tests", "reason_token_allowlist.txt"),
    ]
    reasons = set()
    for p in candidates:
        if not p or not os.path.exists(p):
            continue
        try:
            with open(p, "r", encoding="utf-8", errors="ignore") as f:
                for line in f:
                    for m in re.findall(r"`([a-z0-9_]+)`", line):
                        reasons.add(m)
        except Exception:
            pass
        if reasons:
            break

    allow = set()
    for p in allow_candidates:
        if not p or not os.path.exists(p):
            continue
        with open(p, "r", encoding="utf-8", errors="ignore") as f:
            for line in f:
                line = line.strip()
                if not line or line.startswith("#"):
                    continue
                allow.add(line)
    return reasons, allow

def parse_kv(line: str):
    parts = line.strip().split()
    d = {}
    dup_keys = []
    bad_tokens = []
    for p in parts:
        if "=" in p:
            k, v = p.split("=", 1)
            if k in d:
                dup_keys.append(k)
            d[k] = v
        else:
            bad_tokens.append(p)
    return d, dup_keys, bad_tokens

allowed_reasons, allowlist_reasons = load_allowed_reasons()
txt = open(path, "r", encoding="utf-8", errors="ignore").read().splitlines()

executed = []
monitor_lines = []
run_re = re.compile(r"==== Running monitor: (?:.*/)?([A-Za-z0-9_\\-]+)\\.sh")

for line in txt:
    m = run_re.search(line)
    if m:
        executed.append(m.group(1))
    if "monitor=" in line:
        m2 = re.search(r"(^|\s)(monitor=[^\n]+)$", line)
        if m2:
            ml = m2.group(2)
            if ml.startswith("monitor= ") or ml.startswith("monitor=lines") or ml.startswith("monitor= lines"):
                continue
            monitor_lines.append(ml)

errors = []
if not monitor_lines:
    errors.append(f"no monitor= lines found in {path}")

rows = []
malformed = 0
for l in monitor_lines:
    row, dup_keys, bad_tokens = parse_kv(l)
    if bad_tokens:
        malformed += 1
        errors.append(f"malformed monitor= line (non key=value tokens): {l}")
    if dup_keys:
        malformed += 1
        errors.append(f"duplicate keys {dup_keys} in monitor= line: {l}")
    rows.append(row)

bad_status = 0
missing_reason = 0
bad_reason = 0
missing_required = 0
dup_monitor_host = 0
bad_host = 0
missing_node = 0
seen_monitor_host = {}

for r in rows:
    st = r.get("status", "")
    if not r.get("monitor") or not r.get("host") or not st:
        missing_required += 1
        errors.append(f"monitor= line missing required keys: {r}")
    if r.get("host") == "all":
        bad_host += 1
        errors.append(f"host=all is not allowed (use host=runner instead): {r}")
    if not r.get("node"):
        missing_node += 1
        errors.append(f"monitor= line missing node=: {r}")
    if st not in ALLOWED_STATUSES:
        bad_status += 1
        errors.append(f"invalid status={st} line={r}")
    if r.get("monitor") and r.get("host"):
        key = (r.get("monitor"), r.get("host"))
        seen_monitor_host[key] = seen_monitor_host.get(key, 0) + 1
        if seen_monitor_host[key] > 1:
            dup_monitor_host += 1
            errors.append(f"duplicate monitor/host entries for {key}")
    reason = r.get("reason", "")
    if st in {"WARN", "CRIT", "UNKNOWN", "SKIP"}:
        if "reason" not in r or reason == "":
            missing_reason += 1
        elif not REASON_RE.match(reason):
            bad_reason += 1
            errors.append(f"invalid reason token={reason!r} line={r}")
        elif allowed_reasons and reason not in allowed_reasons and reason not in allowlist_reasons:
            bad_reason += 1
            errors.append(f"reason token not in docs/REASONS.md allowlist: {reason!r} line={r}")

mon_to_lines = defaultdict(int)
for r in rows:
    mon = r.get("monitor")
    if mon:
        mon_to_lines[mon] += 1

missing_monitor_lines = []
for m in executed:
    if mon_to_lines.get(m, 0) == 0:
        missing_monitor_lines.append(m)
if missing_monitor_lines:
    errors.append("executed monitors missing monitor= output: " + ", ".join(missing_monitor_lines))

if missing_reason:
    errors.append(f"{missing_reason} non-OK monitor= lines are missing reason=")

ok = not errors
if json_mode:
    out = {
        "summary_lint_contract_version": 1,
        "ok": ok,
        "errors": errors,
        "counts": {
            "malformed": malformed,
            "missing_required": missing_required,
            "bad_status": bad_status,
            "missing_reason": missing_reason,
            "bad_reason": bad_reason,
            "dup_monitor_host": dup_monitor_host,
            "bad_host": bad_host,
            "missing_node": missing_node,
        },
        "missing_monitor_lines": missing_monitor_lines,
    }
    print(json.dumps(out, indent=2, sort_keys=True))
    raise SystemExit(0 if ok else 2)

for e in errors:
    print(f"ERROR: {e}")
raise SystemExit(0 if ok else 2)
PY
    ;;


  diff)
    # Show diff of monitor= lines since last run.
    # Uses the same state file as the wrapper: last_summary_monitor_lines.log
    JSON=0
    if [[ "${1:-}" == "--json" ]]; then JSON=1; shift; fi
    DIFF_COLOR=1
    [[ -n "${NO_COLOR:-}" || -n "${LM_NO_COLOR:-}" ]] && DIFF_COLOR=0
    color_enabled || DIFF_COLOR=0

    if [[ "$MODE" == "repo" ]]; then
      DIFF_STATE_DIR="${LM_NOTIFY_STATE_DIR:-${LM_STATE_DIR:-$REPO_LOG_DIR}}"
      SUMMARY_LATEST="$REPO_SUMMARY_LATEST"
    else
      DIFF_STATE_DIR="${LM_NOTIFY_STATE_DIR:-${LM_STATE_DIR:-/var/lib/linux_maint}}"
      SUMMARY_LATEST="$INST_SUMMARY_LATEST"
    fi
    PREV_SUMMARY="$DIFF_STATE_DIR/last_summary_monitor_lines.log"

    CUR_SUMMARY="$SUMMARY_LATEST"
    if [[ "$JSON" -eq 0 ]]; then
      if [[ -t 1 ]]; then
        section "linux-maint diff"
      fi
      echo "diff_state_dir=$DIFF_STATE_DIR"
    fi

    if [[ ! -f "$CUR_SUMMARY" ]]; then
      echo "No current summary file: $CUR_SUMMARY" >&2
      echo "Run linux-maint run first." >&2
      exit 1
    fi
    if [[ ! -f "$PREV_SUMMARY" ]]; then
      echo "No previous diff state file: $PREV_SUMMARY" >&2
      echo "The wrapper writes this after each run (best-effort). Typically you need to run linux-maint run twice to get a useful diff." >&2
      exit 1
    fi

    if [[ "$MODE" == "repo" ]]; then
      diff_tool="$REPO_ROOT/tools/summary_diff.py"
    else
      diff_tool="$LIBEXEC/summary_diff.py"
    fi
    if [[ ! -x "$diff_tool" ]]; then
      # In installed mode, tools/ may not exist; try a system python module not available; fallback to error.
      echo "Diff tool not found/executable: $diff_tool" >&2
      hint_line "reinstall linux-maint to include summary_diff.py" >&2
      exit 1
    fi

    if [[ "$JSON" -eq 1 ]]; then
      exec python3 "$diff_tool" "$PREV_SUMMARY" "$CUR_SUMMARY" --json
    else
      LM_COLOR="$DIFF_COLOR" exec python3 "$diff_tool" "$PREV_SUMMARY" "$CUR_SUMMARY"
    fi
    ;;
  logs)
    if [[ "$MODE" == "installed" ]]; then
      need_root_for logs
    fi
        n="${1:-200}"
        if [[ "$MODE" == "repo" ]]; then
          mkdir -p "$REPO_LOG_DIR"
          [[ -f "$REPO_LATEST_LOG" ]] || { echo "No repo log yet: $REPO_LATEST_LOG"; exit 1; }
          if [[ -t 1 ]]; then
            section "logs (last $n)"
            echo "file=$REPO_LATEST_LOG"
          fi
          tail -n "$n" "$REPO_LATEST_LOG"
        else
          if [[ -t 1 ]]; then
            section "logs (last $n)"
            echo "file=/var/log/health/full_health_monitor_latest.log"
          fi
          exec sudo -n tail -n "$n" /var/log/health/full_health_monitor_latest.log 2>/dev/null || tail -n "$n" /var/log/health/full_health_monitor_latest.log
        fi
    ;;

  report)
    if [[ "$MODE" == "installed" ]]; then
      need_root_for report
    fi

    REPORT_JSON=0
    REPORT_COLOR=1
    REPORT_COMPACT=0
    REPORT_SHORT=0
    REPORT_TABLE="${LM_REPORT_TABLE:-0}"
    REPORT_NO_TREND=0
    REPORT_NO_SLOW=0
    REPORT_NO_REASONS=0
    REPORT_NO_PROBLEMS=0
    REPORT_REDACT=0
    while [[ $# -gt 0 ]]; do
      case "$1" in
        --json) REPORT_JSON=1; shift 1;;
        --no-color) REPORT_COLOR=0; shift 1;;
        --compact) REPORT_COMPACT=1; shift 1;;
        --short) REPORT_SHORT=1; shift 1;;
        --table) REPORT_TABLE=1; shift 1;;
        --redact) REPORT_REDACT=1; shift 1;;
        --no-redact) REPORT_REDACT=0; shift 1;;
        --no-trend) REPORT_NO_TREND=1; shift 1;;
        --no-slow) REPORT_NO_SLOW=1; shift 1;;
        --no-reasons) REPORT_NO_REASONS=1; shift 1;;
        --no-problems) REPORT_NO_PROBLEMS=1; shift 1;;
        -h|--help)
          command_usage report
          exit 0;;
        *) echo "Unknown report flag: $1" >&2; exit 2;;
      esac
    done
    [[ -n "${NO_COLOR:-}" || -n "${LM_NO_COLOR:-}" ]] && REPORT_COLOR=0
    color_enabled || REPORT_COLOR=0
    if [[ "$REPORT_JSON" -eq 1 && "$REPORT_REDACT" -eq 1 ]]; then
      echo "ERROR: --redact is only for human output (not --json)" >&2
      exit 2
    fi

    tmp_status="$(mktemp -p "$TMPDIR" linux_maint_report_status.XXXXXX.json)"
    tmp_trend="$(mktemp -p "$TMPDIR" linux_maint_report_trend.XXXXXX.json)"
    tmp_runtimes="$(mktemp -p "$TMPDIR" linux_maint_report_runtimes.XXXXXX.json)"

    "$0" status --json --problems 20 --reasons 10 >"$tmp_status" 2>/dev/null || printf '{}' >"$tmp_status"
    "$0" trend --last 10 --json >"$tmp_trend" 2>/dev/null || printf '{}' >"$tmp_trend"
    "$0" runtimes --last 1 --json >"$tmp_runtimes" 2>/dev/null || printf '{}' >"$tmp_runtimes"

    REPORT_EXPECTED_SKIPS=""
    if [[ "$REPORT_JSON" -eq 0 ]]; then
      cfg_dir="/etc/linux_maint"
      if [[ "$MODE" == "repo" ]]; then
        cfg_dir="${LM_CFG_DIR:-$REPO_ROOT/.etc_linux_maint}"
      fi
      if banner="$(expected_skips_text "$cfg_dir")"; then
        REPORT_EXPECTED_SKIPS="$banner"
      fi
    fi

    LM_COLOR="$REPORT_COLOR" REPORT_COMPACT="$REPORT_COMPACT" REPORT_SHORT="$REPORT_SHORT" REPORT_TABLE="$REPORT_TABLE" REPORT_NO_TREND="$REPORT_NO_TREND" REPORT_NO_SLOW="$REPORT_NO_SLOW" REPORT_NO_REASONS="$REPORT_NO_REASONS" REPORT_NO_PROBLEMS="$REPORT_NO_PROBLEMS" REPORT_EXPECTED_SKIPS="$REPORT_EXPECTED_SKIPS" REPORT_REDACT="$REPORT_REDACT" python3 - "$tmp_status" "$tmp_trend" "$tmp_runtimes" "$REPORT_JSON" <<'PY'
import json, os, sys, re
import re
import builtins

status_path, trend_path, runtimes_path, json_mode = sys.argv[1:5]
json_mode = json_mode == "1"
color = os.environ.get("LM_COLOR","1") == "1"
compact = os.environ.get("REPORT_COMPACT","0") == "1"
short = os.environ.get("REPORT_SHORT","0") == "1"
table = os.environ.get("REPORT_TABLE","0") == "1"
no_trend = os.environ.get("REPORT_NO_TREND","0") == "1"
no_slow = os.environ.get("REPORT_NO_SLOW","0") == "1"
no_reasons = os.environ.get("REPORT_NO_REASONS","0") == "1"
no_problems = os.environ.get("REPORT_NO_PROBLEMS","0") == "1"
expected_skips = os.environ.get("REPORT_EXPECTED_SKIPS","").strip()
redact = os.environ.get("REPORT_REDACT","0") == "1"
redact_json = os.environ.get("LM_REDACT_JSON","0") in ("1","true","TRUE","yes","YES")
redact_json_strict = os.environ.get("LM_REDACT_JSON_STRICT","0") in ("1","true","TRUE","yes","YES")

def redact_line(s: str) -> str:
    pats = [
        (re.compile(r'(?i)\\b([A-Za-z0-9_]*(password|passwd|token|api[_-]?key|secret|access[_-]?key|private[_-]?key|session([_-]?id)?|id[_-]?token|refresh[_-]?token|x[_-]?auth[_-]?token)[A-Za-z0-9_]*)=([^ \\t]+)'), r'\\1=REDACTED'),
        (re.compile(r'(?i)\\b(Authorization:|X-Auth-Token:)\\s+[^ \\t]+'), r'\\1 REDACTED'),
        (re.compile(r'(?i)\\b(Bearer)\\s+[A-Za-z0-9_.~+/-]+=*'), r'\\1 REDACTED'),
        (re.compile(r'\\b[0-9A-Za-z_-]{12,}\\.[0-9A-Za-z_-]{12,}\\.[0-9A-Za-z_-]{12,}\\b'), 'REDACTED_JWT'),
        (re.compile(r'\\bAKIA[0-9A-Z]{16}\\b'), 'AKIA_REDACTED'),
        (re.compile(r'\\bASIA[0-9A-Z]{16}\\b'), 'ASIA_REDACTED'),
        (re.compile(r'\\bgh[pousr]_[A-Za-z0-9]{20,}\\b'), 'GH_REDACTED'),
        (re.compile(r'\\bgithub_pat_[A-Za-z0-9_]{20,}\\b'), 'GH_PAT_REDACTED'),
        (re.compile(r'\\bxox[baprs]-[A-Za-z0-9-]{10,}\\b'), 'SLACK_REDACTED'),
        (re.compile(r'\\bAIza[0-9A-Za-z_-]{35}\\b'), 'GCP_REDACTED'),
        (re.compile(r'\\bya29\\.[A-Za-z0-9_-]{10,}\\b'), 'OAUTH_REDACTED'),
        (re.compile(r'-----BEGIN [A-Z ]*PRIVATE KEY-----'), '-----BEGIN PRIVATE KEY-----'),
        (re.compile(r'-----END [A-Z ]*PRIVATE KEY-----'), '-----END PRIVATE KEY-----'),
    ]
    out = s
    for pat, rep in pats:
        out = pat.sub(rep, out)
    return out

def redact_json_obj(obj):
    if isinstance(obj, dict):
        return {k: redact_json_obj(v) for k, v in obj.items()}
    if isinstance(obj, list):
        return [redact_json_obj(v) for v in obj]
    if isinstance(obj, str):
        if redact_json_strict:
            return "REDACTED"
        return redact_line(obj)
    return obj

if redact and not json_mode:
    def print(*args, **kwargs):
        sep = kwargs.get("sep", " ")
        end = kwargs.get("end", "\\n")
        text = sep.join(str(a) for a in args)
        builtins.print(redact_line(text), end=end)

def c(s, code):
    if not color:
        return s
    return f"\033[{code}m{s}\033[0m"

def header(text):
    if not color:
        return text
    if text.startswith("=== ") and text.endswith(" ==="):
        inner = text[4:-4]
        return f"=== {c(inner, '1;36')} ==="
    return c(text, "1;36")

def section(title):
    # Friendly section header for human output.
    print("")
    print(c(title, "1;36"))

def color_status(st, text=None):
    label = text if text is not None else st
    if st == "CRIT":
        return c(label, "1;31")
    if st == "WARN":
        return c(label, "1;33")
    if st == "OK":
        return c(label, "1;32")
    if st == "UNKNOWN":
        return c(label, "1;35")
    if st == "SKIP":
        return c(label, "1;36")
    return label

def read_json(p):
    try:
        with open(p, "r", encoding="utf-8") as f:
            return json.load(f)
    except Exception:
        return {}

status = read_json(status_path)
trend = read_json(trend_path)
runtimes = read_json(runtimes_path)

if json_mode:
    out = {
        "report_json_contract_version": 1,
        "status": status,
        "trend": trend,
        "runtimes": runtimes,
    }
    if redact_json or redact_json_strict:
        out = redact_json_obj(out)
    print(json.dumps(out, indent=2, sort_keys=True))
    raise SystemExit(0)

mode = status.get("mode", "unknown")
last = status.get("last_status", {})
overall = last.get("overall", "UNKNOWN")
exit_code = last.get("exit_code", "3")
logfile = last.get("logfile", "")
summary = status.get("summary_file", "")
ov = color_status(overall)
if short:
    print(header("=== linux-maint report (short) ==="))
    print(f"mode={mode} overall={ov} exit_code={exit_code}")
    if expected_skips:
        print(expected_skips)
    totals = status.get("totals", {})
    if totals:
        parts = []
        for k in ["CRIT","WARN","UNKNOWN","SKIP","OK"]:
            v = totals.get(k,0)
            kv = f"{k}={v}"
            if v != 0:
                kv = color_status(k, kv)
            parts.append(kv)
        print("totals: " + " ".join(parts))
    problems = status.get("problems", [])
    if problems and not no_problems:
        print("\nproblems (top 5):")
        for p in problems[:5]:
            s = p.get("status","UNKNOWN")
            mon = p.get("monitor","unknown")
            host = p.get("host","")
            reason = p.get("reason","")
            st = color_status(s)
            line = f"{st} {mon}"
            if host:
                line += f" host={host}"
            if reason:
                line += f" reason={reason}"
            print(line)
    else:
        print("\nproblems: none (all OK)")
    print(c("\nnext_steps:", "1;36"))
    print("  - run: linux-maint doctor")
    print("  - run: linux-maint status --verbose")
    raise SystemExit(0)
if not compact:
    banner = f"health={color_status(overall)} exit_code={exit_code}"
    print(header("=== linux-maint report ===") + " " + banner)
print(f"mode={mode} overall={ov} exit_code={exit_code}")
if expected_skips and not compact:
    print(expected_skips)
if not compact:
    section("files")
    if logfile:
        print(f"logfile={logfile}")
    if summary:
        print(f"summary_file={summary}")

totals = status.get("totals", {})
if totals:
    if not compact:
        section("totals")
    tvals=[("CRIT", totals.get("CRIT",0)), ("WARN", totals.get("WARN",0)), ("UNKNOWN", totals.get("UNKNOWN",0)), ("SKIP", totals.get("SKIP",0)), ("OK", totals.get("OK",0))]
    maxk=max(len(k) for k,_ in tvals) if tvals else 0
    maxv=max(len(str(v)) for _,v in tvals) if tvals else 0
    if table:
        print("totals:")
        print(f"  {'STATUS':<{maxk}} {'COUNT':<{maxv}}")
        for k,v in tvals:
            label = f"{k:<{maxk}}"
            count = f"{str(v):<{maxv}}"
            label = color_status(k, label)
            if v != 0:
                count = color_status(k, count)
            print(f"  {label} {count}")
    else:
        parts = []
        for k, v in tvals:
            kv = f"{k}={v}"
            if v != 0:
                kv = color_status(k, kv)
            parts.append(kv)
        line = "totals: " + " ".join(parts)
        print(line)
    if compact:
        raise SystemExit(0)

problems = status.get("problems", [])
if problems and not no_problems:
    section("problems (top)")
    if table:
        rows=[]
        for p in problems[:20]:
            s=p.get("status","UNKNOWN")
            mon=p.get("monitor","unknown")
            host=p.get("host","")
            reason=p.get("reason","")
            rows.append((s, mon, host, reason))
        sev_order={'CRIT':0,'WARN':1,'UNKNOWN':2,'SKIP':3}
        rows.sort(key=lambda r: sev_order.get(r[0], 9))
        headers=("STATUS","MONITOR","HOST","REASON")
        w=[len(h) for h in headers]
        for r in rows:
            for i,v in enumerate(r):
                w[i]=max(w[i], len(str(v)))
        print(f"{headers[0]:<{w[0]}} {headers[1]:<{w[1]}} {headers[2]:<{w[2]}} {headers[3]}")
        for s,mon,host,reason in rows:
            s_pad=f"{s:<{w[0]}}"
            if s=="CRIT":
                s_pad=c(s_pad,'1;31')
            elif s=="WARN":
                s_pad=c(s_pad,'1;33')
            elif s=="OK":
                s_pad=c(s_pad,'1;32')
            elif s=="UNKNOWN":
                s_pad=c(s_pad,'1;35')
            elif s=="SKIP":
                s_pad=c(s_pad,'1;36')
            print(f"{s_pad} {mon:<{w[1]}} {host:<{w[2]}} {reason}")
    else:
        for p in problems[:20]:
            s = p.get("status","UNKNOWN")
            mon = p.get("monitor","unknown")
            host = p.get("host","")
            reason = p.get("reason","")
            st = color_status(s)
            line = f"{st} {mon}"
            if host:
                line += f" host={host}"
            if reason:
                line += f" reason={reason}"
            print(line)
    print(c("\nnext_steps:", "1;36"))
    print("  - run: linux-maint doctor")
    print("  - run: linux-maint status --verbose")
elif not no_problems:
    if table:
        section("problems (top)")
        print("STATUS MONITOR HOST REASON")
    print("\nproblems: none (all OK)")

reason_rollup = status.get("reason_rollup", [])
if reason_rollup and not no_reasons:
    section("reasons (latest)")
    for r in reason_rollup[:10]:
        print(f"{r.get('reason')}={r.get('count')}")

    hints_map = {
        "permission_denied": "Run with sudo or fix permissions for logs/state/config.",
        "missing_optional_cmd": "Install the optional dependency listed in the monitor output.",
        "missing_dependency": "Install the required dependency on the runner/host.",
        "kernel_log_unreadable": "Check journal/dmesg permissions and ensure kernel logs are readable.",
        "collect_failed": "Inventory export failed; verify /var/log/inventory and required tools (ip, lsblk, lscpu).",
        "ports_baseline_changed": "Review listening port changes and update the baseline if expected.",
        "config_drift_changed": "Review config changes and update the baseline if intended.",
        "user_anomalies": "Review new/removed users and sudoers changes.",
        "ntp_drift_high": "Check NTP/chrony sync and clock drift.",
        "ntp_not_synced": "Check NTP/chrony sync.",
        "missing_log_source": "Ensure journald/syslog is available and readable.",
        "security_updates_pending": "Apply security updates via your package manager.",
        "updates_pending": "Apply pending package updates.",
        "baseline_missing": "Create a baseline via linux-maint baseline.",
        "baseline_created": "Baseline created; rerun to compare changes.",
        "baseline_updated": "Baseline updated; rerun to check for drift.",
        "baseline_exists": "Baseline already exists; use --update if you want to overwrite it.",
        "baseline_collect_failed": "Baseline collection failed; check permissions/SSH and retry.",
        "timer_missing": "Install/enable linux-maint.timer if you want scheduled runs.",
        "timer_disabled": "Enable linux-maint.timer (systemctl enable --now linux-maint.timer).",
        "timer_inactive": "Start linux-maint.timer (systemctl start linux-maint.timer).",
        "ssh_unreachable": "Verify SSH connectivity and credentials for the target host.",
        "stale_run": "Check timers/cron; last run appears too old.",
    }
    reasons = [r.get("reason") for r in reason_rollup[:10] if r.get("reason")]
    hint_lines = []
    seen = set()
    for reason in reasons:
        if reason in hints_map and reason not in seen:
            seen.add(reason)
            hint_lines.append(f"{reason}: {hints_map[reason]}")
    if hint_lines:
        print(c("\nhints:", "1;36"))
        for h in hint_lines[:5]:
            print(f"- {h}")

if trend and not no_trend:
    t_totals = trend.get("totals", {})
    if t_totals:
        section("trend (last runs)")
        print("totals: " + " ".join(f"{k}={t_totals.get(k,0)}" for k in ["CRIT","WARN","UNKNOWN","SKIP","OK"]))
    t_reasons = trend.get("reasons", [])
    if t_reasons:
        print("top_reasons:")
        for r in t_reasons[:10]:
            print(f"{r.get('reason')}={r.get('count')}")

rows = runtimes.get("rows", [])
if rows and not no_slow:
    section("slow monitors (last run)")
    if table:
        rows2=[(r.get("monitor",""), str(r.get("ms",""))) for r in rows[:10]]
        headers=("MONITOR","MS")
        w=[len(h) for h in headers]
        for r in rows2:
            for i,v in enumerate(r):
                w[i]=max(w[i], len(str(v)))
        print(f"{headers[0]:<{w[0]}} {headers[1]:<{w[1]}}")
        for mon,ms in rows2:
            print(f"{mon:<{w[0]}} {ms:<{w[1]}}")
    else:
        for r in rows[:10]:
            print(f"{r.get('monitor')} ms={r.get('ms')}")
PY

    rm -f "$tmp_status" "$tmp_trend" "$tmp_runtimes" 2>/dev/null || true
    ;;

  metrics)
    if [[ "$MODE" == "installed" ]]; then
      need_root_for metrics
    fi

    METRICS_JSON=0
    METRICS_PROM=0
    while [[ $# -gt 0 ]]; do
      case "$1" in
        --json) METRICS_JSON=1; shift 1;;
        --prom) METRICS_PROM=1; shift 1;;
        -h|--help)
          command_usage metrics
          exit 0;;
        *) echo "Unknown metrics flag: $1" >&2; exit 2;;
      esac
    done

    if [[ "$METRICS_JSON" -eq 1 && "$METRICS_PROM" -eq 1 ]]; then
      echo "ERROR: choose only one output format (--json or --prom)" >&2
      exit 2
    fi
    if [[ "$METRICS_PROM" -eq 1 ]]; then
      "$0" status --prom
      exit 0
    fi
    if [[ "$METRICS_JSON" -ne 1 ]]; then
      echo "ERROR: metrics output is JSON-only (use --json) or --prom" >&2
      exit 2
    fi

    tmp_status="$(mktemp -p "$TMPDIR" linux_maint_metrics_status.XXXXXX.json)"
    tmp_trend="$(mktemp -p "$TMPDIR" linux_maint_metrics_trend.XXXXXX.json)"
    tmp_runtimes="$(mktemp -p "$TMPDIR" linux_maint_metrics_runtimes.XXXXXX.json)"

    "$0" status --json --problems 20 --reasons 10 >"$tmp_status" 2>/dev/null || printf '{}' >"$tmp_status"
    "$0" trend --last 10 --json >"$tmp_trend" 2>/dev/null || printf '{}' >"$tmp_trend"
    "$0" runtimes --last 1 --json >"$tmp_runtimes" 2>/dev/null || printf '{}' >"$tmp_runtimes"

    python3 - "$tmp_status" "$tmp_trend" "$tmp_runtimes" <<'PY'
import json, os, sys, re

status_path, trend_path, runtimes_path = sys.argv[1:4]
redact_json = os.environ.get("LM_REDACT_JSON","0") in ("1","true","TRUE","yes","YES")
redact_json_strict = os.environ.get("LM_REDACT_JSON_STRICT","0") in ("1","true","TRUE","yes","YES")

def read_json(p):
    try:
        with open(p, "r", encoding="utf-8") as f:
            return json.load(f)
    except Exception:
        return {}

def redact_line(s: str) -> str:
    pats = [
        (re.compile(r'(?i)\b([A-Za-z0-9_]*(password|passwd|token|api[_-]?key|secret|access[_-]?key|private[_-]?key|session([_-]?id)?|id[_-]?token|refresh[_-]?token|x[_-]?auth[_-]?token)[A-Za-z0-9_]*)=([^ \t]+)'), r'\1=REDACTED'),
        (re.compile(r'(?i)\b(Authorization:|X-Auth-Token:)\s+[^ \t]+'), r'\1 REDACTED'),
        (re.compile(r'(?i)\b(Bearer)\s+[A-Za-z0-9_.~+/-]+=*'), r'\1 REDACTED'),
        (re.compile(r'\b[0-9A-Za-z_-]{12,}\.[0-9A-Za-z_-]{12,}\.[0-9A-Za-z_-]{12,}\b'), 'REDACTED_JWT'),
        (re.compile(r'\bAKIA[0-9A-Z]{16}\b'), 'AKIA_REDACTED'),
        (re.compile(r'\bASIA[0-9A-Z]{16}\b'), 'ASIA_REDACTED'),
        (re.compile(r'\bgh[pousr]_[A-Za-z0-9]{20,}\b'), 'GH_REDACTED'),
        (re.compile(r'\bgithub_pat_[A-Za-z0-9_]{20,}\b'), 'GH_PAT_REDACTED'),
        (re.compile(r'\bxox[baprs]-[A-Za-z0-9-]{10,}\b'), 'SLACK_REDACTED'),
        (re.compile(r'\bAIza[0-9A-Za-z_-]{35}\b'), 'GCP_REDACTED'),
        (re.compile(r'\bya29\.[A-Za-z0-9_-]{10,}\b'), 'OAUTH_REDACTED'),
        (re.compile(r'-----BEGIN [A-Z ]*PRIVATE KEY-----'), '-----BEGIN PRIVATE KEY-----'),
        (re.compile(r'-----END [A-Z ]*PRIVATE KEY-----'), '-----END PRIVATE KEY-----'),
    ]
    out = s
    for pat, rep in pats:
        out = pat.sub(rep, out)
    return out

def redact_json_obj(obj):
    if isinstance(obj, dict):
        return {k: redact_json_obj(v) for k, v in obj.items()}
    if isinstance(obj, list):
        return [redact_json_obj(v) for v in obj]
    if isinstance(obj, str):
        if redact_json_strict:
            return "REDACTED"
        return redact_line(obj)
    return obj

def parse_kv_line(line: str):
    d = {}
    for p in line.strip().split():
        if "=" in p:
            k, v = p.split("=", 1)
            d[k] = v
    return d

def read_summary_rows(summary_path):
    rows = []
    if summary_path and os.path.exists(summary_path):
        with open(summary_path, "r", encoding="utf-8", errors="ignore") as f:
            for line in f:
                if line.startswith("monitor="):
                    rows.append(parse_kv_line(line))
    return rows

def ensure_totals(src):
    base = {"CRIT": 0, "WARN": 0, "UNKNOWN": 0, "SKIP": 0, "OK": 0}
    if isinstance(src, dict):
        for k in base:
            try:
                base[k] = int(src.get(k, 0))
            except Exception:
                base[k] = 0
    return base

def status_rank(st):
    return {"OK": 0, "WARN": 1, "CRIT": 2, "UNKNOWN": 3, "SKIP": 3}.get(st, 3)

status = read_json(status_path)
trend = read_json(trend_path)
runtimes = read_json(runtimes_path)

summary_file = ""
if isinstance(status, dict):
    summary_file = status.get("summary_file") or ""

rows = read_summary_rows(summary_file)

severity_totals = ensure_totals(status.get("totals") if isinstance(status, dict) else {})
if not rows and not any(severity_totals.values()):
    severity_totals = {"CRIT": 0, "WARN": 0, "UNKNOWN": 0, "SKIP": 0, "OK": 0}
elif rows and not any(severity_totals.values()):
    for r in rows:
        st = (r.get("status") or "UNKNOWN").upper()
        if st not in severity_totals:
            st = "UNKNOWN"
        severity_totals[st] += 1

host_status = {}
for r in rows:
    host = r.get("host") or ""
    if not host:
        continue
    st = (r.get("status") or "UNKNOWN").upper()
    if st not in severity_totals:
        st = "UNKNOWN"
    prev = host_status.get(host)
    if prev is None or status_rank(st) >= status_rank(prev):
        host_status[host] = st

host_counts = {"CRIT": 0, "WARN": 0, "UNKNOWN": 0, "SKIP": 0, "OK": 0}
for st in host_status.values():
    host_counts[st] = host_counts.get(st, 0) + 1

monitor_durations_ms = {}
if isinstance(runtimes, dict):
    for row in runtimes.get("rows", []) or []:
        if not isinstance(row, dict):
            continue
        mon = row.get("monitor")
        ms = row.get("ms")
        if mon is None or ms is None:
            continue
        try:
            ms_val = int(ms)
        except Exception:
            continue
        prev = monitor_durations_ms.get(mon)
        if prev is None or ms_val > prev:
            monitor_durations_ms[mon] = ms_val

out = {
    "metrics_json_contract_version": 1,
    "status": status,
    "trend": trend,
    "runtimes": runtimes,
    "severity_totals": severity_totals,
    "host_counts": host_counts,
    "monitor_durations_ms": monitor_durations_ms,
}

if redact_json or redact_json_strict:
    out = redact_json_obj(out)
print(json.dumps(out, indent=2, sort_keys=True))
PY

    rm -f "$tmp_status" "$tmp_trend" "$tmp_runtimes" 2>/dev/null || true
    ;;

  config)
    if [[ "$MODE" == "installed" ]]; then
      need_root_for config
    fi

    CFG_JSON=0
    CFG_SOURCES=0
    CFG_LINT=0
    while [[ $# -gt 0 ]]; do
      case "$1" in
        --json) CFG_JSON=1; shift 1;;
        --sources) CFG_SOURCES=1; shift 1;;
        --lint) CFG_LINT=1; shift 1;;
        -h|--help)
          command_usage config
          exit 0;;
        *) echo "Unknown config flag: $1" >&2; exit 2;;
      esac
    done

    CFG_DIR="${LM_CFG_DIR:-/etc/linux_maint}"
    main_conf="$CFG_DIR/linux-maint.conf"
    conf_d="$CFG_DIR/conf.d"
    conf_files=()
    [[ -f "$main_conf" ]] && conf_files+=("$main_conf")
    if [[ -d "$conf_d" ]]; then
      while IFS= read -r f; do
        [[ -f "$f" ]] && conf_files+=("$f")
      done < <(find "$conf_d" -maxdepth 1 -type f -name '*.conf' 2>/dev/null | sort)
    fi

    if [[ "${#conf_files[@]}" -eq 0 ]]; then
      if [[ "$CFG_JSON" -eq 1 ]]; then
        printf '{\n  "error": "no_config",\n  "cfg_dir": "%s",\n  "message": "No config files found"\n}\n' "$CFG_DIR"
        echo "Hint: sudo linux-maint init" >&2
      else
        if color_enabled; then
          echo "${C_RED}No config files found in ${CFG_DIR}${C_RESET}"
        else
          echo "No config files found in $CFG_DIR"
        fi
        hint_line "sudo linux-maint init"
      fi
      exit 1
    fi

    CFG_COLOR=1
    [[ -n "${NO_COLOR:-}" || -n "${LM_NO_COLOR:-}" ]] && CFG_COLOR=0
    color_enabled || CFG_COLOR=0
    CFG_DIR="$CFG_DIR" CFG_SOURCES="$CFG_SOURCES" CFG_JSON="$CFG_JSON" CFG_LINT="$CFG_LINT" CFG_COLOR="$CFG_COLOR" python3 - "${conf_files[@]}" <<'PY'
import json, os, re, shlex, subprocess, sys

cfg_dir = os.environ.get("CFG_DIR", "/etc/linux_maint")
show_sources = os.environ.get("CFG_SOURCES", "0") == "1"
json_mode = os.environ.get("CFG_JSON", "0") == "1"
lint_mode = os.environ.get("CFG_LINT", "0") == "1"
color = os.environ.get("CFG_COLOR", "0") == "1"
files = sys.argv[1:]

def c(s, code):
    if not color:
        return s
    return f"\033[{code}m{s}\033[0m"

def header(text):
    if not color:
        return text
    if text.startswith("=== ") and text.endswith(" ==="):
        inner = text[4:-4]
        return f"=== {c(inner, '1;36')} ==="
    return c(text, "1;36")

def extract_keys(paths):
    keys = []
    seen = set()
    for p in paths:
        try:
            with open(p, "r", encoding="utf-8", errors="ignore") as f:
                for raw in f:
                    line = raw.strip()
                    if not line or line.startswith("#"):
                        continue
                    m = re.match(r"^([A-Za-z_][A-Za-z0-9_]*)\s*=", line)
                    if not m:
                        continue
                    k = m.group(1)
                    if k not in seen:
                        seen.add(k)
                        keys.append(k)
        except FileNotFoundError:
            continue
    return keys

def lint(paths):
    invalid = []
    seen = {}
    for p in paths:
        try:
            with open(p, "r", encoding="utf-8", errors="ignore") as f:
                for i, raw in enumerate(f, start=1):
                    line = raw.strip()
                    if not line or line.startswith("#"):
                        continue
                    if line.startswith("export "):
                        line = line[len("export "):].lstrip()
                    m = re.match(r"^([A-Za-z_][A-Za-z0-9_]*)\s*=", line)
                    if not m:
                        invalid.append((p, i, raw.rstrip()))
                        continue
                    k = m.group(1)
                    seen.setdefault(k, []).append((p, i))
        except FileNotFoundError:
            continue
    duplicates = {k: v for k, v in seen.items() if len(v) > 1}
    return invalid, duplicates

if lint_mode:
    invalid, duplicates = lint(files)
    print(header("=== linux-maint config lint ==="))
    print(f"cfg_dir={cfg_dir}")
    if invalid:
        print(c("\ninvalid lines:", "1;33"))
        for p, i, line in invalid[:50]:
            print(f"- {p}:{i}: {line}")
    else:
        print(c("\ninvalid lines: none", "1;32"))
    if duplicates:
        print(c("\nduplicate keys:", "1;33"))
        for k, locs in sorted(duplicates.items()):
            loc_str = ", ".join(f"{p}:{i}" for p, i in locs[:6])
            print(f"- {k}: {loc_str}")
    else:
        print(c("\nduplicate keys: none", "1;32"))
    if invalid:
        sys.exit(1)
    sys.exit(0)

keys = extract_keys(files)
if not keys:
    if json_mode:
        print(json.dumps({"error": "no_keys", "cfg_dir": cfg_dir, "sources": files}, indent=2, sort_keys=True))
    else:
        print(f"No config keys found in {cfg_dir}")
    sys.exit(1)

src_cmd = "set -a; " + " ".join(f". {shlex.quote(p)};" for p in files) + " env"
proc = subprocess.run(["/bin/bash", "-lc", src_cmd], capture_output=True, text=True)
env = {}
if proc.returncode == 0:
    for line in proc.stdout.splitlines():
        if "=" not in line:
            continue
        k, v = line.split("=", 1)
        env[k] = v
else:
    msg = proc.stderr.strip() or "failed to source config"
    if json_mode:
        print(json.dumps({"error": msg, "cfg_dir": cfg_dir, "sources": files}, indent=2, sort_keys=True))
    else:
        print(f"ERROR: {msg}")
        print(c("Hint: run 'sudo linux-maint config'", "1;33"))
    sys.exit(1)

values = {k: env.get(k, "") for k in keys}

if json_mode:
    out = {
        "config_json_contract_version": 1,
        "cfg_dir": cfg_dir,
        "sources": files,
        "values": values,
    }
    print(json.dumps(out, indent=2, sort_keys=True))
    sys.exit(0)

print(header("=== linux-maint config (effective) ==="))
print(f"cfg_dir={cfg_dir}")
if show_sources:
    print(c("sources:", "1;36"))
    for p in files:
        print(f"- {p}")
print("")
width = max(len(k) for k in keys)
print(f"{'KEY':<{width}} VALUE")
for k in keys:
    print(f"{k:<{width}} {values.get(k,'')}")
PY
    ;;

  version)
    if [[ -f "$SHARE/BUILD_INFO" ]]; then
      cat "$SHARE/BUILD_INFO"
    else
      echo "BUILD_INFO not found at $SHARE/BUILD_INFO"
      exit 1
    fi
    ;;

  preflight)
    if [[ "$MODE" == "installed" ]]; then
      need_root_for preflight
    fi
    exec bash "$preflight"
    ;;

  validate)
    if [[ "$MODE" == "installed" ]]; then
      need_root_for validate
    fi
    exec bash "$validate"
    ;;

  check)
    if [[ "$MODE" == "installed" ]]; then
      need_root_for check
    fi

    CHECK_JSON=0
    while [[ $# -gt 0 ]]; do
      case "$1" in
        --json) CHECK_JSON=1; shift 1;;
        -h|--help)
          command_usage check
          exit 0;;
        *) echo "Unknown check flag: $1" >&2; exit 2;;
      esac
    done

    print_check_status() {
      local label="$1" rc="$2" status color
      case "$rc" in
        0) status="OK"; color="$C_GREEN" ;;
        1) status="WARN"; color="$C_YELLOW" ;;
        2) status="CRIT"; color="$C_RED" ;;
        *) status="UNKNOWN"; color="$C_RED" ;;
      esac
      if color_enabled; then
        printf '%s: %s%s%s\n' "$label" "$color" "$status" "$C_RESET"
      else
        printf '%s: %s\n' "$label" "$status"
      fi
    }
    rc_to_status() {
      local rc="$1"
      case "$rc" in
        0) echo "OK" ;;
        1) echo "WARN" ;;
        2) echo "CRIT" ;;
        *) echo "UNKNOWN" ;;
      esac
    }

    set +e
    if [[ "$CHECK_JSON" -eq 1 ]]; then
      cv_out="$(bash "$validate" 2>&1)"
      cv_rc=$?
      pf_out="$(bash "$preflight" 2>&1)"
      pf_rc=$?
    else
      section "config_validate"
      bash "$validate"
      cv_rc=$?
      print_check_status "config_validate" "$cv_rc"
      echo ""
      section "preflight"
      bash "$preflight"
      pf_rc=$?
      print_check_status "preflight" "$pf_rc"
      echo ""
    fi
    set -e

    cfg_dir="/etc/linux_maint"
    if [[ "$MODE" == "repo" ]]; then
      cfg_dir="${LM_CFG_DIR:-$REPO_ROOT/.etc_linux_maint}"
      mkdir -p "$cfg_dir" 2>/dev/null || true
    fi
    if [[ "$CHECK_JSON" -eq 1 ]]; then
      ok="false"
      [[ "$cv_rc" -eq 0 && "$pf_rc" -eq 0 ]] && ok="true"
      printf '{'
      printf '"config_validate":{"status":"%s","exit_code":%s},' "$(rc_to_status "$cv_rc")" "$cv_rc"
      printf '"preflight":{"status":"%s","exit_code":%s},' "$(rc_to_status "$pf_rc")" "$pf_rc"
      printf '"expected_skips":%s,' "$(expected_skips_json "$cfg_dir")"
      printf '"ok":%s' "$ok"
      printf '}\n'
    else
      expected_skips "$cfg_dir"
    fi
    ;;

  history)
    if [[ "$MODE" == "installed" ]]; then
      need_root_for history
    fi

    LAST_N=10
    HISTORY_JSON=0
    HISTORY_TABLE=0
    HISTORY_COLOR=1
    HISTORY_COMPACT=0
    while [[ $# -gt 0 ]]; do
      case "$1" in
        --last) LAST_N="$2"; shift 2;;
        --json) HISTORY_JSON=1; shift 1;;
        --table) HISTORY_TABLE=1; shift 1;;
        --no-color) HISTORY_COLOR=0; shift 1;;
        --compact) HISTORY_COMPACT=1; shift 1;;
        -h|--help)
          command_usage history
          exit 0;;
        *) echo "Unknown history flag: $1" >&2; exit 2;;
      esac
    done
    [[ -n "${NO_COLOR:-}" || -n "${LM_NO_COLOR:-}" ]] && HISTORY_COLOR=0
    color_enabled || HISTORY_COLOR=0

    if [[ ! "$LAST_N" =~ ^[0-9]+$ ]] || (( LAST_N <= 0 )); then
      echo "ERROR: --last must be a positive integer" >&2
      exit 2
    fi

    if [[ "$MODE" == "repo" ]]; then
      state_dir="${LM_STATE_DIR:-$REPO_LOG_DIR}"
    else
      state_dir="${LM_STATE_DIR:-/var/lib/linux_maint}"
    fi
    index_file="${LM_RUN_INDEX_FILE:-$state_dir/run_index.jsonl}"

    HISTORY_NOTE=""
    if [[ ! -f "$index_file" ]]; then
      for alt in /var/tmp/run_index.jsonl /var/tmp/linux_maint/run_index.jsonl /tmp/linux_maint/run_index.jsonl; do
        if [[ -f "$alt" ]]; then
          index_file="$alt"
          HISTORY_NOTE="note: using run_index from $alt"
          break
        fi
      done
    fi

    LM_COLOR="$HISTORY_COLOR" HISTORY_NOTE="$HISTORY_NOTE" python3 - "$index_file" "$LAST_N" "$HISTORY_JSON" "$HISTORY_TABLE" "$HISTORY_COMPACT" <<'PY'
import json, os, sys
path, last_n, json_mode, table, compact = sys.argv[1:6]
last_n = int(last_n)
json_mode = json_mode == "1"
table = table == "1"
compact = compact == "1"
color = os.environ.get("LM_COLOR","1") == "1"
note = os.environ.get("HISTORY_NOTE","")

def c(s, code):
    if not color:
        return s
    return f"\033[{code}m{s}\033[0m"

def header(text):
    if not color:
        return text
    if text.startswith("=== ") and text.endswith(" ==="):
        inner = text[4:-4]
        return f"=== {c(inner, '1;36')} ==="
    return c(text, "1;36")

def color_status(st, text=None):
    label = text if text is not None else st
    if st == "CRIT":
        return c(label, "1;31")
    if st == "WARN":
        return c(label, "1;33")
    if st == "OK":
        return c(label, "1;32")
    if st == "UNKNOWN":
        return c(label, "1;35")
    if st == "SKIP":
        return c(label, "1;36")
    return label

def color_count(label, value):
    text = f"{label}={value}"
    if not color:
        return text
    try:
        v = int(value)
    except Exception:
        v = 0
    if v == 0:
        return text
    if label == "CRIT":
        return c(text, "1;31")
    if label == "WARN":
        return c(text, "1;33")
    if label == "OK":
        return c(text, "1;32")
    if label == "UNKNOWN":
        return c(text, "1;35")
    if label == "SKIP":
        return c(text, "1;36")
    return text

if not os.path.exists(path):
    print(c(f"No run index found: {path}", "1;31"))
    print(c("Hints:", "1;33"))
    print(c("- Run: sudo linux-maint run", "1;33"))
    print(c("- Or set LM_RUN_INDEX_FILE when invoking the wrapper", "1;33"))
    sys.exit(1)

rows=[]
with open(path, "r", encoding="utf-8", errors="ignore") as f:
    for line in f:
        line=line.strip()
        if not line:
            continue
        try:
            rows.append(json.loads(line))
        except Exception:
            continue

rows = rows[-last_n:]
if json_mode:
    out = {
        "history_json_contract_version": 1,
        "runs": rows,
    }
    print(json.dumps(out, indent=2, sort_keys=True))
    raise SystemExit(0)

if compact:
    if rows:
        r = rows[-1]
        hosts = r.get("hosts",{}) or {}
        overall = r.get("overall","UNKNOWN")
        ov = color_status(overall)
        counts = [
            color_count("CRIT", hosts.get("crit",0)),
            color_count("WARN", hosts.get("warn",0)),
            color_count("UNKNOWN", hosts.get("unknown",0)),
            color_count("SKIP", hosts.get("skipped",0)),
            color_count("OK", hosts.get("ok",0)),
        ]
        print(f"last_run={r.get('timestamp','')} overall={ov} " + " ".join(counts))
    else:
        print("no runs")
    raise SystemExit(0)

if not rows:
    print(header("=== Last 0 runs (run_index) ==="))
    print("No runs recorded yet.")
    print(c("Hint: run sudo linux-maint run", "1;33"))
    raise SystemExit(0)

print(header(f"=== Last {len(rows)} runs (run_index) ==="))
if note:
    print(note)
if table:
    headers=("TIMESTAMP","OVERALL","EXIT_CODE","CRIT","WARN","UNKNOWN","SKIP","OK")
    table_rows=[]
    for r in rows:
        hosts = r.get("hosts",{}) or {}
        table_rows.append((
            r.get("timestamp",""),
            r.get("overall","UNKNOWN"),
            str(r.get("exit_code","")),
            str(hosts.get("crit",0)),
            str(hosts.get("warn",0)),
            str(hosts.get("unknown",0)),
            str(hosts.get("skipped",0)),
            str(hosts.get("ok",0)),
        ))
    w=[len(h) for h in headers]
    for row in table_rows:
        for i,v in enumerate(row):
            w[i]=max(w[i], len(v))
    def pad(s, width):
        return f"{s:<{width}}"
    print(" ".join(pad(headers[i], w[i]) for i in range(len(headers))))
    for row in table_rows:
        cells=[pad(row[i], w[i]) for i in range(len(headers))]
        overall=row[1]
        cells[1]=color_status(overall, cells[1])
        # Colorize count columns (crit/warn/unknown/skip/ok)
        if row[3] != "0":
            cells[3]=c(cells[3],"1;31")
        if row[4] != "0":
            cells[4]=c(cells[4],"1;33")
        if row[5] != "0":
            cells[5]=c(cells[5],"1;35")
        if row[6] != "0":
            cells[6]=c(cells[6],"1;36")
        if row[7] != "0":
            cells[7]=c(cells[7],"1;32")
        print(" ".join(cells))
else:
    for r in rows:
        ts = r.get("timestamp","")
        overall = r.get("overall","UNKNOWN")
        exit_code = r.get("exit_code","")
        hosts = r.get("hosts",{}) or {}
        counts = " ".join([
            color_count("CRIT", hosts.get("crit",0)),
            color_count("WARN", hosts.get("warn",0)),
            color_count("UNKNOWN", hosts.get("unknown",0)),
            color_count("SKIP", hosts.get("skipped",0)),
            color_count("OK", hosts.get("ok",0)),
        ])
        print(f"{ts} overall={color_status(overall)} exit_code={exit_code} {counts}")
PY
    ;;

  run-index)
    if [[ "$MODE" == "installed" ]]; then
      need_root_for run-index
    fi

    ACTION="stats"
    KEEP=200
    RI_JSON=0
    while [[ $# -gt 0 ]]; do
      case "$1" in
        --stats) ACTION="stats"; shift 1;;
        --prune) ACTION="prune"; shift 1;;
        --keep) KEEP="$2"; shift 2;;
        --json) RI_JSON=1; shift 1;;
        -h|--help)
          command_usage run-index
          exit 0;;
        *) echo "Unknown run-index flag: $1" >&2; exit 2;;
      esac
    done

    if [[ ! "$KEEP" =~ ^[0-9]+$ ]] || (( KEEP <= 0 )); then
      echo "ERROR: --keep must be a positive integer" >&2
      exit 2
    fi

    if [[ "$MODE" == "repo" ]]; then
      state_dir="${LM_STATE_DIR:-$REPO_LOG_DIR}"
    else
      state_dir="${LM_STATE_DIR:-/var/lib/linux_maint}"
    fi
    index_file="${LM_RUN_INDEX_FILE:-$state_dir/run_index.jsonl}"
    if [[ ! -f "$index_file" ]]; then
      for alt in /var/tmp/run_index.jsonl /var/tmp/linux_maint/run_index.jsonl /tmp/linux_maint/run_index.jsonl; do
        if [[ -f "$alt" ]]; then
          index_file="$alt"
          break
        fi
      done
    fi

    python3 - "$index_file" "$ACTION" "$KEEP" "$RI_JSON" <<'PY'
import json, os, sys, time, tempfile
path, action, keep_s, json_mode = sys.argv[1:5]
keep = int(keep_s)
json_mode = json_mode == "1"

exists = os.path.exists(path)
if not exists:
    if json_mode:
        print(json.dumps({"exists": False, "path": path}, indent=2, sort_keys=True))
    else:
        print(f"No run index found: {path}")
    sys.exit(1)

lines = []
with open(path, "r", encoding="utf-8", errors="ignore") as f:
    lines = [l for l in f if l.strip()]

count = len(lines)
last = {}
if lines:
    try:
        last = json.loads(lines[-1])
    except Exception:
        last = {}

if action == "prune":
    if keep > 0 and count > keep:
        lines = lines[-keep:]
        try:
            tmp_dir = os.path.dirname(path) or "."
            fd, tmp = tempfile.mkstemp(prefix=".run_index.", dir=tmp_dir)
            with os.fdopen(fd, "w", encoding="utf-8") as f:
                f.writelines(lines)
            os.replace(tmp, path)
        except Exception:
            pass
    if json_mode:
        print(json.dumps({"path": path, "kept": min(count, keep), "total_before": count}, indent=2, sort_keys=True))
    else:
        print(f"run_index_pruned path={path} kept={min(count, keep)} total_before={count}")
    sys.exit(0)

if json_mode:
    out = {
        "path": path,
        "count": count,
        "last": last,
    }
    print(json.dumps(out, indent=2, sort_keys=True))
else:
    print(f"run_index path={path} count={count}")
    if last:
        ts = last.get("timestamp","")
        overall = last.get("overall","")
        code = last.get("exit_code","")
        print(f"last_run timestamp={ts} overall={overall} exit_code={code}")
PY
    ;;

  summary)
    if [[ "$MODE" == "installed" ]]; then
      need_root_for summary
    fi

    SUMMARY_COLOR=1
    while [[ $# -gt 0 ]]; do
      case "$1" in
        --no-color) SUMMARY_COLOR=0; shift 1;;
        -h|--help)
          echo "Usage: linux-maint summary [--no-color]"
          exit 0;;
        *) echo "Unknown summary flag: $1" >&2; exit 2;;
      esac
    done
    [[ -n "${NO_COLOR:-}" || -n "${LM_NO_COLOR:-}" ]] && SUMMARY_COLOR=0
    color_enabled || SUMMARY_COLOR=0

    tmp_status="$(mktemp -p "$TMPDIR" linux_maint_summary_status.XXXXXX.json)"
    "$0" status --json --problems 0 >"$tmp_status" 2>/dev/null || printf '{}' >"$tmp_status"

    LM_COLOR="$SUMMARY_COLOR" python3 - "$tmp_status" <<'PY'
import json, os, sys

path = sys.argv[1]
color = os.environ.get("LM_COLOR","1") == "1"

def c(s, code):
    if not color:
        return s
    return f"\033[{code}m{s}\033[0m"

def color_status(st, text=None):
    label = text if text is not None else st
    if st == "CRIT":
        return c(label,"1;31")
    if st == "WARN":
        return c(label,"1;33")
    if st == "OK":
        return c(label,"1;32")
    if st == "UNKNOWN":
        return c(label,"1;35")
    if st == "SKIP":
        return c(label,"1;36")
    return label

try:
    with open(path, "r", encoding="utf-8") as f:
        status = json.load(f)
except Exception:
    status = {}

last = status.get("last_status", {})
overall = last.get("overall", "UNKNOWN")
exit_code = last.get("exit_code", "3")
summary_file = status.get("summary_file","")
totals = status.get("totals", {})

ov = color_status(overall)

parts = [
    f"overall={ov}",
    f"exit_code={exit_code}",
]
for k in ["CRIT","WARN","UNKNOWN","SKIP","OK"]:
    v = totals.get(k,0)
    kv = f"{k}={v}"
    if v != 0:
        kv = color_status(k, kv)
    parts.append(kv)
if summary_file:
    parts.append(f"summary={summary_file}")

print(" ".join(parts))
PY
    rm -f "$tmp_status" 2>/dev/null || true
    ;;

  status)
    if [[ "$MODE" == "installed" ]]; then
      need_root_for status
    fi

    ONLY=""
    TAIL_N=200
    VERBOSE=0
    QUIET=0
    PROB_N=20
    JSON=0
    LAST_N=0
    HOST_FILTER=""
    MONITOR_FILTER=""
    MATCH_MODE="contains"
    REASONS_N=0
    SINCE=""
    TABLE=0
    SUMMARY_ONLY=0
    SHOW_META=1
    EXPECTED_SKIPS=0
    GROUP_BY=""
    TOP_N=0
    PROM=0
    STRICT=0


    while [[ $# -gt 0 ]]; do
      case "$1" in
        --only) ONLY="$2"; shift 2;;
        --tail) TAIL_N="$2"; shift 2;;
        --verbose) VERBOSE=1; shift 1;;
        --quiet) QUIET=1; shift 1;;
        --json) JSON=1; shift 1;;
        --no-color) LM_COLOR=0; shift 1;;
        --table) TABLE=1; shift 1;;
        --summary) SUMMARY_ONLY=1; shift 1;;
        --expected-skips) EXPECTED_SKIPS=1; shift 1;;
        --compact) SHOW_META=0; shift 1;;
        --host) HOST_FILTER="$2"; shift 2;;
        --monitor) MONITOR_FILTER="$2"; shift 2;;
        --match-mode) MATCH_MODE="$2"; shift 2;;
        --problems) PROB_N="$2"; shift 2;;
        --reasons) REASONS_N="$2"; shift 2;;
        --group-by) GROUP_BY="$2"; shift 2;;
        --top) TOP_N="$2"; shift 2;;
        --prom) PROM=1; shift 1;;
        --since) SINCE="$2"; shift 2;;
        --last) LAST_N="$2"; shift 2;;
        --strict) STRICT=1; shift 1;;
        -h|--help)
          command_usage status
          exit 0;;
        *) echo "Unknown status flag: $1" >&2; exit 2;;
      esac
    done
    [[ -n "${NO_COLOR:-}" || -n "${LM_NO_COLOR:-}" ]] && LM_COLOR=0
    color_enabled || LM_COLOR=0

    if [[ "$JSON" -eq 1 && "$EXPECTED_SKIPS" -eq 1 ]]; then
      echo "ERROR: --expected-skips is not compatible with --json" >&2
      exit 2
    fi
    if [[ "$JSON" -eq 1 && "$PROM" -eq 1 ]]; then
      echo "ERROR: --prom is not compatible with --json" >&2
      exit 2
    fi

    if [[ "$SUMMARY_ONLY" -eq 1 ]]; then
      "$0" summary --no-color
      [[ "$TABLE" -eq 1 ]] || exit 0
      echo ""
    fi

    if [[ "$EXPECTED_SKIPS" -eq 1 ]]; then
      cfg_dir="/etc/linux_maint"
      if [[ "$MODE" == "repo" ]]; then
        cfg_dir="${LM_CFG_DIR:-$REPO_ROOT/.etc_linux_maint}"
        mkdir -p "$cfg_dir" 2>/dev/null || true
      fi
      expected_skips "$cfg_dir"
      echo ""
    fi

    if [[ "$PROM" -eq 1 ]]; then
      status_file=""
      if [[ "$MODE" == "repo" ]]; then
        status_file="$REPO_STATUS_FILE"
      else
        status_file="/var/log/health/last_status_full"
      fi

      summary_file=""
      if [[ "$MODE" == "repo" ]]; then
        summary_file="$REPO_SUMMARY_LATEST"
      else
        summary_file="$INST_SUMMARY_LATEST"
      fi

      python3 - "$status_file" "$summary_file" <<'PY'
import os, sys, re
from datetime import datetime, timezone

status_path, summary_path = sys.argv[1:3]

def read_kv(path):
    d={}
    if not path or not os.path.exists(path):
        return d
    with open(path,'r',encoding='utf-8',errors='ignore') as f:
        for line in f:
            line=line.strip()
            if not line or '=' not in line:
                continue
            k,v=line.split('=',1)
            d[k]=v
    return d

def get_kv(line, key):
    m=re.search(rf"\b{re.escape(key)}=([^ ]+)", line)
    return m.group(1) if m else None

status = read_kv(status_path)
overall = status.get("overall", "UNKNOWN")
exit_code_raw = status.get("exit_code", "")
timestamp_raw = status.get("timestamp", "")

def parse_exit_code(val):
    try:
        return int(val)
    except Exception:
        return -1

def parse_timestamp(ts):
    if not ts:
        return -1
    try:
        if ts.endswith("Z"):
            dt = datetime.strptime(ts, "%Y-%m-%dT%H:%M:%SZ").replace(tzinfo=timezone.utc)
        else:
            dt = datetime.strptime(ts, "%Y-%m-%dT%H:%M:%S%z")
        return int(dt.timestamp())
    except Exception:
        return -1

exit_code = parse_exit_code(exit_code_raw)
run_epoch = parse_timestamp(timestamp_raw)

counts = {k:0 for k in ["OK","WARN","CRIT","UNKNOWN","SKIP"]}
if summary_path and os.path.exists(summary_path):
    with open(summary_path,'r',encoding='utf-8',errors='ignore') as f:
        for line in f:
            line=line.strip()
            if not line:
                continue
            if not line.startswith("monitor="):
                continue
            st = get_kv(line, "status") or "UNKNOWN"
            if st not in counts:
                st = "UNKNOWN"
            counts[st] += 1

print("# HELP linux_maint_overall_status Overall status (labelled)")
print("# TYPE linux_maint_overall_status gauge")
for st in ["OK","WARN","CRIT","UNKNOWN","SKIP"]:
    val = 1 if st == overall else 0
    print(f"linux_maint_overall_status{{status=\"{st}\"}} {val}")
print("# HELP linux_maint_status_count Count of monitor results by status")
print("# TYPE linux_maint_status_count gauge")
for st in ["OK","WARN","CRIT","UNKNOWN","SKIP"]:
    print(f"linux_maint_status_count{{status=\"{st.lower()}\"}} {counts.get(st,0)}")
print("# HELP linux_maint_last_run_exit_code Exit code of last run (wrapper)")
print("# TYPE linux_maint_last_run_exit_code gauge")
print(f"linux_maint_last_run_exit_code {exit_code}")
print("# HELP linux_maint_last_run_timestamp Last run timestamp as epoch seconds (wrapper)")
print("# TYPE linux_maint_last_run_timestamp gauge")
print(f"linux_maint_last_run_timestamp {run_epoch}")
PY
      exit 0
    fi

    # Optional strict validation of summary lines (ensure monitor/host/status are valid).
    if [[ "$STRICT" -eq 1 ]]; then
      # Resolve summary file path the same way status does.
      if [[ "$MODE" == "repo" ]]; then
        summary_file="$REPO_SUMMARY_LATEST"
        log_dir="$REPO_LOG_DIR"
      else
        summary_file="$INST_SUMMARY_LATEST"
        log_dir="/var/log/health"
      fi
      if [[ -n "$SINCE" ]]; then
        tmp_since="$(mktemp -p "$TMPDIR" linux_maint_status_since.XXXXXX.log)"
        _run_tmpfiles+=("$tmp_since")
        python3 - "$log_dir" "$SINCE" <<'PY' | while IFS= read -r f; do
import os, re, sys, time
log_dir, since = sys.argv[1:3]
m = re.match(r'^(\d+)([smhd])$', since)
if not m:
    sys.exit(2)
num = int(m.group(1))
unit = m.group(2)
mult = {'s':1, 'm':60, 'h':3600, 'd':86400}[unit]
cutoff = time.time() - (num * mult)
pat = re.compile(r'^full_health_monitor_summary_(\d{4}-\d{2}-\d{2})_(\d{6})\.log$')
rows=[]
try:
    names=os.listdir(log_dir)
except FileNotFoundError:
    names=[]
for name in names:
    m2 = pat.match(name)
    if not m2:
        continue
    ts=f"{m2.group(1)} {m2.group(2)}"
    try:
        epoch=time.mktime(time.strptime(ts, "%Y-%m-%d %H%M%S"))
    except Exception:
        continue
    if epoch >= cutoff:
        rows.append((epoch, os.path.join(log_dir, name)))
rows.sort()
for _,p in rows:
    print(p)
PY
          [[ -f "$f" ]] && cat "$f" >> "$tmp_since"
        done
        summary_file="$tmp_since"
      fi
      if [[ ! -f "$summary_file" ]]; then
        echo "ERROR: strict status validation failed (missing summary file: $summary_file)" >&2
        exit 2
      fi
      if ! python3 - "$summary_file" <<'PY'
import sys
path = sys.argv[1]
allowed = {"OK","WARN","CRIT","UNKNOWN","SKIP"}
had = False
with open(path, "r", encoding="utf-8", errors="ignore") as f:
    for line in f:
        line = line.strip()
        if not line.startswith("monitor="):
            continue
        had = True
        has_monitor = has_host = has_status = False
        status = ""
        for tok in line.split():
            if "=" not in tok:
                print(f"bad token: {tok}", file=sys.stderr)
                sys.exit(2)
            key, val = tok.split("=", 1)
            if key == "monitor":
                has_monitor = True
            elif key == "host":
                has_host = True
            elif key == "status":
                has_status = True
                status = val
        if not (has_monitor and has_host and has_status):
            print(f"missing required fields: {line}", file=sys.stderr)
            sys.exit(2)
        if status not in allowed:
            print(f"invalid status: {status}", file=sys.stderr)
            sys.exit(2)
if not had:
    print("no monitor= lines found", file=sys.stderr)
    sys.exit(2)
PY
      then
        echo "ERROR: strict status validation failed" >&2
        exit 2
      fi
    fi

    case "$MATCH_MODE" in
      contains|exact|regex) ;;
      *)
        echo "ERROR: invalid --match-mode '$MATCH_MODE' (use contains|exact|regex)" >&2
        exit 2
        ;;
    esac
    case "$GROUP_BY" in
      ""|host|monitor|reason) ;;
      *)
        echo "ERROR: invalid --group-by '$GROUP_BY' (use host|monitor|reason)" >&2
        exit 2
        ;;
    esac
    if [[ ! "$TOP_N" =~ ^[0-9]+$ ]]; then
      echo "ERROR: --top must be a non-negative integer" >&2
      exit 2
    fi
    if (( TOP_N > 0 )) && [[ -z "$GROUP_BY" ]]; then
      echo "ERROR: --top requires --group-by" >&2
      exit 2
    fi

    # Validate/cap PROB_N (default 20, max 100)
    if [[ ! "$PROB_N" =~ ^[0-9]+$ ]]; then
      PROB_N=20

    elif (( PROB_N > 100 )); then
      PROB_N=100
    elif (( PROB_N < 0 )); then
      PROB_N=0
    fi

    # Validate/cap REASONS_N (default 0=disabled, max 20)
    if [[ ! "$REASONS_N" =~ ^[0-9]+$ ]]; then
      REASONS_N=0
    elif (( REASONS_N > 20 )); then
      REASONS_N=20
    elif (( REASONS_N < 0 )); then
      REASONS_N=0
    fi


    # Validate --since duration (optional): <int><s|m|h|d>
    if [[ -n "$SINCE" && ! "$SINCE" =~ ^[0-9]+[smhd]$ ]]; then
      echo "ERROR: invalid --since '$SINCE' (use like 30s, 15m, 2h, 1d)" >&2
      exit 2
    fi

    # History mode: show last N wrapper runs (best-effort)
    if [[ "${LAST_N:-0}" -gt 0 ]]; then
      if [[ "$MODE" == "repo" ]]; then
        log_dir="$REPO_LOG_DIR"
      else
        log_dir="/var/log/health"
      fi
      echo "=== Last ${LAST_N} runs ==="
      color_total() {
        local kv="$1" key val
        key="${kv%%=*}"
        val="${kv#*=}"
        if [[ "$LM_COLOR" -ne 1 || -z "$val" || "$val" == "0" ]]; then
          printf '%s' "$kv"
          return
        fi
        case "$key" in
          CRIT) printf '%s' "${C_RED}${kv}${C_RESET}" ;;
          WARN) printf '%s' "${C_YELLOW}${kv}${C_RESET}" ;;
          UNKNOWN) printf '%s' "${C_YELLOW}${kv}${C_RESET}" ;;
          SKIP) printf '%s' "${C_CYAN}${kv}${C_RESET}" ;;
          OK) printf '%s' "${C_GREEN}${kv}${C_RESET}" ;;
          *) printf '%s' "$kv" ;;
        esac
      }
      # shellcheck disable=SC2012
      ls -1t "$log_dir"/full_health_monitor_summary_[0-9][0-9][0-9][0-9]-[0-9][0-9]-[0-9][0-9]_[0-9][0-9][0-9][0-9][0-9][0-9].log 2>/dev/null | head -n "$LAST_N" | while read -r f; do
        ts="$(basename "$f" | sed -E "s/^full_health_monitor_summary_([0-9-]+)_(\\d+)[.]log$/\1T\2/")"
        totals="$(awk '/^monitor=/{for(i=1;i<=NF;i++) if($i ~ /^status=/){split($i,a,"="); s=a[2]; c[s]++}} END{printf("CRIT=%d WARN=%d UNKNOWN=%d SKIP=%d OK=%d",c["CRIT"]+0,c["WARN"]+0,c["UNKNOWN"]+0,c["SKIP"]+0,c["OK"]+0)}' "$f" 2>/dev/null)"
        if [[ "$LM_COLOR" -eq 1 ]]; then
          colored_totals=()
          for kv in $totals; do
            colored_totals+=("$(color_total "$kv")")
          done
          totals="${colored_totals[*]}"
        fi
        echo "$ts $totals file=$f"
      done
      exit 0
    fi

    if [[ "$JSON" -eq 1 ]]; then
      # JSON mode: emit a single JSON object and exit.
      status_file=""
      if [[ "$MODE" == "repo" ]]; then
        status_file="$REPO_STATUS_FILE"
      else
        status_file="/var/log/health/last_status_full"
      fi

      summary_file=""
      if [[ "$MODE" == "repo" ]]; then
        summary_file="$REPO_SUMMARY_LATEST"
        log_dir="$REPO_LOG_DIR"
      else
        summary_file="$INST_SUMMARY_LATEST"
        log_dir="/var/log/health"
      fi

      if [[ -n "$SINCE" ]]; then
        tmp_since="$(mktemp -p "$TMPDIR" linux_maint_status_since.XXXXXX.log)"
        _run_tmpfiles+=("$tmp_since")
        python3 - "$log_dir" "$SINCE" <<'PY' | while IFS= read -r f; do
import os, re, sys, time
log_dir, since = sys.argv[1:3]
m = re.match(r'^(\d+)([smhd])$', since)
if not m:
    sys.exit(2)
num = int(m.group(1))
unit = m.group(2)
mult = {'s':1, 'm':60, 'h':3600, 'd':86400}[unit]
cutoff = time.time() - (num * mult)
pat = re.compile(r'^full_health_monitor_summary_(\d{4}-\d{2}-\d{2})_(\d{6})\.log$')
rows=[]
try:
    names=os.listdir(log_dir)
except FileNotFoundError:
    names=[]
for name in names:
    m2 = pat.match(name)
    if not m2:
        continue
    ts=f"{m2.group(1)} {m2.group(2)}"
    try:
        epoch=time.mktime(time.strptime(ts, "%Y-%m-%d %H%M%S"))
    except Exception:
        continue
    if epoch >= cutoff:
        rows.append((epoch, os.path.join(log_dir, name)))
rows.sort()
for _,p in rows:
    print(p)
PY
          [[ -f "$f" ]] && cat "$f" >> "$tmp_since"
        done
        summary_file="$tmp_since"
      fi

      python3 - "$MODE" "$status_file" "$summary_file" "$ONLY" "$PROB_N" "$HOST_FILTER" "$MONITOR_FILTER" "$MATCH_MODE" "$REASONS_N" <<'PY'
import json, os, re, sys

mode, status_path, summary_path, only, limit, host_filter, monitor_filter, match_mode, reasons_limit = sys.argv[1:10]
limit=int(limit)
reasons_limit=int(reasons_limit)
redact_json = os.environ.get("LM_REDACT_JSON","0") in ("1","true","TRUE","yes","YES")
redact_json_strict = os.environ.get("LM_REDACT_JSON_STRICT","0") in ("1","true","TRUE","yes","YES")

def read_kv(path):
    d={}
    if not path or not os.path.exists(path):
        return d
    with open(path,'r',encoding='utf-8',errors='ignore') as f:
        for line in f:
            line=line.strip()
            if not line or '=' not in line:
                continue
            k,v=line.split('=',1)
            d[k]=v
    return d

def get_kv(line, key):
    m=re.search(rf"\b{re.escape(key)}=([^ ]+)", line)
    return m.group(1) if m else None

def redact_line(s: str) -> str:
    pats = [
        (re.compile(r'(?i)\b([A-Za-z0-9_]*(password|passwd|token|api[_-]?key|secret|access[_-]?key|private[_-]?key|session([_-]?id)?|id[_-]?token|refresh[_-]?token|x[_-]?auth[_-]?token)[A-Za-z0-9_]*)=([^ \t]+)'), r'\1=REDACTED'),
        (re.compile(r'(?i)\b(Authorization:|X-Auth-Token:)\s+[^ \t]+'), r'\1 REDACTED'),
        (re.compile(r'(?i)\b(Bearer)\s+[A-Za-z0-9_.~+/-]+=*'), r'\1 REDACTED'),
        (re.compile(r'\b[0-9A-Za-z_-]{12,}\.[0-9A-Za-z_-]{12,}\.[0-9A-Za-z_-]{12,}\b'), 'REDACTED_JWT'),
        (re.compile(r'\bAKIA[0-9A-Z]{16}\b'), 'AKIA_REDACTED'),
        (re.compile(r'\bASIA[0-9A-Z]{16}\b'), 'ASIA_REDACTED'),
        (re.compile(r'\bgh[pousr]_[A-Za-z0-9]{20,}\b'), 'GH_REDACTED'),
        (re.compile(r'\bgithub_pat_[A-Za-z0-9_]{20,}\b'), 'GH_PAT_REDACTED'),
        (re.compile(r'\bxox[baprs]-[A-Za-z0-9-]{10,}\b'), 'SLACK_REDACTED'),
        (re.compile(r'\bAIza[0-9A-Za-z_-]{35}\b'), 'GCP_REDACTED'),
        (re.compile(r'\bya29\.[A-Za-z0-9_-]{10,}\b'), 'OAUTH_REDACTED'),
        (re.compile(r'-----BEGIN [A-Z ]*PRIVATE KEY-----'), '-----BEGIN PRIVATE KEY-----'),
        (re.compile(r'-----END [A-Z ]*PRIVATE KEY-----'), '-----END PRIVATE KEY-----'),
    ]
    out = s
    for pat, rep in pats:
        out = pat.sub(rep, out)
    return out

def redact_json_obj(obj):
    if isinstance(obj, dict):
        return {k: redact_json_obj(v) for k, v in obj.items()}
    if isinstance(obj, list):
        return [redact_json_obj(v) for v in obj]
    if isinstance(obj, str):
        if redact_json_strict:
            return "REDACTED"
        return redact_line(obj)
    return obj

def matched(value, flt):
    if not flt:
        return True
    if match_mode == 'contains':
        return flt in value
    if match_mode == 'exact':
        return value == flt
    try:
        return re.search(flt, value) is not None
    except re.error as e:
        print(f"ERROR: invalid regex for --match-mode regex: {e}", file=sys.stderr)
        sys.exit(2)

status=read_kv(status_path)

counts={}
problems=[]
reason_counts={}
runtime_warnings=[]
if summary_path and os.path.exists(summary_path):
    with open(summary_path,'r',encoding='utf-8',errors='ignore') as f:
        for line in f:
            line=line.strip()
            if not line.startswith('monitor='):
                continue
            st=get_kv(line,'status') or 'UNKNOWN'
            host=get_kv(line,'host') or ''
            monitor=get_kv(line,'monitor') or ''
            if only and st != only:
                continue
            if not matched(host, host_filter):
                continue
            if not matched(monitor, monitor_filter):
                continue
            counts[st]=counts.get(st,0)+1
            if monitor == 'runtime_guard':
                warn_entry={'status':st,'monitor':monitor,'host':host}
                for key in ('reason','target_monitor','runtime_ms','threshold_ms'):
                    val=get_kv(line,key)
                    if val is not None:
                        warn_entry[key]=val
                runtime_warnings.append(warn_entry)
            if st!='OK':
                mon=monitor or 'unknown_monitor'
                reason=get_kv(line,'reason')
                entry={'status':st,'monitor':mon,'host':host}
                if reason:
                    entry['reason']=reason
                    reason_counts[reason]=reason_counts.get(reason,0)+1
                problems.append(entry)

sev_order={'CRIT':0,'WARN':1,'UNKNOWN':2,'SKIP':3,'OK':4}
problems.sort(key=lambda e: sev_order.get(e.get('status','UNKNOWN'), 9))

out={
    'mode': mode,
    'status_json_contract_version': 1,
    'last_status': status,
    'summary_file': summary_path if summary_path and os.path.exists(summary_path) else None,
    'totals': {k: counts.get(k,0) for k in ['CRIT','WARN','UNKNOWN','SKIP','OK']},
    'problems': problems[:limit],
    'runtime_warnings': runtime_warnings,
}
if reasons_limit > 0:
    rollup=sorted(reason_counts.items(), key=lambda kv: (-kv[1], kv[0]))
    out['reason_rollup']=[{'reason':r,'count':c} for r,c in rollup[:reasons_limit]]
if redact_json or redact_json_strict:
    out = redact_json_obj(out)
print(json.dumps(out, indent=2, sort_keys=True))
PY
      exit 0
    fi
    if [[ "$QUIET" -eq 0 && "$SHOW_META" -eq 1 ]]; then

      # Banner: overall health (best-effort)
      if [[ "$MODE" == "repo" ]]; then
        status_file="$REPO_STATUS_FILE"
      else
        status_file="/var/log/health/last_status_full"
      fi
      if [[ -f "$status_file" ]]; then
        overall_val="$(awk -F= '$1=="overall"{print $2}' "$status_file" 2>/dev/null || true)"
        exit_val="$(awk -F= '$1=="exit_code"{print $2}' "$status_file" 2>/dev/null || true)"
        banner="health=${overall_val:-UNKNOWN} exit_code=${exit_val:-3}"
        case "$overall_val" in
          CRIT) banner="${C_RED}${banner}${C_RESET}" ;;
          WARN) banner="${C_YELLOW}${banner}${C_RESET}" ;;
          OK)   banner="${C_GREEN}${banner}${C_RESET}" ;;
        esac
        if color_enabled; then
          echo "=== ${C_CYAN}linux-maint status${C_RESET} === $banner"
        else
          echo "=== linux-maint status === $banner"
        fi
      else
        section "linux-maint status"
      fi

    if [[ "$MODE" == "repo" ]]; then
      section "Mode"
      echo "repo"
      echo "repo_root: ${C_BOLD}${REPO_ROOT}${C_RESET}"
      echo "linux_maint_lib: ${C_BOLD}${LINUX_MAINT_LIB:-}${C_RESET}"
      echo "logs: ${C_BOLD}${REPO_LOG_DIR}${C_RESET}"
      echo ""; section "Last run status"
      if [[ -f "$REPO_STATUS_FILE" ]]; then
        cat "$REPO_STATUS_FILE"
      else
        echo "No status file: $REPO_STATUS_FILE"
      fi
    else
      status_file="/var/log/health/last_status_full"
      section "Mode"
      echo "${C_BOLD}installed${C_RESET}"
      echo "prefix: ${C_BOLD}${PREFIX}${C_RESET}"
      echo ""; section "Installed paths"
      echo "wrapper: ${C_BOLD}$SBIN/run_full_health_monitor.sh${C_RESET}"
      echo "libexec: ${C_BOLD}$LIBEXEC${C_RESET}"
      echo "build_info: ${C_BOLD}$SHARE/BUILD_INFO${C_RESET}"
      [[ -f "$SHARE/BUILD_INFO" ]] && { echo ""; cat "$SHARE/BUILD_INFO"; }
      echo ""; section "Last run status"
      if [[ -f "$status_file" ]]; then
        cat "$status_file"
      else
        echo "No status file: $status_file"
      fi
    fi

    fi

    # Default: compact summary (hide OK). Use --verbose to show full tail of summary file.
    VERBOSE=${VERBOSE:-0}

    if [[ "$QUIET" -eq 0 ]]; then
      echo ""; section "Summary (compact)"
      tip_line "Use --verbose to show raw monitor lines"
    fi
    summary_file=""
    if [[ "$MODE" == "repo" ]]; then
      summary_file="$REPO_SUMMARY_LATEST"
      log_dir="$REPO_LOG_DIR"
    else
      summary_file="$INST_SUMMARY_LATEST"
      log_dir="/var/log/health"
    fi

    if [[ "$QUIET" -eq 0 && "$SUMMARY_ONLY" -eq 0 && "$EXPECTED_SKIPS" -eq 0 && "$SHOW_META" -eq 1 ]]; then
      cfg_dir="/etc/linux_maint"
      if [[ "$MODE" == "repo" ]]; then
        cfg_dir="${LM_CFG_DIR:-$REPO_ROOT/.etc_linux_maint}"
      fi
      if banner="$(expected_skips_text "$cfg_dir")"; then
        echo "$banner"
        echo ""
      fi
    fi

    if [[ -n "$SINCE" ]]; then
      tmp_since="$(mktemp -p "$TMPDIR" linux_maint_status_since.XXXXXX.log)"
      _run_tmpfiles+=("$tmp_since")
      python3 - "$log_dir" "$SINCE" <<'PY' | while IFS= read -r f; do
import os, re, sys, time
log_dir, since = sys.argv[1:3]
m = re.match(r'^(\d+)([smhd])$', since)
if not m:
    sys.exit(2)
num = int(m.group(1))
unit = m.group(2)
mult = {'s':1, 'm':60, 'h':3600, 'd':86400}[unit]
cutoff = time.time() - (num * mult)
pat = re.compile(r'^full_health_monitor_summary_(\d{4}-\d{2}-\d{2})_(\d{6})\.log$')
rows=[]
try:
    names=os.listdir(log_dir)
except FileNotFoundError:
    names=[]
for name in names:
    m2 = pat.match(name)
    if not m2:
        continue
    ts=f"{m2.group(1)} {m2.group(2)}"
    try:
        epoch=time.mktime(time.strptime(ts, "%Y-%m-%d %H%M%S"))
    except Exception:
        continue
    if epoch >= cutoff:
        rows.append((epoch, os.path.join(log_dir, name)))
rows.sort()
for _,p in rows:
    print(p)
PY
        [[ -f "$f" ]] && cat "$f" >> "$tmp_since"
      done
      summary_file="$tmp_since"
    fi

    if [[ -f "$summary_file" ]]; then
      if [[ "$VERBOSE" -eq 1 ]]; then
        echo "(verbose; last $TAIL_N lines from: $summary_file)"
        if [[ -n "$ONLY" || -n "$HOST_FILTER" || -n "$MONITOR_FILTER" ]]; then
          python3 - "$summary_file" "$TAIL_N" "$ONLY" "$HOST_FILTER" "$MONITOR_FILTER" "$MATCH_MODE" <<'PY'
import re, sys

path, tail_n, only, host_filter, monitor_filter, match_mode = sys.argv[1:7]
tail_n=int(tail_n)

def get_kv(line, key):
    m=re.search(rf"\b{re.escape(key)}=([^ ]+)", line)
    return m.group(1) if m else None

def matched(value, flt):
    if not flt:
        return True
    if match_mode == 'contains':
        return flt in value
    if match_mode == 'exact':
        return value == flt
    try:
        return re.search(flt, value) is not None
    except re.error as e:
        print(f"ERROR: invalid regex for --match-mode regex: {e}", file=sys.stderr)
        sys.exit(2)

matched=[]
with open(path, 'r', encoding='utf-8', errors='ignore') as f:
    for line in f:
        line=line.strip()
        if not line.startswith('monitor='):
            continue
        st=get_kv(line,'status') or 'UNKNOWN'
        host=get_kv(line,'host') or ''
        monitor=get_kv(line,'monitor') or ''
        if only and st != only:
            continue
        if not matched(host, host_filter):
            continue
        if not matched(monitor, monitor_filter):
            continue
        matched.append(line)

for line in matched[-tail_n:]:
    print(line)
PY
        else
          tail -n "$TAIL_N" "$summary_file" || true
        fi
      else
        [[ "$QUIET" -eq 0 ]] && echo "(from: $summary_file)"
      STATUS_QUIET="$QUIET" LM_COLOR="$LM_COLOR" python3 - "$summary_file" "$ONLY" "$PROB_N" "$HOST_FILTER" "$MONITOR_FILTER" "$MATCH_MODE" "$REASONS_N" "$TABLE" "$GROUP_BY" "$TOP_N" <<'PY'
import re, sys, os
path, only, limit, host_filter, monitor_filter, match_mode, reasons_limit, table, group_by, top_n = sys.argv[1:11]
limit=int(limit)
reasons_limit=int(reasons_limit)
top_n=int(top_n)
color = os.environ.get("LM_COLOR","1") == "1"
table = table == "1"
group_by = group_by.strip()
quiet = os.environ.get("STATUS_QUIET","0") == "1"

def c(s, code):
    if not color:
        return s
    return f"\033[{code}m{s}\033[0m"

def section(title):
    if quiet:
        return
    print(c(title, "1;36"))

# Example line:
# monitor=config_validate host=localhost status=WARN node=localhost warn=1 crit=0 reason=...

def get_kv(line, key):
    m=re.search(rf"\b{re.escape(key)}=([^ ]+)", line)
    return m.group(1) if m else None

def matched(value, flt):
    if not flt:
        return True
    if match_mode == 'contains':
        return flt in value
    if match_mode == 'exact':
        return value == flt
    try:
        return re.search(flt, value) is not None
    except re.error as e:
        print(f"ERROR: invalid regex for --match-mode regex: {e}", file=sys.stderr)
        sys.exit(2)

counts={}
problems=[]
reason_counts={}
groups={}
with open(path, 'r', encoding='utf-8', errors='ignore') as f:
    for line in f:
        line=line.strip()
        if not line:
            continue
        st=get_kv(line,'status') or 'UNKNOWN'
        host=get_kv(line,'host') or ''
        monitor=get_kv(line,'monitor') or ''
        reason=get_kv(line,'reason') or ''
        if only and st != only:
            continue
        if not matched(host, host_filter):
            continue
        if not matched(monitor, monitor_filter):
            continue
        counts[st]=counts.get(st,0)+1
        if group_by:
            if group_by == 'host':
                key = host or 'unknown_host'
            elif group_by == 'monitor':
                key = monitor or 'unknown_monitor'
            else:
                key = reason
                if not key:
                    key = ""
            if group_by != 'reason' or key:
                g = groups.setdefault(key, {})
                g[st]=g.get(st,0)+1
        if st == 'OK':
            continue
        mon=monitor or 'unknown_monitor'
        problems.append({
            "status": st,
            "monitor": mon,
            "host": host,
            "reason": reason or "",
        })
        if reason:
            reason_counts[reason]=reason_counts.get(reason,0)+1

def color_status(st, text=None):
    label = text if text is not None else st
    if st=="CRIT":
        return c(label,'1;31')
    if st=="WARN":
        return c(label,'1;33')
    if st=="OK":
        return c(label,'1;32')
    if st=="UNKNOWN":
        return c(label,'1;35')
    if st=="SKIP":
        return c(label,'1;36')
    return label

order=['CRIT','WARN','UNKNOWN','SKIP','OK']
if not quiet:
    filters=[]
    if only:
        filters.append(f"only={only}")
    if host_filter:
        filters.append(f"host={host_filter}")
    if monitor_filter:
        filters.append(f"monitor={monitor_filter}")
    if (host_filter or monitor_filter) and match_mode:
        filters.append(f"match_mode={match_mode}")
    if group_by:
        filters.append(f"group_by={group_by}")
    if group_by and top_n > 0:
        filters.append(f"top={top_n}")
    if filters:
        print(c("filters: " + " ".join(filters), "1;36"))
if table:
    section("totals")
    print(c("totals:", "1;36"))
    maxk=max(len(k) for k in order)
    maxv=max(len(str(counts.get(k,0))) for k in order)
    print(f"  {'STATUS':<{maxk}} {'COUNT':<{maxv}}")
    for k in order:
        v=str(counts.get(k,0))
        label = color_status(k, f"{k:<{maxk}}")
        count = f"{v:<{maxv}}"
        if v != "0":
            count = color_status(k, count)
        print(f"  {label} {count}")
else:
    section("totals")
    parts=[]
    for k in order:
        v=str(counts.get(k,0))
        kv=f"{k}={v}"
        if v != "0":
            kv=color_status(k, kv)
        parts.append(kv)
    print('totals: ' + ' '.join(parts))

if group_by:
    if not quiet:
        print("")
    print(c(f"group_by={group_by}", "1;36"))
    print(c("groups:", "1;36"))
    def group_key(item):
        name, data = item
        worst = len(order)
        for i, st in enumerate(order):
            if data.get(st, 0) > 0:
                worst = i
                break
        return (worst, name)
    rows = sorted(groups.items(), key=group_key)
    if top_n > 0:
        rows = rows[:top_n]
    if table:
        maxg = max([len("GROUP")] + [len(n) for n,_ in rows]) if rows else len("GROUP")
        headers = ["CRIT","WARN","UNKNOWN","SKIP","OK","TOTAL"]
        maxv = {}
        for h in headers:
            maxv[h]=len(h)
        for _, data in rows:
            total = sum(data.get(st,0) for st in order)
            for h in headers:
                val = total if h == "TOTAL" else data.get(h,0)
                maxv[h]=max(maxv[h], len(str(val)))
        header_line = f"{'GROUP':<{maxg}} " + " ".join(f"{h:<{maxv[h]}}" for h in headers)
        print(header_line)
        for name, data in rows:
            total = sum(data.get(st,0) for st in order)
            parts = []
            for h in headers:
                val = total if h == "TOTAL" else data.get(h,0)
                cell = f"{val:<{maxv[h]}}"
                if h != "TOTAL" and str(val) != "0":
                    cell = color_status(h, cell)
                parts.append(cell)
            print(f"{name:<{maxg}} " + " ".join(parts))
    else:
        for name, data in rows:
            total = sum(data.get(st,0) for st in order)
            parts = []
            for st in order:
                val = data.get(st,0)
                kv = f"{st}={val}"
                if val != 0:
                    kv = color_status(st, kv)
                parts.append(kv)
            parts.append(f"TOTAL={total}")
            print(f"{name} " + " ".join(parts))

if problems:
    sev_order={'CRIT':0,'WARN':1,'UNKNOWN':2,'SKIP':3}
    problems.sort(key=lambda r: sev_order.get(r["status"], 9))
    show_n=min(limit, len(problems))
    if not quiet:
        print("")
    print(c(f"problems (top {show_n}):", "1;36"))
    if table:
        rows=[(p["status"], p["monitor"], p["host"], p["reason"]) for p in problems[:limit]]
        headers=("STATUS","MONITOR","HOST","REASON")
        w=[len(h) for h in headers]
        for r in rows:
            for i,v in enumerate(r):
                w[i]=max(w[i], len(str(v)))
        print(f"{headers[0]:<{w[0]}} {headers[1]:<{w[1]}} {headers[2]:<{w[2]}} {headers[3]}")
        for st,mon,host,reason in rows:
            s_pad=color_status(st, f"{st:<{w[0]}}")
            print(f"{s_pad} {mon:<{w[1]}} {host:<{w[2]}} {reason}")
    else:
        for p in problems[:limit]:
            st=color_status(p["status"])
            line=f"{st} {p['monitor']} host={p['host']}"
            if p["reason"]:
                line += f" reason={p['reason']}"
            print(line)
    if not quiet:
        print(c("\ntip: run 'linux-maint doctor' for fix suggestions", "1;33"))
else:
    if not quiet:
        print("")
    print(c('problems: none (all OK)', "1;32"))

if reasons_limit > 0:
    if not quiet:
        print("")
    print(c(f"reasons (top {reasons_limit}):", "1;36"))
    if reason_counts:
        rollup=sorted(reason_counts.items(), key=lambda kv: (-kv[1], kv[0]))
        for reason, count in rollup[:reasons_limit]:
            print(f"{reason}={count}")
        hints_map = {
            "permission_denied": "Run with sudo or fix permissions for logs/state/config.",
            "missing_optional_cmd": "Install the optional dependency listed in the monitor output.",
            "missing_dependency": "Install the required dependency on the runner/host.",
            "kernel_log_unreadable": "Check journal/dmesg permissions and ensure kernel logs are readable.",
            "collect_failed": "Inventory export failed; verify /var/log/inventory and required tools (ip, lsblk, lscpu).",
            "ports_baseline_changed": "Review listening port changes and update the baseline if expected.",
            "config_drift_changed": "Review config changes and update the baseline if intended.",
            "user_anomalies": "Review new/removed users and sudoers changes.",
            "ntp_drift_high": "Check NTP/chrony sync and clock drift.",
            "ntp_not_synced": "Check NTP/chrony sync.",
            "missing_log_source": "Ensure journald/syslog is available and readable.",
            "security_updates_pending": "Apply security updates via your package manager.",
            "updates_pending": "Apply pending package updates.",
            "baseline_missing": "Create a baseline via linux-maint baseline.",
            "baseline_created": "Baseline created; rerun to compare changes.",
            "baseline_updated": "Baseline updated; rerun to check for drift.",
            "baseline_exists": "Baseline already exists; use --update if you want to overwrite it.",
            "baseline_collect_failed": "Baseline collection failed; check permissions/SSH and retry.",
            "timer_missing": "Install/enable linux-maint.timer if you want scheduled runs.",
            "timer_disabled": "Enable linux-maint.timer (systemctl enable --now linux-maint.timer).",
            "timer_inactive": "Start linux-maint.timer (systemctl start linux-maint.timer).",
            "ssh_unreachable": "Verify SSH connectivity and credentials for the target host.",
            "stale_run": "Check timers/cron; last run appears too old.",
        }
        hints=[]
        for reason, _count in rollup[:reasons_limit]:
            if reason in hints_map and reason not in hints:
                hints.append(reason)
        if hints:
            print("\nhints:")
            for reason in hints[:5]:
                print(f"- {reason}: {hints_map[reason]}")
    else:
        print('none')
PY
      fi
    else
      echo "No summary file: $summary_file"
      if [[ "$TABLE" -eq 1 ]]; then
        echo "STATUS MONITOR HOST REASON"
      fi
      if color_enabled; then
        echo "${C_CYAN}Likely causes:${C_RESET}"
      else
        echo "Likely causes:"
      fi
      echo "- The wrapper has not been run yet"
      echo "- LOG_DIR/SUMMARY_DIR points elsewhere"
      echo "- Permission issue writing to /var/log/health (try sudo)"
      if color_enabled; then
        echo "${C_CYAN}Next steps:${C_RESET}"
      else
        echo "Next steps:"
      fi
      echo "- Run: sudo linux-maint run"
      echo "- Check logs: sudo linux-maint logs 200"
      echo "- Diagnose: sudo linux-maint doctor"
      echo "Falling back to grepping latest wrapper log"
      log="/var/log/health/full_health_monitor_latest.log"
      [[ "$MODE" == "repo" ]] && log="$REPO_LATEST_LOG"
      if [[ -f "$log" ]]; then
        grep -E " status=(WARN|CRIT|UNKNOWN)|SKIP:|SUMMARY_RESULT|FINAL_STATUS_SUMMARY|^\\[.*\\] monitor=" "$log" | tail -n 120 || true
      else
        echo "No log found at: $log"
        hint_line "run linux-maint run to generate logs"
      fi
    fi
    ;;


  trend)
    if [[ "$MODE" == "installed" ]]; then
      need_root_for trend
    fi

    LAST_N=10
    JSON=0
    CSV=0
    REDACT=0
    SINCE=""
    UNTIL=""
    while [[ $# -gt 0 ]]; do
      case "$1" in
        --last) LAST_N="$2"; shift 2 ;;
        --since|--from) SINCE="$2"; shift 2 ;;
        --until|--to) UNTIL="$2"; shift 2 ;;
        --json) JSON=1; shift 1 ;;
        --csv) CSV=1; shift 1 ;;
        --export)
          case "${2:-}" in
            csv) CSV=1; shift 2 ;;
            json) JSON=1; shift 2 ;;
            *) echo "ERROR: --export expects csv|json" >&2; exit 2 ;;
          esac
          ;;
        --redact) REDACT=1; shift 1 ;;
        -h|--help)
          command_usage trend
          exit 0 ;;
        *) echo "Unknown trend flag: $1" >&2; exit 2 ;;
      esac
    done

    if [[ ! "$LAST_N" =~ ^[0-9]+$ ]] || (( LAST_N <= 0 )); then
      echo "ERROR: --last must be a positive integer" >&2
      exit 2
    fi
    if [[ "$JSON" -eq 1 && "$CSV" -eq 1 ]]; then
      echo "ERROR: choose only one output format (--json or --csv)" >&2
      exit 2
    fi
    if [[ "$REDACT" -eq 1 && ( "$JSON" -eq 1 || "$CSV" -eq 1 ) ]]; then
      echo "ERROR: --redact is only for human output" >&2
      exit 2
    fi

    if [[ "$MODE" == "repo" ]]; then
      log_dir="${LOG_DIR:-$REPO_LOG_DIR}"
      cache_dir="${LM_STATE_DIR:-$REPO_LOG_DIR}"
    else
      log_dir="/var/log/health"
      cache_dir="${LM_STATE_DIR:-/var/lib/linux_maint}"
    fi

    TREND_COLOR=0
    color_enabled && TREND_COLOR=1
    LM_COLOR="$TREND_COLOR" TREND_REDACT="$REDACT" TREND_CACHE="${LM_TREND_CACHE:-0}" TREND_CACHE_TTL="${LM_TREND_CACHE_TTL:-60}" TREND_CACHE_FILE="${LM_TREND_CACHE_FILE:-$cache_dir/trend_cache.json}" python3 - "$log_dir" "$LAST_N" "$JSON" "$CSV" "$SINCE" "$UNTIL" <<'PY'
import glob, json, os, re, sys, time
import builtins

log_dir, last_n, json_mode, csv_mode, since_arg, until_arg = sys.argv[1:7]
last_n=int(last_n)
json_mode = json_mode == '1'
csv_mode = csv_mode == '1'
color = os.environ.get("LM_COLOR","1") == "1"
redact = os.environ.get("TREND_REDACT","0") == "1"
redact_json = os.environ.get("LM_REDACT_JSON","0") in ("1","true","TRUE","yes","YES")
redact_json_strict = os.environ.get("LM_REDACT_JSON_STRICT","0") in ("1","true","TRUE","yes","YES")
cache_enabled = os.environ.get("TREND_CACHE","0") == "1"
cache_ttl = int(os.environ.get("TREND_CACHE_TTL","60") or "60")
cache_file = os.environ.get("TREND_CACHE_FILE","")

def redact_line(s: str) -> str:
    pats = [
        (re.compile(r'(?i)\\b([A-Za-z0-9_]*(password|passwd|token|api[_-]?key|secret|access[_-]?key|private[_-]?key|session([_-]?id)?|id[_-]?token|refresh[_-]?token|x[_-]?auth[_-]?token)[A-Za-z0-9_]*)=([^ \\t]+)'), r'\\1=REDACTED'),
        (re.compile(r'(?i)\\b(Authorization:|X-Auth-Token:)\\s+[^ \\t]+'), r'\\1 REDACTED'),
        (re.compile(r'(?i)\\b(Bearer)\\s+[A-Za-z0-9_.~+/-]+=*'), r'\\1 REDACTED'),
        (re.compile(r'\\b[0-9A-Za-z_-]{12,}\\.[0-9A-Za-z_-]{12,}\\.[0-9A-Za-z_-]{12,}\\b'), 'REDACTED_JWT'),
        (re.compile(r'\\bAKIA[0-9A-Z]{16}\\b'), 'AKIA_REDACTED'),
        (re.compile(r'\\bASIA[0-9A-Z]{16}\\b'), 'ASIA_REDACTED'),
        (re.compile(r'\\bgh[pousr]_[A-Za-z0-9]{20,}\\b'), 'GH_REDACTED'),
        (re.compile(r'\\bgithub_pat_[A-Za-z0-9_]{20,}\\b'), 'GH_PAT_REDACTED'),
        (re.compile(r'\\bxox[baprs]-[A-Za-z0-9-]{10,}\\b'), 'SLACK_REDACTED'),
        (re.compile(r'\\bAIza[0-9A-Za-z_-]{35}\\b'), 'GCP_REDACTED'),
        (re.compile(r'\\bya29\\.[A-Za-z0-9_-]{10,}\\b'), 'OAUTH_REDACTED'),
        (re.compile(r'-----BEGIN [A-Z ]*PRIVATE KEY-----'), '-----BEGIN PRIVATE KEY-----'),
        (re.compile(r'-----END [A-Z ]*PRIVATE KEY-----'), '-----END PRIVATE KEY-----'),
    ]
    out = s
    for pat, rep in pats:
        out = pat.sub(rep, out)
    return out

def redact_json_obj(obj):
    if isinstance(obj, dict):
        return {k: redact_json_obj(v) for k, v in obj.items()}
    if isinstance(obj, list):
        return [redact_json_obj(v) for v in obj]
    if isinstance(obj, str):
        if redact_json_strict:
            return "REDACTED"
        return redact_line(obj)
    return obj

if redact and not json_mode and not csv_mode:
    def print(*args, **kwargs):
        sep = kwargs.get("sep", " ")
        end = kwargs.get("end", "\\n")
        text = sep.join(str(a) for a in args)
        builtins.print(redact_line(text), end=end)

def c(s, code):
    if not color:
        return s
    return f"\033[{code}m{s}\033[0m"

def header(text):
    if not color:
        return text
    if text.startswith("=== ") and text.endswith(" ==="):
        inner = text[4:-4]
        return f"=== {c(inner, '1;36')} ==="
    return c(text, "1;36")

def color_kv(k, v):
    text = f"{k}={v}"
    if not color or int(v) == 0:
        return text
    if k == "CRIT":
        return c(text, "1;31")
    if k == "WARN":
        return c(text, "1;33")
    if k == "UNKNOWN":
        return c(text, "1;35")
    if k == "SKIP":
        return c(text, "1;36")
    if k == "OK":
        return c(text, "1;32")
    return text

def parse_date_arg(s: str, end_of_day: bool = False):
    if not s:
        return None
    fmts = ("%Y-%m-%d", "%Y-%m-%d_%H%M%S", "%Y-%m-%dT%H:%M:%S")
    for fmt in fmts:
        try:
            ts = time.strptime(s, fmt)
            epoch = int(time.mktime(ts))
            if fmt == "%Y-%m-%d" and end_of_day:
                epoch += 86399
            return epoch
        except Exception:
            continue
    raise ValueError(f"invalid date: {s} (use YYYY-MM-DD or YYYY-MM-DD_HHMMSS)")

try:
    since_ts = parse_date_arg(since_arg, end_of_day=False)
    until_ts = parse_date_arg(until_arg, end_of_day=True)
except ValueError as exc:
    print(f"ERROR: {exc}", file=sys.stderr)
    sys.exit(2)

pat = os.path.join(log_dir, 'full_health_monitor_summary_[0-9][0-9][0-9][0-9]-[0-9][0-9]-[0-9][0-9]_[0-9][0-9][0-9][0-9][0-9][0-9].log')
all_files = glob.glob(pat)
file_rows = []
name_re = re.compile(r'full_health_monitor_summary_(\d{4}-\d{2}-\d{2})_(\d{6})\.log$')
for fp in all_files:
    m = name_re.search(os.path.basename(fp))
    if not m:
        continue
    try:
        ts = time.mktime(time.strptime(f"{m.group(1)} {m.group(2)}", "%Y-%m-%d %H%M%S"))
    except Exception:
        continue
    if since_ts is not None and ts < since_ts:
        continue
    if until_ts is not None and ts > until_ts:
        continue
    file_rows.append((ts, fp))
file_rows.sort(reverse=True)
files = [fp for _, fp in file_rows][:last_n]

if not files and not cache_enabled:
    if json_mode:
        print(json.dumps({'trend_json_contract_version': 1, 'runs':[], 'totals':{'CRIT':0,'WARN':0,'UNKNOWN':0,'SKIP':0,'OK':0}, 'reasons':[]}, indent=2, sort_keys=True))
    elif csv_mode:
        print("file,CRIT,WARN,UNKNOWN,SKIP,OK")
    else:
        print(f'No summary artifacts found in: {log_dir}')
    sys.exit(0)

order=['CRIT','WARN','UNKNOWN','SKIP','OK']
overall={k:0 for k in order}
reason_counts={}
runs=[]

def get_kv(line, key):
    m=re.search(rf"\b{re.escape(key)}=([^ ]+)", line)
    return m.group(1) if m else None

cache_hit = False
if cache_enabled and cache_file and os.path.exists(cache_file):
    try:
        age = time.time() - os.path.getmtime(cache_file)
        if age <= cache_ttl:
            cached = json.load(open(cache_file, "r", encoding="utf-8"))
            if cached.get("last_n") == last_n and cached.get("source_dir") == log_dir and cached.get("since") == since_arg and cached.get("until") == until_arg:
                runs = cached.get("runs", [])
                overall = cached.get("totals", overall)
                reason_counts = {r["reason"]: r["count"] for r in cached.get("reasons", [])}
                cache_hit = True
    except Exception:
        cache_hit = False

if not cache_hit:
    for fp in files:
        rc={k:0 for k in order}
        with open(fp,'r',encoding='utf-8',errors='ignore') as f:
            for line in f:
                line=line.strip()
                if not line.startswith('monitor='):
                    continue
                st=get_kv(line,'status') or 'UNKNOWN'
                if st not in rc:
                    st='UNKNOWN'
                rc[st]+=1
                overall[st]=overall.get(st,0)+1
                if st!='OK':
                    reason=get_kv(line,'reason')
                    if reason:
                        reason_counts[reason]=reason_counts.get(reason,0)+1
        runs.append({'file': fp, 'totals': rc})

rollup=sorted(reason_counts.items(), key=lambda kv: (-kv[1], kv[0]))
if json_mode:
    out={'trend_json_contract_version': 1, 'runs':runs, 'totals':overall, 'reasons':[{'reason':r,'count':c} for r,c in rollup]}
    if redact_json or redact_json_strict:
        out = redact_json_obj(out)
    print(json.dumps(out, indent=2, sort_keys=True))
elif csv_mode:
    print("file,CRIT,WARN,UNKNOWN,SKIP,OK")
    for r in runs:
        row = [os.path.basename(r["file"]), str(r["totals"].get("CRIT",0)), str(r["totals"].get("WARN",0)), str(r["totals"].get("UNKNOWN",0)), str(r["totals"].get("SKIP",0)), str(r["totals"].get("OK",0))]
        print(",".join(row))
else:
    print(header("=== linux-maint trend ==="))
    print(f'trend_runs={len(runs)} source_dir={log_dir}')
    print(c('totals:', "1;36") + ' ' + ' '.join(color_kv(k, overall.get(k,0)) for k in order))
    print('')
    print(c('runs:', "1;36"))
    for r in runs:
      print(f"- {os.path.basename(r['file'])}: " + ' '.join(color_kv(k, r['totals'].get(k,0)) for k in order))
    print('')
    print(c('reasons:', "1;36"))
    if rollup:
      for reason, count in rollup[:20]:
          print(f"{reason}={count}")
    else:
      print('none')

if cache_enabled and cache_file and not cache_hit:
    try:
        payload = {
            "last_n": last_n,
            "since": since_arg,
            "until": until_arg,
            "source_dir": log_dir,
            "created_epoch": int(time.time()),
            "runs": runs,
            "totals": overall,
            "reasons": [{"reason": r, "count": c} for r,c in rollup],
        }
        with open(cache_file, "w", encoding="utf-8") as f:
            json.dump(payload, f, indent=2, sort_keys=True)
    except Exception:
        pass
PY
    ;;

  runtimes)
    if [[ "$MODE" == "installed" ]]; then
      need_root_for runtimes
    fi

    RT_JSON=0
    RT_LAST=1
    RT_COLOR=1
    while [[ $# -gt 0 ]]; do
      case "$1" in
        --json) RT_JSON=1; shift ;;
        --last) RT_LAST="$2"; shift 2 ;;
        -h|--help)
          command_usage runtimes
          exit 0;;
        *) echo "Unknown runtimes flag: $1" >&2; exit 2;;
      esac
    done
    [[ -n "${NO_COLOR:-}" || -n "${LM_NO_COLOR:-}" ]] && RT_COLOR=0
    color_enabled || RT_COLOR=0

    if [[ ! "$RT_LAST" =~ ^[0-9]+$ ]] || [[ "$RT_LAST" -lt 1 ]]; then
      echo "ERROR: invalid --last '$RT_LAST' (use positive integer)" >&2
      exit 2
    fi

    if [[ "$MODE" == "repo" ]]; then
      log_dir="${LOG_DIR:-$REPO_LOG_DIR}"
    else
      log_dir="${LOG_DIR:-/var/log/health}"
    fi

    # Gather last N wrapper logs
    mapfile -t rt_files < <(find "$log_dir" -maxdepth 1 -type f -name 'full_health_monitor_[0-9][0-9][0-9][0-9]-[0-9][0-9]-[0-9][0-9]_[0-9][0-9][0-9][0-9][0-9][0-9].log' -printf '%T@ %p\n' 2>/dev/null | sort -nr | head -n "$RT_LAST" | awk '{print $2}')

    if [[ "${#rt_files[@]}" -eq 0 ]]; then
      echo "No wrapper logs found in $log_dir" >&2
      exit 1
    fi

    if [[ "$RT_JSON" -eq 1 ]]; then
      python3 - "$RT_LAST" "${rt_files[@]}" <<'PY'
import json, sys, re

rt_last = int(sys.argv[1])
files = sys.argv[2:]
rows = []
pat = re.compile(r'RUNTIME\s+monitor=([^ ]+)\s+ms=([0-9]+)')

for f in files:
    try:
        with open(f, 'r', encoding='utf-8', errors='ignore') as fh:
            for line in fh:
                m = pat.search(line)
                if m:
                    rows.append({"monitor": m.group(1), "ms": int(m.group(2)), "unit": "ms", "source_file": f})
    except FileNotFoundError:
        continue

# Sort desc by ms
rows.sort(key=lambda r: (-r["ms"], r["monitor"]))

print(json.dumps({"files": files, "unit": "ms", "rows": rows}, sort_keys=True))
PY
      exit 0
    fi

    CFG_DIR="${LM_CFG_DIR:-/etc/linux_maint}"
    MONITOR_RUNTIME_WARN_FILE="${MONITOR_RUNTIME_WARN_FILE:-$CFG_DIR/monitor_runtime_warn.conf}"

    echo "=== linux-maint runtimes ==="
    echo "files=${#rt_files[@]}"
    echo "log_dir=$log_dir"
    awk '
      /RUNTIME monitor=/ {
        for (i=1; i<=NF; i++) {
          if ($i ~ /^monitor=/) { split($i,a,"="); mon=a[2]; }
          if ($i ~ /^ms=/) { split($i,b,"="); ms=b[2]; }
        }
        if (mon != "" && ms != "") {
          print ms, mon
        }
        mon=""; ms=""
      }
    ' "${rt_files[@]}" | sort -rn | awk -v color="$RT_COLOR" -v warn_file="$MONITOR_RUNTIME_WARN_FILE" -v yel="$C_YELLOW" -v reset="$C_RESET" '
      BEGIN {
        if (warn_file != "" && (getline line < warn_file) > 0) {
          do {
            gsub(/\r/, "", line)
            if (line ~ /^[[:space:]]*#/ || line ~ /^[[:space:]]*$/) continue
            split(line, a, "=")
            if (a[1] != "" && a[2] ~ /^[0-9]+$/ && a[2] > 0) {
              warn_ms[a[1]] = a[2] * 1000
            }
          } while ((getline line < warn_file) > 0)
          close(warn_file)
        }
      }
      {
        ms=$1; mon=$2
        line="monitor="mon" ms="ms
        if (color == 1 && (mon in warn_ms) && ms >= warn_ms[mon]) {
          line = yel line reset
        }
        print line
      }
    '
    ;;

  export)
    if [[ "$MODE" == "installed" ]]; then
      need_root_for export
    fi

    EXPORT_JSON=0
    EXPORT_CSV=0
    case "${1:-}" in
      --json) EXPORT_JSON=1; shift ;;
      --csv) EXPORT_CSV=1; shift ;;
      -h|--help) EXPORT_JSON=0 ;;
      "") ;;
      *) echo "Unknown export flag: $1" >&2; exit 2 ;;
    esac

    if [[ "$EXPORT_JSON" -eq 0 && "$EXPORT_CSV" -eq 0 ]]; then
      echo "Usage: linux-maint export --json|--csv" >&2
      exit 2
    fi
    if [[ "$EXPORT_JSON" -eq 1 && "$EXPORT_CSV" -eq 1 ]]; then
      echo "ERROR: choose only one export format (--json or --csv)" >&2
      exit 2
    fi

    if [[ "$MODE" == "repo" ]]; then
      summary_file="$REPO_SUMMARY_LATEST"
      status_file="$REPO_STATUS_FILE"
      log_file="$REPO_LATEST_LOG"
      summary_json="$REPO_LOG_DIR/full_health_monitor_summary_latest.json"
    else
      summary_file="$INST_SUMMARY_LATEST"
      status_file="/var/log/health/last_status_full"
      log_file="/var/log/health/full_health_monitor_latest.log"
      summary_json="/var/log/health/full_health_monitor_summary_latest.json"
    fi

    python3 - "$MODE" "$EXPORT_CSV" "$status_file" "$summary_file" "$summary_json" "$log_file" <<'PY'
import json, os, re, sys

mode = sys.argv[1]
csv_mode = sys.argv[2] == "1"
status_path, summary_path, summary_json_path, log_path = sys.argv[3:7]
redact_json = os.environ.get("LM_REDACT_JSON","0") in ("1","true","TRUE","yes","YES")
redact_json_strict = os.environ.get("LM_REDACT_JSON_STRICT","0") in ("1","true","TRUE","yes","YES")

def read_kv(path):
    d={}
    if not path or not os.path.exists(path):
        return d
    with open(path,'r',encoding='utf-8',errors='ignore') as f:
        for line in f:
            line=line.strip()
            if not line or '=' not in line:
                continue
            k,v=line.split('=',1)
            d[k]=v
    return d

def parse_kv_line(line):
    d={}
    for p in line.strip().split():
        if '=' in p:
            k,v=p.split('=',1)
            d[k]=v
    return d

def redact_value(val: str) -> str:
    lower = val.lower()
    secret_keys = (
        "password","passwd","token","api_key","apikey","secret",
        "access_key","private_key","session","session_id","id_token",
        "refresh_token","x_auth_token"
    )
    if any(k in lower for k in secret_keys):
        return "REDACTED"
    if val.count(".") == 2 and all(len(p) >= 12 for p in val.split(".")):
        return "REDACTED_JWT"
    if re.match(r'^(gh[pousr]_[A-Za-z0-9]{20,}|github_pat_[A-Za-z0-9_]{20,}|xox[baprs]-[A-Za-z0-9-]{10,})$', val):
        return "REDACTED"
    if re.match(r'^AIza[0-9A-Za-z_-]{35}$', val):
        return "GCP_REDACTED"
    if re.match(r'^ya29\.[A-Za-z0-9_-]{10,}$', val):
        return "OAUTH_REDACTED"
    return val

def redact_kv_map(row):
    out = {}
    for k,v in row.items():
        if redact_json_strict:
            out[k] = "REDACTED"
            continue
        kl = k.lower()
        if any(x in kl for x in ("password","passwd","token","api_key","apikey","secret","access_key","private_key","session","id_token","refresh_token","x_auth_token")):
            out[k] = "REDACTED"
        else:
            out[k] = redact_value(v)
    return out

def read_rows():
    if summary_json_path and os.path.exists(summary_json_path):
        try:
            with open(summary_json_path,'r',encoding='utf-8',errors='ignore') as f:
                payload=json.load(f)
            if isinstance(payload, dict) and 'rows' in payload:
                return payload.get('rows',[]), payload.get('meta',{})
            if isinstance(payload, list):
                return payload, {}
        except Exception:
            pass
    rows=[]
    if summary_path and os.path.exists(summary_path):
        with open(summary_path,'r',encoding='utf-8',errors='ignore') as f:
            for line in f:
                if line.startswith('monitor='):
                    rows.append(parse_kv_line(line))
    return rows, {}

def parse_allowlist():
    raw=os.environ.get("LM_EXPORT_ALLOWLIST","").strip()
    if not raw:
        return None
    parts=[p for p in re.split(r'[,\s]+', raw) if p]
    if not parts:
        return None
    allow=set(parts)
    # Always keep core identity fields in rows.
    allow.update(["monitor","host","status","reason"])
    return allow

def filter_map(d, allow):
    if not d:
        return d
    return {k:v for k,v in d.items() if k in allow}

def parse_log_summary(log_path):
    summary_result=None
    summary_hosts=None
    if not log_path or not os.path.exists(log_path):
        return summary_result, summary_hosts
    with open(log_path,'r',encoding='utf-8',errors='ignore') as f:
        for line in f:
            if 'SUMMARY_RESULT' in line:
                m=re.search(r'SUMMARY_RESULT\\s+(.*)$', line)
                if m:
                    summary_result=parse_kv_line(m.group(1))
            elif 'SUMMARY_HOSTS' in line:
                m=re.search(r'SUMMARY_HOSTS\\s+(.*)$', line)
                if m:
                    summary_hosts=parse_kv_line(m.group(1))
    return summary_result, summary_hosts

def worst_status(rows):
    order={'OK':0,'WARN':1,'CRIT':2,'UNKNOWN':3,'SKIP':3}
    worst='OK'
    for r in rows:
        st=r.get('status','UNKNOWN')
        if order.get(st,3) >= order.get(worst,0):
            worst=st
    return worst

def derive_hosts(rows):
    counts={'ok':0,'warn':0,'crit':0,'unknown':0,'skipped':0}
    for r in rows:
        st=(r.get('status') or 'UNKNOWN').upper()
        if st == 'OK':
            counts['ok']+=1
        elif st == 'WARN':
            counts['warn']+=1
        elif st == 'CRIT':
            counts['crit']+=1
        elif st == 'SKIP':
            counts['skipped']+=1
        else:
            counts['unknown']+=1
    return counts

rows, meta = read_rows()
if os.environ.get("LM_REDACT_LOGS","0") in ("1","true","TRUE","yes","YES") or redact_json or redact_json_strict:
    rows = [redact_kv_map(r) for r in rows]
    if meta:
        meta = redact_kv_map(meta)

allow = parse_allowlist()
if allow:
    rows = [filter_map(r, allow) for r in rows]
    if meta:
        meta = filter_map(meta, allow)
summary_result, summary_hosts = parse_log_summary(log_path)

summary_result_source = 'log' if summary_result else 'derived'
summary_hosts_source = 'log' if summary_hosts else 'derived'

if not summary_result:
    summary_result={'overall': worst_status(rows), 'derived': True}
if not summary_hosts:
    summary_hosts=derive_hosts(rows)
    summary_hosts['derived'] = True

last_status = read_kv(status_path)
if allow:
    last_status = filter_map(last_status, allow)
if redact_json or redact_json_strict:
    last_status = redact_kv_map(last_status)

if csv_mode:
    import csv
    writer = csv.writer(sys.stdout)
    writer.writerow(["monitor","host","status","reason"])
    for r in rows:
        writer.writerow([
            r.get("monitor",""),
            r.get("host",""),
            r.get("status",""),
            r.get("reason",""),
        ])
else:
    out={
        'mode': mode,
        'summary_file': summary_path if summary_path and os.path.exists(summary_path) else None,
        'summary_log': log_path if log_path and os.path.exists(log_path) else None,
        'summary_json': summary_json_path if summary_json_path and os.path.exists(summary_json_path) else None,
        'summary_result_source': summary_result_source,
        'summary_hosts_source': summary_hosts_source,
        'summary_result': summary_result,
        'summary_hosts': summary_hosts,
        'last_status': last_status,
        'rows': rows,
    }
    if meta:
        out['meta']=meta

    print(json.dumps(out, indent=2, sort_keys=True))
PY
    ;;

  install)
    exec sudo ./install.sh "$@"
    ;;

  uninstall)
    exec sudo ./install.sh --uninstall "$@"
    ;;

  make-tarball)
    exec ./tools/make_tarball.sh "$@"
    ;;

  verify-release)
    exec ./tools/verify_release.sh "$@"
    ;;

  init)
    if [[ "$MODE" == "installed" ]]; then
      need_root_for init
    fi

    INIT_MINIMAL=0
    INIT_FORCE=0
    while [[ $# -gt 0 ]]; do
      case "$1" in
        --minimal) INIT_MINIMAL=1; shift ;;
        --force) INIT_FORCE=1; shift ;;
        *) echo "Unknown init flag: $1" >&2; exit 2 ;;
      esac
    done

    CFG_DIR="${LM_CFG_DIR:-/etc/linux_maint}"
    # Prefer repo templates in repo mode; in installed mode use PREFIX share templates.
    SRC_DIR="$REPO_ROOT/etc/linux_maint"
    if [[ "$MODE" == "installed" ]]; then
      ALT="$SHARE/templates/linux_maint"
      [[ -d "$ALT" ]] && SRC_DIR="$ALT"
    fi
    if [[ -z "$SRC_DIR" || ! -d "$SRC_DIR" ]]; then
      echo "ERROR: templates not found at $SRC_DIR" >&2
      echo "Run init from a git checkout:" >&2
      echo "  git clone https://github.com/ShenhavHezi/Linux_Maint_ToolKit.git" >&2
      echo "  cd Linux_Maint_ToolKit" >&2
      echo "  sudo ./bin/linux-maint init" >&2
      exit 1
    fi

    sudo mkdir -p "$CFG_DIR"
    if [[ "$INIT_MINIMAL" -eq 0 ]]; then
      sudo mkdir -p "$CFG_DIR/baselines" "$CFG_DIR/baselines/ports" "$CFG_DIR/baselines/configs" "$CFG_DIR/baselines/users" "$CFG_DIR/baselines/sudoers"
    fi

    if [[ "$INIT_MINIMAL" -eq 1 ]]; then
      init_templates=(
        "$SRC_DIR/servers.txt.example"
        "$SRC_DIR/excluded.txt.example"
        "$SRC_DIR/services.txt.example"
      )
    else
      shopt -s nullglob
      init_templates=("$SRC_DIR"/*.example)
    fi

    for f in "${init_templates[@]}"; do
      [[ -f "$f" ]] || continue
      base="$(basename "$f" .example)"
      dest="$CFG_DIR/$base"
      existed=0
      [[ -e "$dest" ]] && existed=1
      if [[ "$existed" -eq 1 && "$INIT_FORCE" -eq 0 ]]; then
        echo "keep:   $dest (exists)"
        continue
      fi
      if [[ "${LM_INIT_USE_CP:-0}" == "1" ]]; then
        # Some environments emit noisy SELinux warnings when using install(1).
        if [[ "$INIT_FORCE" -eq 1 ]]; then
          sudo cp -f "$f" "$dest"
        else
          sudo cp "$f" "$dest"
        fi
        sudo chmod 0644 "$dest"
      else
        sudo install -m 0644 "$f" "$dest"
      fi
      if [[ "$existed" -eq 1 && "$INIT_FORCE" -eq 1 ]]; then
        echo "overwrite: $dest"
      else
        echo "create: $dest"
      fi
    done

    echo ""
    echo "Next steps:"
    echo "  - Edit $CFG_DIR/servers.txt"
    echo "  - Run: sudo linux-maint doctor"
    if [[ "$INIT_MINIMAL" -eq 1 ]]; then
      echo "  - Optional later: run 'sudo linux-maint init' to install full optional templates"
    fi
    ;;

  tune)
    sub="${1:-}"; shift || true
    case "$sub" in
      dark-site)
        CFG_DIR="${LM_CFG_DIR:-/etc/linux_maint}"
        CONF="$CFG_DIR/linux-maint.conf"

        if [[ "$MODE" == "installed" ]]; then
          need_root_for tune
        fi

        if [[ ! -d "$CFG_DIR" ]]; then
          mkdir -p "$CFG_DIR" 2>/dev/null || { echo "ERROR: cannot create $CFG_DIR (try sudo)" >&2; exit 1; }
        fi
        if [[ ! -w "$CFG_DIR" ]]; then
          echo "ERROR: cannot write to $CFG_DIR (try sudo)" >&2
          exit 1
        fi

        SRC_DIR="$REPO_ROOT/etc/linux_maint"
        if [[ "$MODE" == "installed" ]]; then
          ALT="$SHARE/templates/linux_maint"
          [[ -d "$ALT" ]] && SRC_DIR="$ALT"
        fi
        tmpl="$SRC_DIR/linux-maint.conf.example"
        if [[ ! -f "$CONF" ]]; then
          if [[ -f "$tmpl" ]]; then
            cp -f "$tmpl" "$CONF"
          else
            cat > "$CONF" <<'EOF'
# linux-maint.conf - main configuration (KEY=VALUE)
# Generated by linux-maint tune dark-site
EOF
          fi
          echo "create: $CONF"
        fi

        python3 - "$CONF" <<'PY'
import os, re, sys, tempfile

conf_path = sys.argv[1]
settings = [
    ("LM_DARK_SITE", "true"),
    ("LM_LOCAL_ONLY", "true"),
    ("LM_NOTIFY_ONLY_ON_CHANGE", "1"),
    ("MONITOR_TIMEOUT_SECS", "300"),
    ("LM_LAST_RUN_MAX_AGE_MIN", "1800"),
    ("LM_LAST_RUN_LOG_DIR", "\"/var/log/health\""),
    ("LM_FS_RO_EXCLUDE_RE", "'^(proc|sysfs|devtmpfs|tmpfs|devpts|cgroup2?|cgroup|debugfs|tracefs|mqueue|hugetlbfs|pstore|squashfs|overlay|rpc_pipefs|autofs|fuse\\\\..*|binfmt_misc|iso9660)$'"),
]

with open(conf_path, "r", encoding="utf-8") as f:
    lines = f.readlines()

found = {k: False for k, _ in settings}
replaced = {k: False for k, _ in settings}
actions = []

for i, line in enumerate(lines):
    for key, val in settings:
        if found[key]:
            continue
        if re.match(r"\\s*#?\\s*%s\\s*=" % re.escape(key), line):
            if line.lstrip().startswith("#"):
                lines[i] = f"{key}={val}\n"
                replaced[key] = True
                actions.append(f"set: {key}={val} (was commented)")
            else:
                found[key] = True
                actions.append(f"keep: {key} (already set)")
            break

for key, val in settings:
    if found[key] or replaced[key]:
        continue
    lines.append(f"{key}={val}\n")
    actions.append(f"add: {key}={val}")

fd, tmp_path = tempfile.mkstemp(prefix="linux_maint_conf.", dir=os.path.dirname(conf_path))
with os.fdopen(fd, "w", encoding="utf-8") as f:
    f.writelines(lines)
os.replace(tmp_path, conf_path)

for a in actions:
    print(a)
PY
        ;;
      *)
        echo "Usage: linux-maint tune dark-site" >&2
        exit 2
        ;;
    esac
    ;;

  baseline)
    if [[ "$MODE" == "installed" ]]; then
      need_root_for baseline
    fi

    target="${1:-}"; shift || true
    BASELINE_UPDATE=0
    BASELINE_LOCAL=0
    BASELINE_DIFF=0
    BASELINE_SHOW=0
    BASELINE_PROGRESS_SET=0
    BASELINE_PROGRESS=0
    while [[ $# -gt 0 ]]; do
      case "$1" in
        --update) BASELINE_UPDATE=1; shift 1;;
        --local-only) BASELINE_LOCAL=1; shift 1;;
        --diff) BASELINE_DIFF=1; shift 1;;
        --show) BASELINE_SHOW=1; shift 1;;
        --progress) BASELINE_PROGRESS=1; BASELINE_PROGRESS_SET=1; shift 1;;
        --no-progress) BASELINE_PROGRESS=0; BASELINE_PROGRESS_SET=1; shift 1;;
        -h|--help)
          command_usage baseline
          exit 0;;
        *) echo "Unknown baseline flag: $1" >&2; exit 2;;
      esac
    done

    if [[ -z "$target" ]]; then
      command_usage baseline >&2
      exit 2
    fi

    if [[ "$BASELINE_DIFF" -eq 1 && "$BASELINE_SHOW" -eq 1 ]]; then
      echo "ERROR: use only one of --diff or --show" >&2
      exit 2
    fi
    if [[ "$BASELINE_UPDATE" -eq 1 && ( "$BASELINE_DIFF" -eq 1 || "$BASELINE_SHOW" -eq 1 ) ]]; then
      echo "ERROR: --update cannot be combined with --diff or --show" >&2
      exit 2
    fi

    if [[ "$MODE" == "repo" ]]; then
      scripts_dir="$REPO_MONITORS"
    else
      scripts_dir="$LIBEXEC"
    fi

    case "$target" in
      ports)
        script="$scripts_dir/ports_baseline_monitor.sh"
        export LM_BASELINE_TARGET="ports"
        ;;
      configs|config)
        script="$scripts_dir/config_drift_monitor.sh"
        export LM_BASELINE_TARGET="configs"
        ;;
      users)
        script="$scripts_dir/user_monitor.sh"
        export LM_BASELINE_TARGET="users"
        ;;
      sudoers)
        script="$scripts_dir/user_monitor.sh"
        export LM_BASELINE_TARGET="sudoers"
        ;;
      *)
        echo "Unknown baseline target: $target" >&2
        exit 2
        ;;
    esac

    if [[ ! -x "$script" ]]; then
      echo "ERROR: baseline helper not found: $script" >&2
      exit 1
    fi

    export LM_BASELINE_ONLY=1
    if [[ "$BASELINE_UPDATE" -eq 1 ]]; then
      export BASELINE_UPDATE="true"
      export LM_HOST_PROGRESS=1
    fi
    if [[ "$BASELINE_LOCAL" -eq 1 ]]; then
      export LM_LOCAL_ONLY="true"
    fi
    if [[ "$BASELINE_DIFF" -eq 1 ]]; then
      export LM_BASELINE_DIFF=1
      export LM_BASELINE_ONLY=0
    fi
    if [[ "$BASELINE_SHOW" -eq 1 ]]; then
      export LM_BASELINE_SHOW=1
      export LM_BASELINE_ONLY=0
    fi

    if [[ "$BASELINE_PROGRESS_SET" -eq 1 ]]; then
      if [[ "$BASELINE_PROGRESS" -eq 1 ]]; then
        export LM_PROGRESS=1
        export LM_HOST_PROGRESS=1
      else
        export LM_PROGRESS=0
        export LM_HOST_PROGRESS=0
      fi
    fi

    exec bash "$script"
    ;;

  explain)
    sub="${1:-}"; shift || true
    case "$sub" in
      reason)
        token="${1:-}"
        if [[ -z "$token" ]]; then
          echo "Usage: linux-maint explain reason <token>" >&2
          exit 2
        fi
        f="$REPO_ROOT/docs/REASONS.md"
        if [[ ! -f "$f" ]]; then
          # installed mode: docs may be under share
          for alt in \
            "$SHARE/docs/REASONS.md" \
            "$PREFIX/share/Linux_Maint_ToolKit/docs/REASONS.md" \
            "$PREFIX/share/linux-maint/docs/REASONS.md" \
            "/usr/share/Linux_Maint_ToolKit/docs/REASONS.md" \
            "/usr/share/linux-maint/docs/REASONS.md" \
            "/usr/share/linux_maint/docs/REASONS.md" \
          ; do
            if [[ -f "$alt" ]]; then f="$alt"; break; fi
          done
        fi
        if [[ ! -f "$f" ]]; then
          echo "ERROR: reasons doc not found: $f" >&2
          exit 1
        fi
        # Look for a bullet line that contains `- token â€” ...` under any section.
        # Print the matching line(s) plus the section header immediately above.
        if awk -v tok="$token" '
          BEGIN{sec=""; found=0}
          /^### /{sec=$0}
          $0 ~ "- `"tok"`" {
            if (sec!="") {print sec}
            print $0
            found=1
          }
          END{exit(found?0:1)}
        ' "$f"; then
          echo ""
          reason_next_steps "$token"
          exit 0
        fi

        # Fallback: substring search
        if grep -n -i -F "$token" "$f" >/dev/null 2>&1; then
          echo "No exact token match; showing closest lines:" >&2
          grep -n -i -F "$token" "$f" | head -n 20
          exit 0
        fi
        echo "Unknown reason token: $token" >&2
        exit 1
        ;;

      monitor)
        mon="${1:-}"
        if [[ -z "$mon" ]]; then
          echo "Usage: linux-maint explain monitor <name>" >&2
          exit 2
        fi
        # Normalize common aliases (allow both with/without _monitor suffix).
        case "$mon" in
          health) mon="health_monitor" ;;
          inode) mon="inode_monitor" ;;
          disk_trend) mon="disk_trend_monitor" ;;
          network) mon="network_monitor" ;;
          service) mon="service_monitor" ;;
          ntp) mon="ntp_drift_monitor" ;;
          patch) mon="patch_monitor" ;;
          storage) mon="storage_health_monitor" ;;
          kernel_events) mon="kernel_events_monitor" ;;
          cert) mon="cert_monitor" ;;
          nfs) mon="nfs_mount_monitor" ;;
          ports) mon="ports_baseline_monitor" ;;
          config_drift) mon="config_drift_monitor" ;;
          user) mon="user_monitor" ;;
          backup) mon="backup_check" ;;
          inventory) mon="inventory_export" ;;
          preflight) mon="preflight_check" ;;
          config_validate|validate) mon="config_validate" ;;
        esac

        req=""
        opt=""
        while IFS='|' read -r m r o; do
          [[ -z "$m" ]] && continue
          if [[ "$m" == "$mon" ]]; then
            req="$r"
            opt="$o"
            break
          fi
        done <<'EOF_DEPS'
preflight_check|awk sed grep df timeout ssh|curl openssl
config_validate|awk sed grep|none
health_monitor|awk sed grep ps df|none
inode_monitor|awk sed grep df|none
disk_trend_monitor|awk sed grep df|none
network_monitor|awk sed grep|curl
service_monitor|awk sed grep|systemctl
ntp_drift_monitor|awk sed grep|chronyc ntpq
patch_monitor|awk sed grep|apt yum dnf zypper
storage_health_monitor|awk sed grep|smartctl nvme
kernel_events_monitor|awk sed grep|journalctl dmesg
cert_monitor|awk sed grep|openssl
nfs_mount_monitor|awk sed grep|showmount
ports_baseline_monitor|awk sed grep|ss netstat
config_drift_monitor|awk sed grep|sha256sum md5sum
user_monitor|awk sed grep|id getent
backup_check|awk sed grep|none
inventory_export|awk sed grep hostname|ip lsblk lscpu
EOF_DEPS

        if [[ -z "$req" && -z "$opt" ]]; then
          echo "Unknown monitor: $mon" >&2
          exit 2
        fi

        purpose="General health check"
        reasons="missing_dependency permission_denied"
        case "$mon" in
          preflight_check)
            purpose="Preflight readiness (deps/SSH/config)"
            reasons="missing_dependency missing_optional_cmd ssh_unreachable"
            ;;
          config_validate)
            purpose="Validate /etc/linux_maint config formats"
            reasons="config_invalid config_missing"
            ;;
          health_monitor)
            purpose="CPU/mem/load/disk snapshot"
            reasons="high_load high_mem disk_full"
            ;;
          inode_monitor)
            purpose="Inode utilization thresholds"
            reasons="inode_high"
            ;;
          disk_trend_monitor)
            purpose="Disk growth trend tracking"
            reasons="disk_growth disk_full"
            ;;
          network_monitor)
            purpose="Ping/TCP/HTTP reachability checks"
            reasons="ping_failed tcp_failed http_failed"
            ;;
          service_monitor)
            purpose="Systemd service health"
            reasons="service_inactive service_failed"
            ;;
          ntp_drift_monitor)
            purpose="Time sync health and drift"
            reasons="ntp_not_synced ntp_drift_high"
            ;;
          patch_monitor)
            purpose="Pending updates and reboot hints"
            reasons="security_updates_pending updates_pending reboot_required"
            ;;
          storage_health_monitor)
            purpose="RAID/SMART/NVMe health"
            reasons="raid_degraded smart_failed missing_dependency"
            ;;
          kernel_events_monitor)
            purpose="Kernel log scan (OOM/I/O/FS/hung tasks)"
            reasons="permission_denied missing_dependency"
            ;;
          cert_monitor)
            purpose="TLS certificate expiry/validity"
            reasons="cert_expiring cert_invalid"
            ;;
          nfs_mount_monitor)
            purpose="NFS mounted + responsive"
            reasons="timeout ssh_unreachable"
            ;;
          ports_baseline_monitor)
            purpose="Listening ports drift vs baseline"
            reasons="baseline_missing baseline_exists baseline_updated"
            ;;
          config_drift_monitor)
            purpose="Config drift vs baseline"
            reasons="config_missing baseline_missing"
            ;;
          user_monitor)
            purpose="User/sudoers drift + SSH failures"
            reasons="unexpected_user unexpected_sudoers_change failed_ssh_logins"
            ;;
          backup_check)
            purpose="Backup freshness/integrity"
            reasons="missing_dependency permission_denied"
            ;;
          inventory_export)
            purpose="HW/SW inventory export"
            reasons="missing_dependency permission_denied"
            ;;
        esac

        echo "monitor=$mon"
        echo "purpose=$purpose"
        echo "required_deps=${req:-none}"
        echo "optional_deps=${opt:-none}"
        echo "common_reasons=$reasons"
        echo "see=docs/REASONS.md"
        ;;

      status)
        st="${1:-}"
        if [[ -z "$st" ]]; then
          echo "Usage: linux-maint explain status <OK|WARN|CRIT|UNKNOWN|SKIP>" >&2
          exit 2
        fi
        case "$st" in
          OK) echo "OK: check succeeded; no action required." ;;
          WARN) echo "WARN: potential issue; attention suggested." ;;
          CRIT) echo "CRIT: actionable failure; immediate attention required." ;;
          UNKNOWN) echo "UNKNOWN: check could not be completed reliably (missing tool/permission/unexpected error)." ;;
          SKIP) echo "SKIP: check intentionally did not run (missing optional config/baseline/unsupported environment)." ;;
          *) echo "Unknown status: $st" >&2; exit 2 ;;
        esac
        ;;

      *)
        echo "Usage: linux-maint explain <reason|status|monitor> ..." >&2
        exit 2
        ;;
    esac
    ;;


  pack-logs)
    OUT=""
    PACK_PROGRESS_SET=0
    PACK_PROGRESS=0
    PACK_REDACT_SET=0
    PACK_REDACT=0
    PACK_HASH=0
    while [[ $# -gt 0 ]]; do
      case "$1" in
        --out) OUT="${2:-}"; shift 2;;
        --progress) PACK_PROGRESS=1; PACK_PROGRESS_SET=1; shift 1;;
        --no-progress) PACK_PROGRESS=0; PACK_PROGRESS_SET=1; shift 1;;
        --redact) PACK_REDACT=1; PACK_REDACT_SET=1; shift 1;;
        --no-redact) PACK_REDACT=0; PACK_REDACT_SET=1; shift 1;;
        --hash) PACK_HASH=1; shift 1;;
        -h|--help)
          command_usage pack-logs
          exit 0;;
        *) echo "Unknown pack-logs flag: $1" >&2; exit 2;;
      esac
    done

    # Default output directory:
    # - repo mode: repo root
    # - installed: current directory
    if [[ -z "$OUT" ]]; then
      if [[ "$MODE" == "repo" ]]; then
        OUT="$REPO_ROOT"
      else
        OUT="."
      fi
    fi

    # Determine log dir for mode
    if [[ "$MODE" == "repo" ]]; then
      _logdir="$REPO_LOG_DIR"
      _repo_root="$REPO_ROOT"
    else
      _logdir="${LOG_DIR:-/var/log/health}"
      _repo_root=""
    fi

    # Use best-effort state dir (where notify/summary diff stores state)
    _state_dir="${LM_NOTIFY_STATE_DIR:-${LM_STATE_DIR:-/var/lib/linux_maint}}"

    if [[ "$MODE" == "repo" ]]; then
      pack_logs_bin="$REPO_ROOT/tools/pack_logs.sh"
    else
      pack_logs_bin="$LIBEXEC/pack_logs.sh"
    fi
    if [[ ! -x "$pack_logs_bin" ]]; then
      echo "ERROR: pack-logs helper not found: $pack_logs_bin" >&2
      hint_line "reinstall or run from a git checkout." >&2
      exit 1
    fi
    if [[ "$PACK_PROGRESS_SET" -eq 1 ]]; then
      if [[ "$PACK_PROGRESS" -eq 1 ]]; then
        export LM_PROGRESS=1
      else
        export LM_PROGRESS=0
      fi
    fi

    if [[ "$PACK_REDACT_SET" -eq 1 ]]; then
      if [[ "$PACK_REDACT" -eq 1 ]]; then
        export LM_REDACT_LOGS=1
      else
        export LM_REDACT_LOGS=0
      fi
    fi

    if [[ "$PACK_HASH" -eq 1 ]]; then
      export LM_PACK_LOGS_HASH=1
    fi

    OUTDIR="$OUT" LOG_DIR="$_logdir" CFG_DIR="${LM_CFG_DIR:-/etc/linux_maint}" STATE_DIR="$_state_dir" REPO_ROOT="$_repo_root" \
      "$pack_logs_bin"
    ;;
  verify-install)
    section "linux-maint verify-install"
    echo "mode=$MODE"
    echo "prefix=$PREFIX"
    echo "wrapper=$wrapper"
    echo "lib=${LINUX_MAINT_LIB:-/usr/local/lib/linux_maint.sh}"

    fail=0

    check_file() {
      local label="$1" path="$2"
      if [[ -e "$path" ]]; then
        echo "${C_GREEN}OK${C_RESET}: $label: $path"
      else
        echo "${C_RED}MISSING${C_RESET}: $label: $path" >&2
        fail=1
      fi
    }

    check_exec() {
      local label="$1" path="$2"
      if [[ -x "$path" ]]; then
        echo "${C_GREEN}OK${C_RESET}: $label: $path"
      elif [[ -e "$path" ]]; then
        echo "${C_RED}NOT EXECUTABLE${C_RESET}: $label: $path" >&2
        fail=1
      else
        echo "${C_RED}MISSING${C_RESET}: $label: $path" >&2
        fail=1
      fi
    }

    check_writable_dir() {
      local label="$1" path="$2"
      if [[ -d "$path" ]]; then
        if ( : > "$path/.linux_maint_write_test" ) 2>/dev/null; then
          rm -f "$path/.linux_maint_write_test" 2>/dev/null || true
          echo "${C_GREEN}OK${C_RESET}: writable $label: $path"
        else
          echo "${C_YELLOW}WARN${C_RESET}: not writable $label: $path" >&2
        fi
      else
        echo "${C_YELLOW}WARN${C_RESET}: missing dir $label: $path" >&2
      fi
    }

    # Core files
    check_exec "wrapper" "$wrapper"
    check_file "library" "${LINUX_MAINT_LIB:-/usr/local/lib/linux_maint.sh}"

    if [[ "$MODE" == "repo" ]]; then
      check_file "monitors dir" "$REPO_MONITORS"
      check_file "tools dir" "$REPO_ROOT/tools"
    else
      check_file "libexec" "$LIBEXEC"
    fi

    echo "== Config =="
    CFG_DIR="${LM_CFG_DIR:-/etc/linux_maint}"
    echo "cfg_dir=$CFG_DIR"
    if [[ -d "$CFG_DIR" ]]; then
      check_file "servers" "$CFG_DIR/servers.txt"
      check_file "excluded" "$CFG_DIR/excluded.txt"
      check_file "services" "$CFG_DIR/services.txt"
    else
      echo "WARN: config dir missing: $CFG_DIR" >&2
    fi

    echo "== Writable locations =="
    check_writable_dir "lockdir" "${LM_LOCKDIR:-/var/lock}"
    check_writable_dir "state" "${LM_STATE_DIR:-/var/lib/linux_maint}"
    check_writable_dir "logs" "${LOG_DIR:-/var/log/health}"

    echo "== Version =="
    "$0" version || true

    echo "== systemd (best-effort) =="
    if command -v systemctl >/dev/null 2>&1; then
      # If unit files exist, report basic state; do not fail if systemd is not running.
      svc="/usr/lib/systemd/system/linux-maint.service"
      tmr="/usr/lib/systemd/system/linux-maint.timer"
      if [[ -f "$svc" || -f "$tmr" ]]; then
        [[ -f "$svc" ]] && echo "OK: unit file: $svc" || echo "WARN: missing unit file: $svc" >&2
        [[ -f "$tmr" ]] && echo "OK: unit file: $tmr" || echo "WARN: missing unit file: $tmr" >&2
        systemctl is-enabled linux-maint.timer >/dev/null 2>&1 && echo "OK: timer enabled" || echo "INFO: timer not enabled (or systemd unavailable)"
        systemctl is-active linux-maint.timer >/dev/null 2>&1 && echo "OK: timer active" || echo "INFO: timer not active (or systemd unavailable)"
      else
        echo "INFO: systemd unit files not present (ok if not installed with --with-timer)"
      fi
    else
      echo "INFO: systemctl not found"
    fi

    if [[ "$fail" -ne 0 ]]; then
      echo "verify-install FAIL" >&2
      exit 1
    fi

    if [[ "$fail" -eq 0 ]]; then
      echo "${C_GREEN}verify-install ok${C_RESET}"
    else
      echo "${C_RED}verify-install failed${C_RESET}" >&2
      exit 1
    fi
    ;;
  doctor)
    if [[ "$MODE" == "installed" ]]; then
      need_root_for doctor
    fi

    DOCTOR_JSON=0
    DOCTOR_COMPACT=0
    DOCTOR_FIX=0
    DOCTOR_FIX_DEPS=0
    DOCTOR_FIX_OPTIONAL=0
    DOCTOR_YES=0
    DOCTOR_DRY_RUN=0
    while [[ $# -gt 0 ]]; do
      case "$1" in
        --json) DOCTOR_JSON=1; shift 1;;
        --compact) DOCTOR_COMPACT=1; shift 1;;
        --fix) DOCTOR_FIX=1; shift 1;;
        --fix-deps) DOCTOR_FIX=1; DOCTOR_FIX_DEPS=1; shift 1;;
        --fix-deps-optional) DOCTOR_FIX=1; DOCTOR_FIX_DEPS=1; DOCTOR_FIX_OPTIONAL=1; shift 1;;
        --yes) DOCTOR_YES=1; shift 1;;
        --dry-run) DOCTOR_DRY_RUN=1; shift 1;;
        -h|--help)
          command_usage doctor
          exit 0;;
        *) echo "Unknown doctor flag: $1" >&2; exit 2;;
      esac
    done

    CFG_DIR="${LM_CFG_DIR:-/etc/linux_maint}"

    if [[ "$DOCTOR_FIX" -eq 1 && "${EUID:-$(id -u)}" -ne 0 ]]; then
      echo "ERROR: doctor --fix requires root" >&2
      exit 1
    fi

    fix_actions_file=""
    if [[ "$DOCTOR_FIX" -eq 1 ]]; then
      if [[ "$DOCTOR_DRY_RUN" -eq 0 && "$DOCTOR_YES" -eq 0 ]]; then
        if [[ -t 1 ]]; then
          echo "About to apply fixes (dirs/perms${DOCTOR_FIX_DEPS:+, deps}). Proceed? [y/N]"
          read -r ans
          [[ "$ans" =~ ^[Yy]$ ]] || { echo "Aborted."; exit 1; }
        else
          echo "ERROR: doctor --fix requires --yes in non-interactive mode" >&2
          exit 1
        fi
      fi
      fix_actions=()
      fix_actions_file="$(mktemp -p "${TMPDIR:-/tmp}" linux_maint_fix_actions.XXXXXX)"
      record_fix_action() {
        local action="$1" target="$2" status="$3"
        [[ -n "$fix_actions_file" ]] || return 0
        printf '%s\t%s\t%s\n' "$action" "$target" "$status" >> "$fix_actions_file" 2>/dev/null || true
      }
      ensure_dir() {
        local d="$1"
        if [[ ! -d "$d" ]]; then
          if [[ "$DOCTOR_DRY_RUN" -eq 1 ]]; then
            fix_actions+=("would create: $d")
            record_fix_action "create_dir" "$d" "dry_run"
          else
            if install -d -m 0755 "$d" 2>/dev/null; then
              fix_actions+=("create: $d")
              record_fix_action "create_dir" "$d" "ok"
            else
              fix_actions+=("failed: $d")
              record_fix_action "create_dir" "$d" "failed"
            fi
          fi
        elif [[ ! -w "$d" ]]; then
          if [[ "$DOCTOR_DRY_RUN" -eq 1 ]]; then
            fix_actions+=("would chmod: $d")
            record_fix_action "chmod_dir" "$d" "dry_run"
          else
            if chmod 0755 "$d" 2>/dev/null; then
              fix_actions+=("chmod: $d")
              record_fix_action "chmod_dir" "$d" "ok"
            else
              fix_actions+=("failed: $d")
              record_fix_action "chmod_dir" "$d" "failed"
            fi
          fi
        fi
      }
      ensure_dir "/var/log/health"
      ensure_dir "/var/log/inventory"
      ensure_dir "/var/lib/linux_maint"
      ensure_dir "/var/lock"
      if [[ ! -d "$CFG_DIR" ]]; then
        if [[ "$DOCTOR_DRY_RUN" -eq 1 ]]; then
          fix_actions+=("would create: $CFG_DIR")
          record_fix_action "create_dir" "$CFG_DIR" "dry_run"
        else
          if install -d -m 0755 "$CFG_DIR" 2>/dev/null; then
            fix_actions+=("create: $CFG_DIR")
            record_fix_action "create_dir" "$CFG_DIR" "ok"
          else
            fix_actions+=("failed: $CFG_DIR")
            record_fix_action "create_dir" "$CFG_DIR" "failed"
          fi
        fi
      fi

      if [[ "$DOCTOR_FIX_DEPS" -eq 1 ]]; then
        missing_pkgs=()
        add_pkg() {
          local pkg="$1"
          [[ -z "$pkg" ]] && return 0
          for p in "${missing_pkgs[@]:-}"; do
            [[ "$p" == "$pkg" ]] && return 0
          done
          missing_pkgs+=("$pkg")
        }
        # required deps
        command -v awk >/dev/null 2>&1 || add_pkg "gawk"
        command -v sed >/dev/null 2>&1 || add_pkg "sed"
        command -v grep >/dev/null 2>&1 || add_pkg "grep"
        command -v df >/dev/null 2>&1 || add_pkg "coreutils"
        command -v find >/dev/null 2>&1 || add_pkg "findutils"
        command -v timeout >/dev/null 2>&1 || add_pkg "coreutils"
        command -v curl >/dev/null 2>&1 || add_pkg "curl"
        command -v openssl >/dev/null 2>&1 || add_pkg "openssl"
        command -v ssh >/dev/null 2>&1 || add_pkg "openssh-clients"
        command -v systemctl >/dev/null 2>&1 || add_pkg "systemd"

        if [[ "$DOCTOR_FIX_OPTIONAL" -eq 1 ]]; then
          command -v chronyc >/dev/null 2>&1 || add_pkg "chrony"
          command -v ntpq >/dev/null 2>&1 || add_pkg "ntp"
          command -v smartctl >/dev/null 2>&1 || add_pkg "smartmontools"
          command -v nvme >/dev/null 2>&1 || add_pkg "nvme-cli"
          command -v netstat >/dev/null 2>&1 || add_pkg "net-tools"
          command -v ss >/dev/null 2>&1 || add_pkg "iproute"
          command -v journalctl >/dev/null 2>&1 || add_pkg "systemd"
        fi

        if [[ "${#missing_pkgs[@]:-0}" -gt 0 ]]; then
          if [[ "$DOCTOR_DRY_RUN" -eq 1 ]]; then
            fix_actions+=("deps: would install ${missing_pkgs[*]}")
            record_fix_action "install_deps" "${missing_pkgs[*]}" "dry_run"
          elif command -v dnf >/dev/null 2>&1; then
            if dnf -y install "${missing_pkgs[@]}"; then
              fix_actions+=("deps: installed via dnf")
              record_fix_action "install_deps" "${missing_pkgs[*]}" "ok"
            else
              fix_actions+=("deps: install failed (dnf)")
              record_fix_action "install_deps" "${missing_pkgs[*]}" "failed"
            fi
          elif command -v yum >/dev/null 2>&1; then
            if yum -y install "${missing_pkgs[@]}"; then
              fix_actions+=("deps: installed via yum")
              record_fix_action "install_deps" "${missing_pkgs[*]}" "ok"
            else
              fix_actions+=("deps: install failed (yum)")
              record_fix_action "install_deps" "${missing_pkgs[*]}" "failed"
            fi
          elif command -v apt-get >/dev/null 2>&1; then
            apt-get update >/dev/null 2>&1 || true
            if apt-get -y install "${missing_pkgs[@]}"; then
              fix_actions+=("deps: installed via apt-get")
              record_fix_action "install_deps" "${missing_pkgs[*]}" "ok"
            else
              fix_actions+=("deps: install failed (apt-get)")
              record_fix_action "install_deps" "${missing_pkgs[*]}" "failed"
            fi
          elif command -v zypper >/dev/null 2>&1; then
            if zypper -n install "${missing_pkgs[@]}"; then
              fix_actions+=("deps: installed via zypper")
              record_fix_action "install_deps" "${missing_pkgs[*]}" "ok"
            else
              fix_actions+=("deps: install failed (zypper)")
              record_fix_action "install_deps" "${missing_pkgs[*]}" "failed"
            fi
          else
            fix_actions+=("deps: no supported package manager found")
            record_fix_action "install_deps" "${missing_pkgs[*]}" "failed"
          fi
        else
          fix_actions+=("deps: none missing")
          record_fix_action "install_deps" "none" "skipped"
        fi
      fi
    fi

    if [[ "$DOCTOR_JSON" -eq 1 ]]; then
      MODE="$MODE" PREFIX="$PREFIX" WRAPPER="$wrapper" LIBEXEC="$LIBEXEC" LINUX_MAINT_LIB="${LINUX_MAINT_LIB:-/usr/local/lib/linux_maint.sh}" CFG_DIR="$CFG_DIR" FIX_ACTIONS_FILE="$fix_actions_file" python3 - <<'PYJSON'
import json
import os
import pathlib
import shutil

mode = os.environ.get("MODE", "")
prefix = os.environ.get("PREFIX", "")
wrapper = os.environ.get("WRAPPER", "")
libexec = os.environ.get("LIBEXEC", "")
lib = os.environ.get("LINUX_MAINT_LIB", "")
cfg_dir = os.environ.get("CFG_DIR", "/etc/linux_maint")
fix_actions_file = os.environ.get("FIX_ACTIONS_FILE", "")

cfg_path = pathlib.Path(cfg_dir)


def has_cmd(cmd: str) -> bool:
    return shutil.which(cmd) is not None


def active_hosts_count(path: pathlib.Path) -> int:
    if not path.is_file():
        return 0
    count = 0
    for raw in path.read_text(errors="ignore").splitlines():
        line = raw.strip()
        if not line or line.startswith("#"):
            continue
        count += 1
    return count


config_files = ["servers.txt", "excluded.txt", "services.txt", "emails.txt"]
config = {
    "dir_exists": cfg_path.is_dir(),
    "files": {name: (cfg_path / name).exists() for name in config_files},
    "hosts_configured": active_hosts_count(cfg_path / "servers.txt"),
}

fix_suggestions = []
fix_seen = set()

def add_fix(msg: str) -> None:
    if msg in fix_seen:
        return
    fix_seen.add(msg)
    fix_suggestions.append(msg)

servers_path = cfg_path / "servers.txt"
services_path = cfg_path / "services.txt"
if not cfg_path.is_dir():
    add_fix("Initialize config templates: sudo linux-maint init")
else:
    if not servers_path.exists() or servers_path.stat().st_size == 0:
        add_fix(
            f"Create {cfg_dir}/servers.txt (example: printf '%s\\n' localhost | sudo tee {cfg_dir}/servers.txt)"
        )
    elif active_hosts_count(servers_path) == 0:
        add_fix(f"Add hosts to {cfg_dir}/servers.txt (one per line)")
    if services_path.exists() and services_path.stat().st_size == 0:
        add_fix(f"Populate {cfg_dir}/services.txt with critical services (one per line)")

gates = [
    ("cert_monitor", "certs.txt"),
    ("network_monitor", "network_targets.txt"),
    ("ports_baseline_monitor", "ports_baseline.txt"),
    ("config_drift_monitor", "config_paths.txt"),
    ("user_monitor", "baseline_users.txt"),
    ("user_monitor", "baseline_sudoers.txt"),
    ("backup_check", "backup_targets.csv"),
]
monitor_gates = []
for mon, fn in gates:
    p = cfg_path / fn
    monitor_gates.append(
        {
            "monitor": mon,
            "path": str(p),
            "present": p.exists() and p.stat().st_size > 0,
        }
    )
    if not (p.exists() and p.stat().st_size > 0):
        if fn == "certs.txt":
            add_fix(f"Add cert paths to {cfg_dir}/certs.txt")
        elif fn == "network_targets.txt":
            add_fix(f"Add network targets to {cfg_dir}/network_targets.txt")
        elif fn == "ports_baseline.txt":
            add_fix(f"Add baseline allowlist to {cfg_dir}/ports_baseline.txt")
        elif fn == "config_paths.txt":
            add_fix(f"Add config paths to {cfg_dir}/config_paths.txt")
        elif fn == "baseline_users.txt":
            add_fix(f"Generate baseline users list at {cfg_dir}/baseline_users.txt")
        elif fn == "baseline_sudoers.txt":
            add_fix(f"Generate baseline sudoers list at {cfg_dir}/baseline_sudoers.txt")
        elif fn == "backup_targets.csv":
            add_fix(f"Add backup targets to {cfg_dir}/backup_targets.csv")

dep_hints = [
    ("awk", "gawk"),
    ("sed", "sed"),
    ("grep", "grep"),
    ("df", "coreutils"),
    ("find", "findutils"),
    ("timeout", "coreutils"),
    ("curl", "curl"),
    ("openssl", "openssl"),
    ("ssh", "openssh-clients"),
    ("systemctl", "systemd"),
]
dependencies = []
for c, h in dep_hints:
    present = has_cmd(c)
    dependencies.append({"cmd": c, "present": present, "hint": h})
    if not present and h:
        add_fix(f"Install missing dependency: {h}")

writable_paths = ["/var/log/health", "/var/log/inventory", "/var/lib/linux_maint", "/var/lock"]
writable_locations = []
for d in writable_paths:
    p = pathlib.Path(d)
    exists = p.is_dir()
    writable = exists and os.access(d, os.W_OK)
    writable_locations.append({"path": d, "exists": exists, "writable": writable})
    if not exists:
        add_fix(f"Create missing dir: sudo install -d -m 0755 {d}")
    elif not writable:
        add_fix(f"Ensure {d} is writable (example: sudo install -d -m 0755 {d})")

result = {
    "mode": mode,
    "prefix": prefix,
    "wrapper": wrapper,
    "libexec": libexec,
    "lib": lib,
    "cfg_dir": cfg_dir,
    "config": config,
    "monitor_gates": monitor_gates,
    "dependencies": dependencies,
    "writable_locations": writable_locations,
    "fix_suggestions": fix_suggestions,
    "fix_actions": [],
    "next_actions": [
        "linux-maint verify-install",
        "sudo linux-maint init",
        "sudo linux-maint preflight",
        "sudo linux-maint run",
        "linux-maint pack-logs --out .",
    ],
}

if fix_actions_file and os.path.exists(fix_actions_file):
    try:
        with open(fix_actions_file, "r", encoding="utf-8", errors="ignore") as f:
            for i, raw in enumerate(f, start=1):
                line = raw.rstrip("\n")
                if not line:
                    continue
                parts = line.split("\t")
                action = parts[0] if len(parts) > 0 else ""
                target = parts[1] if len(parts) > 1 else ""
                status = parts[2] if len(parts) > 2 else ""
                result["fix_actions"].append(
                    {"id": i, "action": action, "target": target, "status": status}
                )
    except Exception:
        pass

print(json.dumps(result, sort_keys=True))
PYJSON
      if [[ -n "$fix_actions_file" ]]; then
        rm -f "$fix_actions_file" 2>/dev/null || true
      fi
      exit 0
    fi

    section "linux-maint doctor"
    echo "mode=$MODE"
    echo "prefix=$PREFIX"
    if [[ "$DOCTOR_COMPACT" -eq 1 ]]; then
      echo "note=compact"
      echo ""
    fi
    echo "wrapper=$wrapper"
    echo "libexec=$LIBEXEC"
    echo "lib=${LINUX_MAINT_LIB:-/usr/local/lib/linux_maint.sh}"
    echo "cfg_dir=$CFG_DIR"

    if [[ "$DOCTOR_FIX" -eq 1 ]]; then
      echo ""
      section "Fixes applied"
      if [[ "${#fix_actions[@]}" -eq 0 ]]; then
        echo "none"
      else
        for a in "${fix_actions[@]}"; do
          echo "- $a"
        done
      fi
    fi

    if [[ "$DOCTOR_COMPACT" -eq 0 ]]; then
      echo "== Files =="
      for path in "$wrapper" "${LINUX_MAINT_LIB:-/usr/local/lib/linux_maint.sh}"; do
        if [[ -e "$path" ]]; then ls -la "$path"; else echo "MISSING: $path"; fi
      done
      if [[ "$MODE" == "installed" ]]; then
        [[ -d "$LIBEXEC" ]] && ls -ld "$LIBEXEC" || echo "MISSING: $LIBEXEC"
      else
        [[ -d "$REPO_MONITORS" ]] && ls -ld "$REPO_MONITORS" || echo "MISSING: $REPO_MONITORS"
      fi
    fi

    echo ""
    section "Config presence"
    fix_suggestions=()
    add_fix(){ fix_suggestions+=("$1"); }
    if [[ -d "$CFG_DIR" ]]; then
      printf "%-44s %s\n" "FILE" "STATUS"
      for f in "$CFG_DIR/servers.txt" "$CFG_DIR/excluded.txt" "$CFG_DIR/services.txt" "$CFG_DIR/emails.txt"; do
        if [[ -e "$f" ]]; then
          printf "%-44s %s\n" "$f" "${C_GREEN}OK${C_RESET}"
        else
          printf "%-44s %s\n" "$f" "${C_RED}MISSING${C_RESET}"
        fi
      done

      if [[ ! -s "$CFG_DIR/servers.txt" ]]; then
        echo "WARN: servers.txt missing/empty" >&2
        add_fix "Create $CFG_DIR/servers.txt (example: printf '%s\\n' localhost | sudo tee $CFG_DIR/servers.txt)"
      else
        n_hosts=$(grep -c -vE '^\s*(#|$)' "$CFG_DIR/servers.txt" 2>/dev/null || echo 0)
        echo "hosts_configured=$n_hosts"
        if [[ "$n_hosts" -eq 0 ]]; then
          echo "WARN: servers.txt has no active hosts (only comments/blank lines)" >&2
          add_fix "Add hosts to $CFG_DIR/servers.txt (one per line)"
        fi
      fi

      if [[ -f "$CFG_DIR/services.txt" && ! -s "$CFG_DIR/services.txt" ]]; then
        echo "WARN: services.txt is empty; service monitor may be ineffective" >&2
        add_fix "Populate $CFG_DIR/services.txt with critical services (one per line)"
      fi
    else
      echo "MISSING: config dir $CFG_DIR" >&2
      echo "Tip: sudo linux-maint init" >&2
      add_fix "Initialize config templates: sudo linux-maint init"
    fi

    echo ""
    section "Monitor gates (what may SKIP)"
    printf "%-22s %-10s %s\n" "MONITOR" "STATUS" "PATH"
    if [[ -s "$CFG_DIR/certs.txt" ]]; then
      printf "%-22s %-10s %s\n" "cert_monitor" "${C_GREEN}OK${C_RESET}" "$CFG_DIR/certs.txt"
    else
      printf "%-22s %-10s %s\n" "cert_monitor" "${C_RED}MISSING${C_RESET}" "$CFG_DIR/certs.txt"
      add_fix "Add cert paths to $CFG_DIR/certs.txt"
    fi
    if [[ -s "$CFG_DIR/network_targets.txt" ]]; then
      printf "%-22s %-10s %s\n" "network_monitor" "${C_GREEN}OK${C_RESET}" "$CFG_DIR/network_targets.txt"
    else
      printf "%-22s %-10s %s\n" "network_monitor" "${C_RED}MISSING${C_RESET}" "$CFG_DIR/network_targets.txt"
      add_fix "Add network targets to $CFG_DIR/network_targets.txt"
    fi
    if [[ -s "$CFG_DIR/ports_baseline.txt" ]]; then
      printf "%-22s %-10s %s\n" "ports_baseline_monitor" "${C_GREEN}OK${C_RESET}" "$CFG_DIR/ports_baseline.txt"
    else
      printf "%-22s %-10s %s\n" "ports_baseline_monitor" "${C_RED}MISSING${C_RESET}" "$CFG_DIR/ports_baseline.txt"
      add_fix "Add baseline allowlist to $CFG_DIR/ports_baseline.txt"
    fi
    if [[ -s "$CFG_DIR/config_paths.txt" ]]; then
      printf "%-22s %-10s %s\n" "config_drift_monitor" "${C_GREEN}OK${C_RESET}" "$CFG_DIR/config_paths.txt"
    else
      printf "%-22s %-10s %s\n" "config_drift_monitor" "${C_RED}MISSING${C_RESET}" "$CFG_DIR/config_paths.txt"
      add_fix "Add config paths to $CFG_DIR/config_paths.txt"
    fi
    if [[ -s "$CFG_DIR/baseline_users.txt" ]]; then
      printf "%-22s %-10s %s\n" "user_monitor(users)" "${C_GREEN}OK${C_RESET}" "$CFG_DIR/baseline_users.txt"
    else
      printf "%-22s %-10s %s\n" "user_monitor(users)" "${C_RED}MISSING${C_RESET}" "$CFG_DIR/baseline_users.txt"
      add_fix "Generate baseline users list at $CFG_DIR/baseline_users.txt"
    fi
    if [[ -s "$CFG_DIR/baseline_sudoers.txt" ]]; then
      printf "%-22s %-10s %s\n" "user_monitor(sudoers)" "${C_GREEN}OK${C_RESET}" "$CFG_DIR/baseline_sudoers.txt"
    else
      printf "%-22s %-10s %s\n" "user_monitor(sudoers)" "${C_RED}MISSING${C_RESET}" "$CFG_DIR/baseline_sudoers.txt"
      add_fix "Generate baseline sudoers list at $CFG_DIR/baseline_sudoers.txt"
    fi
    if [[ -s "$CFG_DIR/backup_targets.csv" ]]; then
      printf "%-22s %-10s %s\n" "backup_check" "${C_GREEN}OK${C_RESET}" "$CFG_DIR/backup_targets.csv"
    else
      printf "%-22s %-10s %s\n" "backup_check" "${C_RED}MISSING${C_RESET}" "$CFG_DIR/backup_targets.csv"
      add_fix "Add backup targets to $CFG_DIR/backup_targets.csv"
    fi

    echo ""
    section "Dependencies (best-effort)"
    need_cmd() {
      local cmd="$1" pkg_hint="$2"
      if command -v "$cmd" >/dev/null 2>&1; then
        printf "%-18s %s\n" "$cmd" "${C_GREEN}OK${C_RESET}"
      else
        printf "%-18s %s\n" "$cmd" "${C_RED}MISSING${C_RESET}"
        [[ -n "$pkg_hint" ]] && echo "  hint: install package: $pkg_hint" >&2
        [[ -n "$pkg_hint" ]] && add_fix "Install missing dependency: $pkg_hint"
      fi
    }

    need_cmd awk "gawk"
    need_cmd sed "sed"
    need_cmd grep "grep"
    need_cmd df "coreutils"
    need_cmd find "findutils"
    need_cmd timeout "coreutils"
    need_cmd curl "curl"
    need_cmd openssl "openssl"
    need_cmd ssh "openssh-clients"
    need_cmd systemctl "systemd"

    if [[ "$DOCTOR_COMPACT" -eq 0 ]]; then
      echo ""
      section "systemd (best-effort)"
      if command -v systemctl >/dev/null 2>&1; then
        for unit in linux-maint.timer linux-maint.service; do
          if systemctl list-unit-files --no-legend "$unit" 2>/dev/null | grep -q "^$unit"; then
            echo "UNIT: $unit"
            systemctl is-enabled "$unit" 2>/dev/null || true
            systemctl is-active "$unit" 2>/dev/null || true
          else
            echo "INFO: unit not installed: $unit"
          fi
        done
        echo "-- timers (linux-maint) --"
        systemctl list-timers --all --no-pager 2>/dev/null | grep -E "linux-maint\.timer|NEXT|^$" || true
      else
        echo "INFO: systemctl not found"
      fi
    fi

    echo ""
    section "Can write state/logs?"
    printf "%-24s %s\n" "PATH" "STATUS"
    for d in /var/log/health /var/log/inventory /var/lib/linux_maint /var/lock; do
      if [[ -d "$d" ]]; then
        if touch "$d/.lm_write_test" 2>/dev/null; then
          rm -f "$d/.lm_write_test" 2>/dev/null || true
          printf "%-24s %s\n" "$d" "${C_GREEN}OK${C_RESET}"
        else
          printf "%-24s %s\n" "$d" "${C_RED}NOT_WRITABLE${C_RESET}"
        fi
        if ! touch "$d/.lm_write_test" 2>/dev/null; then
          add_fix "Ensure $d is writable (example: sudo install -d -m 0755 $d)"
        fi
      else
        printf "%-24s %s\n" "$d" "${C_RED}MISSING${C_RESET}"
        add_fix "Create missing dir: sudo install -d -m 0755 $d"
      fi
    done

    echo ""
    section "Fix suggestions"
    if [[ "${#fix_suggestions[@]}" -eq 0 ]]; then
      echo "- none"
    else
      for f in "${fix_suggestions[@]}"; do
        echo "- $f"
      done
    fi

    if [[ "$DOCTOR_COMPACT" -eq 0 ]]; then
      echo ""
      section "Next recommended actions"
      echo "- linux-maint verify-install"
      echo "- sudo linux-maint init      # if config is missing"
      echo "- sudo linux-maint preflight"
      echo "- sudo linux-maint run"
      echo "- linux-maint pack-logs --out .  # create bundle for export"
    fi
    if [[ -n "$fix_actions_file" ]]; then
      rm -f "$fix_actions_file" 2>/dev/null || true
    fi
    ;;

  self-check)
    SC_JSON=0
    SC_COMPACT=0
    while [[ $# -gt 0 ]]; do
      case "$1" in
        --json) SC_JSON=1; shift 1;;
        --compact) SC_COMPACT=1; shift 1;;
        -h|--help)
          command_usage self-check
          exit 0;;
        *) echo "Unknown self-check flag: $1" >&2; exit 2;;
      esac
    done

    CFG_DIR="${LM_CFG_DIR:-/etc/linux_maint}"
    if [[ "$MODE" == "repo" ]]; then
      LOG_DIR_SC="${LOG_DIR:-$REPO_LOG_DIR}"
      STATE_DIR_SC="${LM_STATE_DIR:-/tmp}"
      LOCK_DIR_SC="${LM_LOCKDIR:-/tmp}"
    else
      LOG_DIR_SC="${LOG_DIR:-/var/log/health}"
      STATE_DIR_SC="${LM_STATE_DIR:-/var/lib/linux_maint}"
      LOCK_DIR_SC="${LM_LOCKDIR:-/var/lock}"
    fi

    if [[ "$SC_JSON" -eq 1 ]]; then
      MODE="$MODE" CFG_DIR="$CFG_DIR" LOG_DIR_SC="$LOG_DIR_SC" STATE_DIR_SC="$STATE_DIR_SC" LOCK_DIR_SC="$LOCK_DIR_SC" python3 - <<'PY'
import json, os, pathlib, shutil

mode = os.environ.get("MODE","")
cfg_dir = os.environ.get("CFG_DIR","/etc/linux_maint")
log_dir = os.environ.get("LOG_DIR_SC","/var/log/health")
state_dir = os.environ.get("STATE_DIR_SC","/var/lib/linux_maint")
lock_dir = os.environ.get("LOCK_DIR_SC","/var/lock")

cfg_path = pathlib.Path(cfg_dir)
config_files = ["servers.txt", "excluded.txt", "services.txt"]
config = {
    "dir_exists": cfg_path.is_dir(),
    "files": {name: (cfg_path / name).exists() for name in config_files},
}

def writable(path: str) -> bool:
    p = pathlib.Path(path)
    if not p.is_dir():
        return False
    return os.access(path, os.W_OK)

paths = [
    {"purpose": "logs", "path": log_dir, "exists": pathlib.Path(log_dir).is_dir(), "writable": writable(log_dir)},
    {"purpose": "state", "path": state_dir, "exists": pathlib.Path(state_dir).is_dir(), "writable": writable(state_dir)},
    {"purpose": "lock", "path": lock_dir, "exists": pathlib.Path(lock_dir).is_dir(), "writable": writable(lock_dir)},
]

deps_list = ["bash","awk","sed","grep","df","find","timeout","ssh"]
deps = [{"cmd": d, "present": shutil.which(d) is not None} for d in deps_list]

out = {
    "mode": mode,
    "cfg_dir": cfg_dir,
    "config": config,
    "paths": paths,
    "dependencies": deps,
}

print(json.dumps(out, sort_keys=True))
PY
      exit 0
    fi

    section "linux-maint self-check"
    echo "mode=$MODE"
    echo "cfg_dir=$CFG_DIR"
    if [[ "$SC_COMPACT" -eq 1 ]]; then
      echo "note=compact"
      echo ""
    fi
    section "Config files"
    printf "%-44s %s\n" "FILE" "STATUS"
    for f in "$CFG_DIR/servers.txt" "$CFG_DIR/excluded.txt" "$CFG_DIR/services.txt"; do
      if [[ -e "$f" ]]; then
        printf "%-44s %s\n" "$f" "${C_GREEN}OK${C_RESET}"
      else
        printf "%-44s %s\n" "$f" "${C_RED}MISSING${C_RESET}"
      fi
    done
    if [[ "$SC_COMPACT" -eq 0 ]]; then
      echo ""
      section "Paths (writable)"
      printf "%-10s %-44s %s\n" "PURPOSE" "PATH" "STATUS"
      for purpose in logs state lock; do
        case "$purpose" in
          logs) d="$LOG_DIR_SC" ;;
          state) d="$STATE_DIR_SC" ;;
          lock) d="$LOCK_DIR_SC" ;;
        esac
        if [[ -d "$d" ]]; then
          if [[ -w "$d" ]]; then
            printf "%-10s %-44s %s\n" "$purpose" "$d" "${C_GREEN}OK${C_RESET}"
          else
            printf "%-10s %-44s %s\n" "$purpose" "$d" "${C_RED}NOT_WRITABLE${C_RESET}"
          fi
        else
          printf "%-10s %-44s %s\n" "$purpose" "$d" "${C_RED}MISSING${C_RESET}"
        fi
      done
      echo ""
      section "Dependencies"
      for cmd in bash awk sed grep df find timeout ssh; do
        command -v "$cmd" >/dev/null 2>&1 && printf "%-18s %s\n" "$cmd" "${C_GREEN}OK${C_RESET}" || printf "%-18s %s\n" "$cmd" "${C_RED}MISSING${C_RESET}"
      done
    fi
    ;;

  deps)
    if [[ "$MODE" == "installed" ]]; then
      need_root_for deps
    fi

    has_cmd() { command -v "$1" >/dev/null 2>&1 && echo yes || echo no; }

    section "linux-maint deps"
    echo "mode=$MODE"
    echo "format: monitor|required|optional|available_required|available_optional"

    # monitor|required_cmds(optional space-separated)|optional_cmds(space-separated)
    while IFS='|' read -r mon req opt; do
      [[ -z "$mon" ]] && continue
      req_avail=0; req_total=0
      opt_avail=0; opt_total=0

      for c in $req; do
        req_total=$((req_total+1))
        [[ "$(has_cmd "$c")" == "yes" ]] && req_avail=$((req_avail+1))
      done
      for c in $opt; do
        opt_total=$((opt_total+1))
        [[ "$(has_cmd "$c")" == "yes" ]] && opt_avail=$((opt_avail+1))
      done

      echo "monitor=$mon|required=${req:-none}|optional=${opt:-none}|available_required=${req_avail}/${req_total}|available_optional=${opt_avail}/${opt_total}"
    done <<'EOF_DEPS'
preflight_check|awk sed grep df timeout ssh|curl openssl
config_validate|awk sed grep|none
health_monitor|awk sed grep ps df|none
inode_monitor|awk sed grep df|none
disk_trend_monitor|awk sed grep df|none
network_monitor|awk sed grep|curl
service_monitor|awk sed grep|systemctl
ntp_drift_monitor|awk sed grep|chronyc ntpq
patch_monitor|awk sed grep|apt yum dnf zypper
storage_health_monitor|awk sed grep|smartctl nvme
kernel_events_monitor|awk sed grep|journalctl dmesg
cert_monitor|awk sed grep|openssl
nfs_mount_monitor|awk sed grep|showmount
ports_baseline_monitor|awk sed grep|ss netstat
config_drift_monitor|awk sed grep|sha256sum md5sum
user_monitor|awk sed grep|id getent
backup_check|awk sed grep|none
inventory_export|awk sed grep hostname|ip lsblk lscpu
EOF_DEPS
    ;;


  *)
    echo "Unknown command: $cmd" >&2
    usage
    exit 2
    ;;
esac
