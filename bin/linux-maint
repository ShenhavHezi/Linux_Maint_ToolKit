#!/usr/bin/env bash
# linux-maint - CLI entrypoint for Linux_Maint_Scripts

set -euo pipefail

# Prefer a writable temp dir when creating tmp files.
TMPDIR="${TMPDIR:-/tmp}"

# Color handling (opt-out via NO_COLOR/LM_NO_COLOR or --no-color)
LM_COLOR="${LM_COLOR:-1}"
color_enabled() {
  [[ "$LM_COLOR" -eq 1 ]] && [[ -t 1 ]] && [[ -z "${NO_COLOR:-}" ]] && [[ -z "${LM_NO_COLOR:-}" ]]
}
if color_enabled; then
  C_RESET=$'\033[0m'
  C_BOLD=$'\033[1m'
  C_RED=$'\033[31m'
  C_YELLOW=$'\033[33m'
  C_GREEN=$'\033[32m'
  C_CYAN=$'\033[36m'
else
  C_RESET=""; C_BOLD=""; C_RED=""; C_YELLOW=""; C_GREEN=""; C_CYAN=""
fi

# If running from a git checkout, prefer repo paths automatically.
SCRIPT_DIR="$(cd -- "$(dirname -- "${BASH_SOURCE[0]}")" && pwd)"
REPO_ROOT="$(cd -- "$SCRIPT_DIR/.." && pwd)"

PREFIX="${PREFIX:-/usr/local}"
SBIN="$PREFIX/sbin"
LIBEXEC="$PREFIX/libexec/linux_maint"
SHARE="$PREFIX/share/linux_maint"

REPO_MONITORS="$REPO_ROOT/monitors"
REPO_LIB="$REPO_ROOT/lib/linux_maint.sh"
REPO_WRAPPER="$REPO_ROOT/run_full_health_monitor.sh"

# installed defaults
wrapper="$SBIN/run_full_health_monitor.sh"
preflight="$LIBEXEC/preflight_check.sh"
validate="$LIBEXEC/config_validate.sh"

if [[ -d "$REPO_MONITORS" && -f "$REPO_LIB" ]]; then
  # repo mode
  export LINUX_MAINT_LIB="${LINUX_MAINT_LIB:-$REPO_LIB}"
  export LM_LOCKDIR="${LM_LOCKDIR:-/tmp}"
  export LM_LOGFILE="${LM_LOGFILE:-/tmp/linux_maint.log}"
  wrapper="$REPO_WRAPPER"
  preflight="$REPO_MONITORS/preflight_check.sh"
  validate="$REPO_MONITORS/config_validate.sh"
fi

MODE="installed"
[[ "$wrapper" == "$REPO_WRAPPER" ]] && MODE="repo"
REPO_LOG_DIR="$REPO_ROOT/.logs"
REPO_STATUS_FILE="$REPO_LOG_DIR/last_status_full"
REPO_LATEST_LOG="$REPO_LOG_DIR/full_health_monitor_latest.log"
REPO_SUMMARY_LATEST="$REPO_LOG_DIR/full_health_monitor_summary_latest.log"
INST_SUMMARY_LATEST="/var/log/health/full_health_monitor_summary_latest.log"


need_root_for(){
  local cmd="$1"
  if [[ "${EUID:-$(id -u)}" -ne 0 ]]; then
    echo "ERROR: linux-maint $cmd requires root (installed mode)." >&2
    case "$cmd" in
      run)
        echo "Hint: sudo linux-maint run" >&2
        echo "      (or run the wrapper directly: sudo /usr/local/sbin/run_full_health_monitor.sh)" >&2
        ;;
      status)
        echo "Hint: sudo linux-maint status" >&2
        ;;
      logs)
        echo "Hint: sudo linux-maint logs 200" >&2
        ;;
      preflight)
        echo "Hint: sudo linux-maint preflight" >&2
        ;;
      validate)
        echo "Hint: sudo linux-maint validate" >&2
        ;;
      *)
        echo "Hint: sudo linux-maint $cmd" >&2
        ;;
    esac
    exit 1
  fi
}


validate_ssh_opts(){
  # Reject obviously dangerous shell metacharacters.
  # NOTE: LM_SSH_OPTS is split into argv for ssh; this check reduces the risk of accidental injection.
  local s="${LM_SSH_OPTS:-}"
  [[ -z "$s" ]] && return 0

  # Disallow shell metacharacters.
  # Newline/carriage-return checks are done separately with ANSI-C escapes.
  if printf '%s' "$s" | grep -Eq '[;&|`<>]|\$\(|\$\{'; then
    echo "ERROR: unsafe characters detected in --ssh-opts / LM_SSH_OPTS" >&2
    echo "LM_SSH_OPTS=$s" >&2
    exit 2
  fi
  case "$s" in
    *$'\n'*|*$'\r'*)
      echo "ERROR: unsafe characters detected in --ssh-opts / LM_SSH_OPTS" >&2
      echo "LM_SSH_OPTS=$s" >&2
      exit 2
      ;;
  esac
}


expected_skips(){
  local cfg="${1:-/etc/linux_maint}"
  echo "Expected SKIPs (missing optional config):"
  local any=0
  if [[ ! -s "$cfg/network_targets.txt" ]]; then echo "- network_monitor (missing:$cfg/network_targets.txt)"; any=1; fi
  if [[ ! -s "$cfg/certs.txt" ]]; then echo "- cert_monitor (missing:$cfg/certs.txt)"; any=1; fi
  if [[ ! -s "$cfg/ports_baseline.txt" ]]; then echo "- ports_baseline_monitor (missing:$cfg/ports_baseline.txt)"; any=1; fi
  if [[ ! -s "$cfg/config_paths.txt" ]]; then echo "- config_drift_monitor (missing:$cfg/config_paths.txt)"; any=1; fi
  if [[ ! -s "$cfg/baseline_users.txt" || ! -s "$cfg/baseline_sudoers.txt" ]]; then
    local miss=()
    [[ ! -s "$cfg/baseline_users.txt" ]] && miss+=("$cfg/baseline_users.txt")
    [[ ! -s "$cfg/baseline_sudoers.txt" ]] && miss+=("$cfg/baseline_sudoers.txt")
    local IFS=,
    echo "- user_monitor (missing:${miss[*]})"
    any=1
  fi
  if [[ ! -s "$cfg/backup_targets.csv" ]]; then echo "- backup_check (missing:$cfg/backup_targets.csv)"; any=1; fi
  if [[ "$any" -eq 0 ]]; then
    echo "- none (all optional config present)"
  fi
}


# ---- run() flags parsing (CLI-first, env-compatible) ----
# Maps:
#   --group G        -> LM_GROUP
#   --hosts a,b      -> LM_SERVERLIST (temp file)
#   --exclude a,b    -> LM_EXCLUDED (temp file)
#   --parallel N     -> LM_MAX_PARALLEL
#   --local-only     -> LM_LOCAL_ONLY=true
#   --ssh-opts "..." -> LM_SSH_OPTS
#   --dry-run        -> print resolved hosts and exit
#
_run_tmpfiles=()
cleanup_tmpfiles(){
  for f in "${_run_tmpfiles[@]:-}"; do rm -f "$f" 2>/dev/null || true; done
}
trap cleanup_tmpfiles EXIT

make_list_tmpfile(){
  local csv="$1" prefix="$2"
  local f
  f="$(mktemp -p "$TMPDIR" "linux_maint_${prefix}.XXXXXX")"
  _run_tmpfiles+=("$f")
  # split on comma and whitespace
  echo "$csv" | tr ',' '\n' | awk '{gsub(/^[ \t]+|[ \t]+$/,"",$0); if($0!="") print $0}' > "$f"
  echo "$f"
}

parse_run_args(){
  DRY_RUN=0
  DEBUG=0
  LIMIT=0
  SHUFFLE=0

  while [[ $# -gt 0 ]]; do
    case "$1" in
      --group)
        LM_GROUP="$2"; export LM_GROUP; shift 2;;
      --hosts)
        tmpf="$(make_list_tmpfile "$2" hosts)"; LM_SERVERLIST="$tmpf"; export LM_SERVERLIST; shift 2;;
      --exclude)
        tmpf="$(make_list_tmpfile "$2" excluded)"; LM_EXCLUDED="$tmpf"; export LM_EXCLUDED; shift 2;;
      --parallel)
        LM_MAX_PARALLEL="$2"; export LM_MAX_PARALLEL; shift 2;;
      --local-only)
        LM_LOCAL_ONLY="true"; export LM_LOCAL_ONLY; shift 1;;
      --ssh-opts)
        LM_SSH_OPTS="$2"; export LM_SSH_OPTS; shift 2;;
      --limit)
        LIMIT="$2"; shift 2;;
      --shuffle)
        SHUFFLE=1; shift 1;;
      --debug|--print-env)
        DEBUG=1; shift 1;;
      --dry-run)
        DRY_RUN=1; shift 1;;
      -h|--help)
        echo "Usage: linux-maint run [--group G] [--hosts h1,h2] [--exclude h3,h4] [--parallel N] [--local-only] [--ssh-opts '...'] [--limit N] [--shuffle] [--debug|--print-env] [--dry-run]"
        exit 0;;
      *)
        echo "Unknown run flag: $1" >&2
        exit 2;;
    esac
  done
}


usage(){
  cat <<EOF2
Usage: linux-maint <command> [args]

Common commands:
  run [flags]            Run the full wrapper
  status [flags]         Show last run status + filtered summary lines
  diff [--json]          Show diff since last run (uses wrapper diff state)
  logs [n]               Tail latest wrapper log (default n=200)
  report [--json] [--compact] [--table] [--no-trend] [--no-slow] [--no-reasons] [--no-problems]  Summarize latest run, trends, and slow monitors
  config [--json] [--sources] [--lint]  Show effective config (merged from /etc/linux_maint)
  doctor [--json]        Diagnose installation/config/state permissions
  self-check [--json]    Quick validation (config/paths/deps; safe without sudo)
  check                 Run config_validate + preflight + show expected skips
  history [--last N] [--json] [--table]  Show recent runs (run index; faster than log scan)
  summary [--no-color]  One-line latest summary (for cron/dashboards)

Analysis / reporting:
  trend [--last N] [--json]     Aggregate severity/reason trends
  runtimes [--last N] [--json]  Show per-monitor runtimes
  export --json|--csv           Export a single payload (summary_result/hosts + rows)

Setup / maintenance:
  init [--minimal]       Install /etc/linux_maint templates (from repo checkout)
  tune dark-site         Apply recommended dark-site defaults to linux-maint.conf
  baseline <ports|configs|users|sudoers> [--update] [--local-only] [--diff] [--show]  Capture or preview baselines
  preflight              Run preflight checks
  validate               Validate config file formats (best-effort)
  deps                   Print required/optional dependency manifest by monitor
  verify-install         Verify installation layout and systemd wiring (best-effort)
  pack-logs [--out DIR]  Create a support bundle tar.gz (logs, config redacted, meta)

Release / packaging:
  version                Print installed BUILD_INFO (if present)
  make-tarball            Build offline release tarball (tools/make_tarball.sh)
  verify-release          Verify release tarball integrity (tools/verify_release.sh)
  install [args]          Run ./install.sh (pass-through)
  uninstall [args]        Run ./install.sh --uninstall (pass-through)

Help:
  explain reason <token>  Explain a reason= token (from docs/REASONS.md)
  explain status <S>      Explain a status value (OK/WARN/CRIT/UNKNOWN/SKIP)
  help                    Show this help

Environment:
  PREFIX=/usr/local             installation prefix override
  LINUX_MAINT_LIB=...           override library path (useful in repo mode)
  LM_LOCKDIR=/tmp               override lock dir (useful when not root)
  LM_LOGFILE=/tmp/linux_maint.log override default log file
  NO_COLOR=1                    disable colored output

Examples:
  linux-maint run --local-only
  linux-maint status --only WARN
  linux-maint report
  linux-maint summary
EOF2
}

cmd="${1:-help}"; shift || true

case "$cmd" in
  help|-h|--help)
    usage
    ;;

  run)
    if [[ "$MODE" == "installed" ]]; then
      need_root_for run
    fi
    parse_run_args "$@"
    validate_ssh_opts

    if [[ "${DEBUG:-0}" -eq 1 ]]; then
      echo "=== linux-maint run debug ==="
      echo "MODE=${MODE}"
      echo "wrapper=${wrapper}"
      echo "LM_GROUP=${LM_GROUP:-}"
      echo "LM_HOSTS_DIR=${LM_HOSTS_DIR:-}"
      echo "LM_SERVERLIST=${LM_SERVERLIST:-}"
      echo "LM_EXCLUDED=${LM_EXCLUDED:-}"
      echo "LM_MAX_PARALLEL=${LM_MAX_PARALLEL:-}"
      echo "LM_LOCAL_ONLY=${LM_LOCAL_ONLY:-}"
      echo "LM_SSH_OPTS=${LM_SSH_OPTS:-}"
      echo "LIMIT=${LIMIT:-0}"
      echo "SHUFFLE=${SHUFFLE:-0}"
      echo "DRY_RUN=${DRY_RUN:-0}"
      echo "============================="
    fi

    if [[ "${DRY_RUN:-0}" -eq 1 ]]; then
      if [[ -n "${LM_GROUP:-}" ]]; then
        gf="${LM_HOSTS_DIR:-/etc/linux_maint/hosts.d}/${LM_GROUP}.txt"
        [[ -f "$gf" ]] || echo "NOTE: LM_GROUP=$LM_GROUP but group file not found: $gf (will fall back)" >&2
      fi

      # best-effort host resolution using library if available
      if [[ -f "${LINUX_MAINT_LIB:-/usr/local/lib/linux_maint.sh}" ]]; then
        # shellcheck disable=SC1090
        . "${LINUX_MAINT_LIB:-/usr/local/lib/linux_maint.sh}" >/dev/null 2>&1 || true
        if command -v lm_hosts >/dev/null 2>&1; then
          mapfile -t _hosts < <(lm_hosts)
          if [[ "${SHUFFLE:-0}" -eq 1 ]]; then
            mapfile -t _hosts < <(printf '%s\n' "${_hosts[@]}" | shuf)
          fi
          if [[ "${LIMIT:-0}" -gt 0 ]]; then
            mapfile -t _hosts < <(printf '%s\n' "${_hosts[@]}" | head -n "${LIMIT}")
          fi

          echo "Resolved hosts (${#_hosts[@]}):"
          printf '%s\n' "${_hosts[@]}"
          exit 0
        fi
      fi
      echo "DRY RUN requested, but cannot resolve hosts (library not available)." >&2
      exit 0
    fi

    # Run wrapper (installed or repo mode) and print a short footer when interactive.
    if [[ "$wrapper" == "$SBIN"/* ]]; then
      "$wrapper"
    else
      bash "$wrapper"
    fi
    rc=$?
    if [[ -t 1 ]]; then
      echo ""
      echo "Run complete (exit_code=$rc)"
      if [[ "$MODE" == "repo" ]]; then
        echo "Summary: $REPO_SUMMARY_LATEST"
        echo "Log: $REPO_LATEST_LOG"
      else
        echo "Summary: $INST_SUMMARY_LATEST"
        echo "Log: /var/log/health/full_health_monitor_latest.log"
      fi
      echo "Tip: linux-maint report"
    fi
    exit $rc
    ;;


  diff)
    # Show diff of monitor= lines since last run.
    # Uses the same state file as the wrapper: last_summary_monitor_lines.log
    JSON=0
    if [[ "${1:-}" == "--json" ]]; then JSON=1; shift; fi

    if [[ "$MODE" == "repo" ]]; then
      DIFF_STATE_DIR="${LM_NOTIFY_STATE_DIR:-${LM_STATE_DIR:-$REPO_LOG_DIR}}"
      SUMMARY_LATEST="$REPO_SUMMARY_LATEST"
    else
      DIFF_STATE_DIR="${LM_NOTIFY_STATE_DIR:-${LM_STATE_DIR:-/var/lib/linux_maint}}"
      SUMMARY_LATEST="$INST_SUMMARY_LATEST"
    fi
    PREV_SUMMARY="$DIFF_STATE_DIR/last_summary_monitor_lines.log"

    CUR_SUMMARY="$SUMMARY_LATEST"
    echo "diff_state_dir=$DIFF_STATE_DIR"

    if [[ ! -f "$CUR_SUMMARY" ]]; then
      echo "No current summary file: $CUR_SUMMARY" >&2
      echo "Run linux-maint run first." >&2
      exit 1
    fi
    if [[ ! -f "$PREV_SUMMARY" ]]; then
      echo "No previous diff state file: $PREV_SUMMARY" >&2
      echo "The wrapper writes this after each run (best-effort). Typically you need to run linux-maint run twice to get a useful diff." >&2
      exit 1
    fi

    if [[ "$MODE" == "repo" ]]; then
      diff_tool="$REPO_ROOT/tools/summary_diff.py"
    else
      diff_tool="$LIBEXEC/summary_diff.py"
    fi
    if [[ ! -x "$diff_tool" ]]; then
      # In installed mode, tools/ may not exist; try a system python module not available; fallback to error.
      echo "Diff tool not found/executable: $diff_tool" >&2
      echo "Hint: reinstall linux-maint to include summary_diff.py" >&2
      exit 1
    fi

    if [[ "$JSON" -eq 1 ]]; then
      exec python3 "$diff_tool" "$PREV_SUMMARY" "$CUR_SUMMARY" --json
    else
      exec python3 "$diff_tool" "$PREV_SUMMARY" "$CUR_SUMMARY"
    fi
    ;;
  logs)
    if [[ "$MODE" == "installed" ]]; then
      need_root_for logs
    fi
        n="${1:-200}"
        if [[ "$MODE" == "repo" ]]; then
          mkdir -p "$REPO_LOG_DIR"
          [[ -f "$REPO_LATEST_LOG" ]] || { echo "No repo log yet: $REPO_LATEST_LOG"; exit 1; }
          tail -n "$n" "$REPO_LATEST_LOG"
        else
          exec sudo -n tail -n "$n" /var/log/health/full_health_monitor_latest.log 2>/dev/null || tail -n "$n" /var/log/health/full_health_monitor_latest.log
        fi
    ;;

  report)
    if [[ "$MODE" == "installed" ]]; then
      need_root_for report
    fi

    REPORT_JSON=0
    REPORT_COLOR=1
    REPORT_COMPACT=0
    REPORT_TABLE="${LM_REPORT_TABLE:-0}"
    REPORT_NO_TREND=0
    REPORT_NO_SLOW=0
    REPORT_NO_REASONS=0
    REPORT_NO_PROBLEMS=0
    while [[ $# -gt 0 ]]; do
      case "$1" in
        --json) REPORT_JSON=1; shift 1;;
        --no-color) REPORT_COLOR=0; shift 1;;
        --compact) REPORT_COMPACT=1; shift 1;;
        --table) REPORT_TABLE=1; shift 1;;
        --no-trend) REPORT_NO_TREND=1; shift 1;;
        --no-slow) REPORT_NO_SLOW=1; shift 1;;
        --no-reasons) REPORT_NO_REASONS=1; shift 1;;
        --no-problems) REPORT_NO_PROBLEMS=1; shift 1;;
        -h|--help)
          echo "Usage: linux-maint report [--json] [--no-color] [--compact] [--table] [--no-trend] [--no-slow] [--no-reasons] [--no-problems]"
          exit 0;;
        *) echo "Unknown report flag: $1" >&2; exit 2;;
      esac
    done
    [[ -n "${NO_COLOR:-}" || -n "${LM_NO_COLOR:-}" ]] && REPORT_COLOR=0
    color_enabled || REPORT_COLOR=0

    tmp_status="$(mktemp -p "$TMPDIR" linux_maint_report_status.XXXXXX.json)"
    tmp_trend="$(mktemp -p "$TMPDIR" linux_maint_report_trend.XXXXXX.json)"
    tmp_runtimes="$(mktemp -p "$TMPDIR" linux_maint_report_runtimes.XXXXXX.json)"

    "$0" status --json --problems 20 --reasons 10 >"$tmp_status" 2>/dev/null || printf '{}' >"$tmp_status"
    "$0" trend --last 10 --json >"$tmp_trend" 2>/dev/null || printf '{}' >"$tmp_trend"
    "$0" runtimes --last 1 --json >"$tmp_runtimes" 2>/dev/null || printf '{}' >"$tmp_runtimes"

    LM_COLOR="$REPORT_COLOR" REPORT_COMPACT="$REPORT_COMPACT" REPORT_TABLE="$REPORT_TABLE" REPORT_NO_TREND="$REPORT_NO_TREND" REPORT_NO_SLOW="$REPORT_NO_SLOW" REPORT_NO_REASONS="$REPORT_NO_REASONS" REPORT_NO_PROBLEMS="$REPORT_NO_PROBLEMS" python3 - "$tmp_status" "$tmp_trend" "$tmp_runtimes" "$REPORT_JSON" <<'PY'
import json, os, sys

status_path, trend_path, runtimes_path, json_mode = sys.argv[1:5]
json_mode = json_mode == "1"
color = os.environ.get("LM_COLOR","1") == "1"
compact = os.environ.get("REPORT_COMPACT","0") == "1"
table = os.environ.get("REPORT_TABLE","0") == "1"
no_trend = os.environ.get("REPORT_NO_TREND","0") == "1"
no_slow = os.environ.get("REPORT_NO_SLOW","0") == "1"
no_reasons = os.environ.get("REPORT_NO_REASONS","0") == "1"
no_problems = os.environ.get("REPORT_NO_PROBLEMS","0") == "1"

def c(s, code):
    if not color:
        return s
    return f"\033[{code}m{s}\033[0m"

def color_status(st, text=None):
    label = text if text is not None else st
    if st == "CRIT":
        return c(label, "1;31")
    if st == "WARN":
        return c(label, "1;33")
    if st == "OK":
        return c(label, "1;32")
    if st == "UNKNOWN":
        return c(label, "1;35")
    if st == "SKIP":
        return c(label, "1;36")
    return label

def read_json(p):
    try:
        with open(p, "r", encoding="utf-8") as f:
            return json.load(f)
    except Exception:
        return {}

status = read_json(status_path)
trend = read_json(trend_path)
runtimes = read_json(runtimes_path)

if json_mode:
    out = {
        "status": status,
        "trend": trend,
        "runtimes": runtimes,
    }
    print(json.dumps(out, indent=2, sort_keys=True))
    raise SystemExit(0)

mode = status.get("mode", "unknown")
last = status.get("last_status", {})
overall = last.get("overall", "UNKNOWN")
exit_code = last.get("exit_code", "3")
logfile = last.get("logfile", "")
summary = status.get("summary_file", "")
ov = color_status(overall)
if not compact:
    banner = f"health={color_status(overall)} exit_code={exit_code}"
    print(c("=== linux-maint report ===","1;36") + " " + banner)
print(f"mode={mode} overall={ov} exit_code={exit_code}")
if not compact:
    if logfile:
        print(f"logfile={logfile}")
    if summary:
        print(f"summary_file={summary}")

totals = status.get("totals", {})
if totals:
    tvals=[("CRIT", totals.get("CRIT",0)), ("WARN", totals.get("WARN",0)), ("UNKNOWN", totals.get("UNKNOWN",0)), ("SKIP", totals.get("SKIP",0)), ("OK", totals.get("OK",0))]
    maxk=max(len(k) for k,_ in tvals) if tvals else 0
    maxv=max(len(str(v)) for _,v in tvals) if tvals else 0
    if table:
        print("totals:")
        print(f"  {'STATUS':<{maxk}} {'COUNT':<{maxv}}")
        for k,v in tvals:
            label = f"{k:<{maxk}}"
            count = f"{str(v):<{maxv}}"
            label = color_status(k, label)
            if v != 0:
                count = color_status(k, count)
            print(f"  {label} {count}")
    else:
        parts = []
        for k, v in tvals:
            kv = f"{k}={v}"
            if v != 0:
                kv = color_status(k, kv)
            parts.append(kv)
        line = "totals: " + " ".join(parts)
        print(line)
    if compact:
        raise SystemExit(0)

problems = status.get("problems", [])
if problems and not no_problems:
    print("\nproblems (top):")
    if table:
        rows=[]
        for p in problems[:20]:
            s=p.get("status","UNKNOWN")
            mon=p.get("monitor","unknown")
            host=p.get("host","")
            reason=p.get("reason","")
            rows.append((s, mon, host, reason))
        sev_order={'CRIT':0,'WARN':1,'UNKNOWN':2,'SKIP':3}
        rows.sort(key=lambda r: sev_order.get(r[0], 9))
        headers=("STATUS","MONITOR","HOST","REASON")
        w=[len(h) for h in headers]
        for r in rows:
            for i,v in enumerate(r):
                w[i]=max(w[i], len(str(v)))
        print(f"{headers[0]:<{w[0]}} {headers[1]:<{w[1]}} {headers[2]:<{w[2]}} {headers[3]}")
        for s,mon,host,reason in rows:
            s_pad=f"{s:<{w[0]}}"
            if s=="CRIT":
                s_pad=c(s_pad,'1;31')
            elif s=="WARN":
                s_pad=c(s_pad,'1;33')
            elif s=="OK":
                s_pad=c(s_pad,'1;32')
            elif s=="UNKNOWN":
                s_pad=c(s_pad,'1;35')
            elif s=="SKIP":
                s_pad=c(s_pad,'1;36')
            print(f"{s_pad} {mon:<{w[1]}} {host:<{w[2]}} {reason}")
    else:
        for p in problems[:20]:
            s = p.get("status","UNKNOWN")
            mon = p.get("monitor","unknown")
            host = p.get("host","")
            reason = p.get("reason","")
            st = color_status(s)
            line = f"{st} {mon}"
            if host:
                line += f" host={host}"
            if reason:
                line += f" reason={reason}"
            print(line)
    print("\nnext_steps:")
    print("  - run: linux-maint doctor")
    print("  - run: linux-maint status --verbose")
elif not no_problems:
    print("\nproblems: none (all OK)")

reason_rollup = status.get("reason_rollup", [])
if reason_rollup and not no_reasons:
    print("\nreasons (latest):")
    for r in reason_rollup[:10]:
        print(f"{r.get('reason')}={r.get('count')}")

    hints_map = {
        "permission_denied": "Run with sudo or fix permissions for logs/state/config.",
        "missing_optional_cmd": "Install the optional dependency listed in the monitor output.",
        "missing_dependency": "Install the required dependency on the runner/host.",
        "kernel_log_unreadable": "Check journal/dmesg permissions and ensure kernel logs are readable.",
        "collect_failed": "Inventory export failed; verify /var/log/inventory and required tools (ip, lsblk, lscpu).",
        "ports_baseline_changed": "Review listening port changes and update the baseline if expected.",
        "config_drift_changed": "Review config changes and update the baseline if intended.",
        "user_anomalies": "Review new/removed users and sudoers changes.",
        "ntp_drift_high": "Check NTP/chrony sync and clock drift.",
        "ntp_not_synced": "Check NTP/chrony sync.",
        "missing_log_source": "Ensure journald/syslog is available and readable.",
        "security_updates_pending": "Apply security updates via your package manager.",
        "updates_pending": "Apply pending package updates.",
        "baseline_missing": "Create a baseline via linux-maint baseline.",
        "baseline_created": "Baseline created; rerun to compare changes.",
        "baseline_updated": "Baseline updated; rerun to check for drift.",
        "baseline_exists": "Baseline already exists; use --update if you want to overwrite it.",
        "baseline_collect_failed": "Baseline collection failed; check permissions/SSH and retry.",
        "timer_missing": "Install/enable linux-maint.timer if you want scheduled runs.",
        "timer_disabled": "Enable linux-maint.timer (systemctl enable --now linux-maint.timer).",
        "timer_inactive": "Start linux-maint.timer (systemctl start linux-maint.timer).",
        "ssh_unreachable": "Verify SSH connectivity and credentials for the target host.",
        "stale_run": "Check timers/cron; last run appears too old.",
    }
    reasons = [r.get("reason") for r in reason_rollup[:10] if r.get("reason")]
    hint_lines = []
    seen = set()
    for reason in reasons:
        if reason in hints_map and reason not in seen:
            seen.add(reason)
            hint_lines.append(f"{reason}: {hints_map[reason]}")
    if hint_lines:
        print("\nhints:")
        for h in hint_lines[:5]:
            print(f"- {h}")

if trend and not no_trend:
    t_totals = trend.get("totals", {})
    if t_totals:
        print("\ntrend (last runs):")
        print("totals: " + " ".join(f"{k}={t_totals.get(k,0)}" for k in ["CRIT","WARN","UNKNOWN","SKIP","OK"]))
    t_reasons = trend.get("reasons", [])
    if t_reasons:
        print("top_reasons:")
        for r in t_reasons[:10]:
            print(f"{r.get('reason')}={r.get('count')}")

rows = runtimes.get("rows", [])
if rows and not no_slow:
    print("\nslow monitors (last run):")
    if table:
        rows2=[(r.get("monitor",""), str(r.get("ms",""))) for r in rows[:10]]
        headers=("MONITOR","MS")
        w=[len(h) for h in headers]
        for r in rows2:
            for i,v in enumerate(r):
                w[i]=max(w[i], len(str(v)))
        print(f"{headers[0]:<{w[0]}} {headers[1]:<{w[1]}}")
        for mon,ms in rows2:
            print(f"{mon:<{w[0]}} {ms:<{w[1]}}")
    else:
        for r in rows[:10]:
            print(f"{r.get('monitor')} ms={r.get('ms')}")
PY

    rm -f "$tmp_status" "$tmp_trend" "$tmp_runtimes" 2>/dev/null || true
    ;;

  config)
    if [[ "$MODE" == "installed" ]]; then
      need_root_for config
    fi

    CFG_JSON=0
    CFG_SOURCES=0
    CFG_LINT=0
    while [[ $# -gt 0 ]]; do
      case "$1" in
        --json) CFG_JSON=1; shift 1;;
        --sources) CFG_SOURCES=1; shift 1;;
        --lint) CFG_LINT=1; shift 1;;
        -h|--help)
          echo "Usage: linux-maint config [--json] [--sources] [--lint]"
          exit 0;;
        *) echo "Unknown config flag: $1" >&2; exit 2;;
      esac
    done

    CFG_DIR="${LM_CFG_DIR:-/etc/linux_maint}"
    main_conf="$CFG_DIR/linux-maint.conf"
    conf_d="$CFG_DIR/conf.d"
    conf_files=()
    [[ -f "$main_conf" ]] && conf_files+=("$main_conf")
    if [[ -d "$conf_d" ]]; then
      while IFS= read -r f; do
        [[ -f "$f" ]] && conf_files+=("$f")
      done < <(find "$conf_d" -maxdepth 1 -type f -name '*.conf' 2>/dev/null | sort)
    fi

    if [[ "${#conf_files[@]}" -eq 0 ]]; then
      echo "No config files found in $CFG_DIR"
      echo "Hint: sudo linux-maint init"
      exit 1
    fi

    CFG_DIR="$CFG_DIR" CFG_SOURCES="$CFG_SOURCES" CFG_JSON="$CFG_JSON" CFG_LINT="$CFG_LINT" python3 - "${conf_files[@]}" <<'PY'
import json, os, re, shlex, subprocess, sys

cfg_dir = os.environ.get("CFG_DIR", "/etc/linux_maint")
show_sources = os.environ.get("CFG_SOURCES", "0") == "1"
json_mode = os.environ.get("CFG_JSON", "0") == "1"
lint_mode = os.environ.get("CFG_LINT", "0") == "1"
files = sys.argv[1:]

def extract_keys(paths):
    keys = []
    seen = set()
    for p in paths:
        try:
            with open(p, "r", encoding="utf-8", errors="ignore") as f:
                for raw in f:
                    line = raw.strip()
                    if not line or line.startswith("#"):
                        continue
                    m = re.match(r"^([A-Za-z_][A-Za-z0-9_]*)\s*=", line)
                    if not m:
                        continue
                    k = m.group(1)
                    if k not in seen:
                        seen.add(k)
                        keys.append(k)
        except FileNotFoundError:
            continue
    return keys

def lint(paths):
    invalid = []
    seen = {}
    for p in paths:
        try:
            with open(p, "r", encoding="utf-8", errors="ignore") as f:
                for i, raw in enumerate(f, start=1):
                    line = raw.strip()
                    if not line or line.startswith("#"):
                        continue
                    if line.startswith("export "):
                        line = line[len("export "):].lstrip()
                    m = re.match(r"^([A-Za-z_][A-Za-z0-9_]*)\s*=", line)
                    if not m:
                        invalid.append((p, i, raw.rstrip()))
                        continue
                    k = m.group(1)
                    seen.setdefault(k, []).append((p, i))
        except FileNotFoundError:
            continue
    duplicates = {k: v for k, v in seen.items() if len(v) > 1}
    return invalid, duplicates

if lint_mode:
    invalid, duplicates = lint(files)
    print("=== linux-maint config lint ===")
    print(f"cfg_dir={cfg_dir}")
    if invalid:
        print("\ninvalid lines:")
        for p, i, line in invalid[:50]:
            print(f"- {p}:{i}: {line}")
    else:
        print("\ninvalid lines: none")
    if duplicates:
        print("\nduplicate keys:")
        for k, locs in sorted(duplicates.items()):
            loc_str = ", ".join(f"{p}:{i}" for p, i in locs[:6])
            print(f"- {k}: {loc_str}")
    else:
        print("\nduplicate keys: none")
    if invalid:
        sys.exit(1)
    sys.exit(0)

keys = extract_keys(files)
if not keys:
    print(f"No config keys found in {cfg_dir}")
    sys.exit(1)

src_cmd = "set -a; " + " ".join(f". {shlex.quote(p)};" for p in files) + " env"
proc = subprocess.run(["/bin/bash", "-lc", src_cmd], capture_output=True, text=True)
env = {}
if proc.returncode == 0:
    for line in proc.stdout.splitlines():
        if "=" not in line:
            continue
        k, v = line.split("=", 1)
        env[k] = v
else:
    msg = proc.stderr.strip() or "failed to source config"
    if json_mode:
        print(json.dumps({"error": msg, "cfg_dir": cfg_dir, "sources": files}, indent=2, sort_keys=True))
    else:
        print(f"ERROR: {msg}")
        print("Hint: run 'sudo linux-maint config'")
    sys.exit(1)

values = {k: env.get(k, "") for k in keys}

if json_mode:
    out = {
        "cfg_dir": cfg_dir,
        "sources": files,
        "values": values,
    }
    print(json.dumps(out, indent=2, sort_keys=True))
    sys.exit(0)

print("=== linux-maint config (effective) ===")
print(f"cfg_dir={cfg_dir}")
if show_sources:
    print("sources:")
    for p in files:
        print(f"- {p}")
print("")
width = max(len(k) for k in keys)
print(f"{'KEY':<{width}} VALUE")
for k in keys:
    print(f"{k:<{width}} {values.get(k,'')}")
PY
    ;;

  version)
    if [[ -f "$SHARE/BUILD_INFO" ]]; then
      cat "$SHARE/BUILD_INFO"
    else
      echo "BUILD_INFO not found at $SHARE/BUILD_INFO"
      exit 1
    fi
    ;;

  preflight)
    if [[ "$MODE" == "installed" ]]; then
      need_root_for preflight
    fi
    exec bash "$preflight"
    ;;

  validate)
    if [[ "$MODE" == "installed" ]]; then
      need_root_for validate
    fi
    exec bash "$validate"
    ;;

  check)
    if [[ "$MODE" == "installed" ]]; then
      need_root_for check
    fi

    echo "=== config_validate ==="
    bash "$validate" || true
    echo ""
    echo "=== preflight ==="
    bash "$preflight" || true
    echo ""

    cfg_dir="/etc/linux_maint"
    if [[ "$MODE" == "repo" ]]; then
      cfg_dir="${LM_CFG_DIR:-$REPO_ROOT/.etc_linux_maint}"
      mkdir -p "$cfg_dir" 2>/dev/null || true
    fi
    expected_skips "$cfg_dir"
    ;;

  history)
    if [[ "$MODE" == "installed" ]]; then
      need_root_for history
    fi

    LAST_N=10
    HISTORY_JSON=0
    HISTORY_TABLE=0
    HISTORY_COLOR=1
    HISTORY_COMPACT=0
    while [[ $# -gt 0 ]]; do
      case "$1" in
        --last) LAST_N="$2"; shift 2;;
        --json) HISTORY_JSON=1; shift 1;;
        --table) HISTORY_TABLE=1; shift 1;;
        --no-color) HISTORY_COLOR=0; shift 1;;
        --compact) HISTORY_COMPACT=1; shift 1;;
        -h|--help)
          echo "Usage: linux-maint history [--last N] [--json] [--table] [--no-color] [--compact]"
          exit 0;;
        *) echo "Unknown history flag: $1" >&2; exit 2;;
      esac
    done
    [[ -n "${NO_COLOR:-}" || -n "${LM_NO_COLOR:-}" ]] && HISTORY_COLOR=0
    color_enabled || HISTORY_COLOR=0

    if [[ ! "$LAST_N" =~ ^[0-9]+$ ]] || (( LAST_N <= 0 )); then
      echo "ERROR: --last must be a positive integer" >&2
      exit 2
    fi

    if [[ "$MODE" == "repo" ]]; then
      state_dir="${LM_STATE_DIR:-$REPO_LOG_DIR}"
    else
      state_dir="${LM_STATE_DIR:-/var/lib/linux_maint}"
    fi
    index_file="${LM_RUN_INDEX_FILE:-$state_dir/run_index.jsonl}"

    HISTORY_NOTE=""
    if [[ ! -f "$index_file" ]]; then
      for alt in /var/tmp/run_index.jsonl /var/tmp/linux_maint/run_index.jsonl /tmp/linux_maint/run_index.jsonl; do
        if [[ -f "$alt" ]]; then
          index_file="$alt"
          HISTORY_NOTE="note: using run_index from $alt"
          break
        fi
      done
    fi

    LM_COLOR="$HISTORY_COLOR" HISTORY_NOTE="$HISTORY_NOTE" python3 - "$index_file" "$LAST_N" "$HISTORY_JSON" "$HISTORY_TABLE" "$HISTORY_COMPACT" <<'PY'
import json, os, sys
path, last_n, json_mode, table, compact = sys.argv[1:6]
last_n = int(last_n)
json_mode = json_mode == "1"
table = table == "1"
compact = compact == "1"
color = os.environ.get("LM_COLOR","1") == "1"
note = os.environ.get("HISTORY_NOTE","")

def c(s, code):
    if not color:
        return s
    return f"\033[{code}m{s}\033[0m"

def color_status(st, text=None):
    label = text if text is not None else st
    if st == "CRIT":
        return c(label, "1;31")
    if st == "WARN":
        return c(label, "1;33")
    if st == "OK":
        return c(label, "1;32")
    if st == "UNKNOWN":
        return c(label, "1;35")
    if st == "SKIP":
        return c(label, "1;36")
    return label

if not os.path.exists(path):
    print(f"No run index found: {path}")
    print("Hints:")
    print("- Run: sudo linux-maint run")
    print("- Or set LM_RUN_INDEX_FILE when invoking the wrapper")
    sys.exit(1)

rows=[]
with open(path, "r", encoding="utf-8", errors="ignore") as f:
    for line in f:
        line=line.strip()
        if not line:
            continue
        try:
            rows.append(json.loads(line))
        except Exception:
            continue

rows = rows[-last_n:]
if json_mode:
    print(json.dumps({"runs": rows}, indent=2, sort_keys=True))
    raise SystemExit(0)

if compact:
    if rows:
        r = rows[-1]
        hosts = r.get("hosts",{}) or {}
        overall = r.get("overall","UNKNOWN")
        ov = color_status(overall)
        print(f"last_run={r.get('timestamp','')} overall={ov} CRIT={hosts.get('crit',0)} WARN={hosts.get('warn',0)} UNKNOWN={hosts.get('unknown',0)} SKIP={hosts.get('skipped',0)} OK={hosts.get('ok',0)}")
    else:
        print("no runs")
    raise SystemExit(0)

if not rows:
    print("=== Last 0 runs (run_index) ===")
    print("No runs recorded yet.")
    print("Hint: run sudo linux-maint run")
    raise SystemExit(0)

print(f"=== Last {len(rows)} runs (run_index) ===")
if note:
    print(note)
if table:
    headers=("TIMESTAMP","OVERALL","EXIT_CODE","CRIT","WARN","UNKNOWN","SKIP","OK")
    table_rows=[]
    for r in rows:
        hosts = r.get("hosts",{}) or {}
        table_rows.append((
            r.get("timestamp",""),
            r.get("overall","UNKNOWN"),
            str(r.get("exit_code","")),
            str(hosts.get("crit",0)),
            str(hosts.get("warn",0)),
            str(hosts.get("unknown",0)),
            str(hosts.get("skipped",0)),
            str(hosts.get("ok",0)),
        ))
    w=[len(h) for h in headers]
    for row in table_rows:
        for i,v in enumerate(row):
            w[i]=max(w[i], len(v))
    def pad(s, width):
        return f"{s:<{width}}"
    print(" ".join(pad(headers[i], w[i]) for i in range(len(headers))))
    for row in table_rows:
        cells=[pad(row[i], w[i]) for i in range(len(headers))]
        overall=row[1]
        cells[1]=color_status(overall, cells[1])
        # Colorize count columns (crit/warn/unknown/skip/ok)
        if row[3] != "0":
            cells[3]=c(cells[3],"1;31")
        if row[4] != "0":
            cells[4]=c(cells[4],"1;33")
        if row[5] != "0":
            cells[5]=c(cells[5],"1;35")
        if row[6] != "0":
            cells[6]=c(cells[6],"1;36")
        if row[7] != "0":
            cells[7]=c(cells[7],"1;32")
        print(" ".join(cells))
else:
    for r in rows:
        ts = r.get("timestamp","")
        overall = r.get("overall","UNKNOWN")
        exit_code = r.get("exit_code","")
        hosts = r.get("hosts",{}) or {}
        counts = f"CRIT={hosts.get('crit',0)} WARN={hosts.get('warn',0)} UNKNOWN={hosts.get('unknown',0)} SKIP={hosts.get('skipped',0)} OK={hosts.get('ok',0)}"
        print(f"{ts} overall={color_status(overall)} exit_code={exit_code} {counts}")
PY
    ;;

  summary)
    if [[ "$MODE" == "installed" ]]; then
      need_root_for summary
    fi

    SUMMARY_COLOR=1
    while [[ $# -gt 0 ]]; do
      case "$1" in
        --no-color) SUMMARY_COLOR=0; shift 1;;
        -h|--help)
          echo "Usage: linux-maint summary [--no-color]"
          exit 0;;
        *) echo "Unknown summary flag: $1" >&2; exit 2;;
      esac
    done
    [[ -n "${NO_COLOR:-}" || -n "${LM_NO_COLOR:-}" ]] && SUMMARY_COLOR=0
    color_enabled || SUMMARY_COLOR=0

    tmp_status="$(mktemp -p "$TMPDIR" linux_maint_summary_status.XXXXXX.json)"
    "$0" status --json --problems 0 >"$tmp_status" 2>/dev/null || printf '{}' >"$tmp_status"

    LM_COLOR="$SUMMARY_COLOR" python3 - "$tmp_status" <<'PY'
import json, os, sys

path = sys.argv[1]
color = os.environ.get("LM_COLOR","1") == "1"

def c(s, code):
    if not color:
        return s
    return f"\033[{code}m{s}\033[0m"

def color_status(st, text=None):
    label = text if text is not None else st
    if st == "CRIT":
        return c(label,"1;31")
    if st == "WARN":
        return c(label,"1;33")
    if st == "OK":
        return c(label,"1;32")
    if st == "UNKNOWN":
        return c(label,"1;35")
    if st == "SKIP":
        return c(label,"1;36")
    return label

try:
    with open(path, "r", encoding="utf-8") as f:
        status = json.load(f)
except Exception:
    status = {}

last = status.get("last_status", {})
overall = last.get("overall", "UNKNOWN")
exit_code = last.get("exit_code", "3")
summary_file = status.get("summary_file","")
totals = status.get("totals", {})

ov = color_status(overall)

parts = [
    f"overall={ov}",
    f"exit_code={exit_code}",
]
for k in ["CRIT","WARN","UNKNOWN","SKIP","OK"]:
    v = totals.get(k,0)
    kv = f"{k}={v}"
    if v != 0:
        kv = color_status(k, kv)
    parts.append(kv)
if summary_file:
    parts.append(f"summary={summary_file}")

print(" ".join(parts))
PY
    rm -f "$tmp_status" 2>/dev/null || true
    ;;

  status)
    if [[ "$MODE" == "installed" ]]; then
      need_root_for status
    fi

    ONLY=""
    TAIL_N=200
    VERBOSE=0
    QUIET=0
    PROB_N=20
    JSON=0
    LAST_N=0
    HOST_FILTER=""
    MONITOR_FILTER=""
    MATCH_MODE="contains"
    REASONS_N=0
    SINCE=""
    TABLE=0
    SUMMARY_ONLY=0
    SHOW_META=1


    while [[ $# -gt 0 ]]; do
      case "$1" in
        --only) ONLY="$2"; shift 2;;
        --tail) TAIL_N="$2"; shift 2;;
        --verbose) VERBOSE=1; shift 1;;
        --quiet) QUIET=1; shift 1;;
        --json) JSON=1; shift 1;;
        --no-color) LM_COLOR=0; shift 1;;
        --table) TABLE=1; shift 1;;
        --summary) SUMMARY_ONLY=1; shift 1;;
        --compact) SHOW_META=0; shift 1;;
        --host) HOST_FILTER="$2"; shift 2;;
        --monitor) MONITOR_FILTER="$2"; shift 2;;
        --match-mode) MATCH_MODE="$2"; shift 2;;
        --problems) PROB_N="$2"; shift 2;;
        --reasons) REASONS_N="$2"; shift 2;;
        --since) SINCE="$2"; shift 2;;
        --last) LAST_N="$2"; shift 2;;
        -h|--help)
          echo "Usage: linux-maint status [--only OK|WARN|CRIT|UNKNOWN|SKIP] [--host PATTERN] [--monitor PATTERN] [--match-mode contains|exact|regex] [--tail N] [--verbose] [--quiet] [--json] [--no-color] [--table] [--summary] [--compact] [--problems N (max 100)] [--reasons N (max 20)] [--since 15m|2h|1d|30s] [--last N]"
          exit 0;;
        *) echo "Unknown status flag: $1" >&2; exit 2;;
      esac
    done
    [[ -n "${NO_COLOR:-}" || -n "${LM_NO_COLOR:-}" ]] && LM_COLOR=0
    color_enabled || LM_COLOR=0

    if [[ "$SUMMARY_ONLY" -eq 1 ]]; then
      "$0" summary --no-color
      [[ "$TABLE" -eq 1 ]] || exit 0
      echo ""
    fi

    case "$MATCH_MODE" in
      contains|exact|regex) ;;
      *)
        echo "ERROR: invalid --match-mode '$MATCH_MODE' (use contains|exact|regex)" >&2
        exit 2
        ;;
    esac

    # Validate/cap PROB_N (default 20, max 100)
    if [[ ! "$PROB_N" =~ ^[0-9]+$ ]]; then
      PROB_N=20

    elif (( PROB_N > 100 )); then
      PROB_N=100
    elif (( PROB_N < 0 )); then
      PROB_N=0
    fi

    # Validate/cap REASONS_N (default 0=disabled, max 20)
    if [[ ! "$REASONS_N" =~ ^[0-9]+$ ]]; then
      REASONS_N=0
    elif (( REASONS_N > 20 )); then
      REASONS_N=20
    elif (( REASONS_N < 0 )); then
      REASONS_N=0
    fi


    # Validate --since duration (optional): <int><s|m|h|d>
    if [[ -n "$SINCE" && ! "$SINCE" =~ ^[0-9]+[smhd]$ ]]; then
      echo "ERROR: invalid --since '$SINCE' (use like 30s, 15m, 2h, 1d)" >&2
      exit 2
    fi

    # History mode: show last N wrapper runs (best-effort)
    if [[ "${LAST_N:-0}" -gt 0 ]]; then
      if [[ "$MODE" == "repo" ]]; then
        log_dir="$REPO_LOG_DIR"
      else
        log_dir="/var/log/health"
      fi
      echo "=== Last ${LAST_N} runs ==="
      # shellcheck disable=SC2012
      ls -1t "$log_dir"/full_health_monitor_summary_[0-9][0-9][0-9][0-9]-[0-9][0-9]-[0-9][0-9]_[0-9][0-9][0-9][0-9][0-9][0-9].log 2>/dev/null | head -n "$LAST_N" | while read -r f; do
        ts="$(basename "$f" | sed -E "s/^full_health_monitor_summary_([0-9-]+)_(\\d+)[.]log$/\1T\2/")"
        totals="$(awk '/^monitor=/{for(i=1;i<=NF;i++) if($i ~ /^status=/){split($i,a,"="); s=a[2]; c[s]++}} END{printf("CRIT=%d WARN=%d UNKNOWN=%d SKIP=%d OK=%d",c["CRIT"]+0,c["WARN"]+0,c["UNKNOWN"]+0,c["SKIP"]+0,c["OK"]+0)}' "$f" 2>/dev/null)"
        echo "$ts $totals file=$f"
      done
      exit 0
    fi

    if [[ "$JSON" -eq 1 ]]; then
      # JSON mode: emit a single JSON object and exit.
      status_file=""
      if [[ "$MODE" == "repo" ]]; then
        status_file="$REPO_STATUS_FILE"
      else
        status_file="/var/log/health/last_status_full"
      fi

      summary_file=""
      if [[ "$MODE" == "repo" ]]; then
        summary_file="$REPO_SUMMARY_LATEST"
        log_dir="$REPO_LOG_DIR"
      else
        summary_file="$INST_SUMMARY_LATEST"
        log_dir="/var/log/health"
      fi

      if [[ -n "$SINCE" ]]; then
        tmp_since="$(mktemp -p "$TMPDIR" linux_maint_status_since.XXXXXX.log)"
        _run_tmpfiles+=("$tmp_since")
        python3 - "$log_dir" "$SINCE" <<'PY' | while IFS= read -r f; do
import os, re, sys, time
log_dir, since = sys.argv[1:3]
m = re.match(r'^(\d+)([smhd])$', since)
if not m:
    sys.exit(2)
num = int(m.group(1))
unit = m.group(2)
mult = {'s':1, 'm':60, 'h':3600, 'd':86400}[unit]
cutoff = time.time() - (num * mult)
pat = re.compile(r'^full_health_monitor_summary_(\d{4}-\d{2}-\d{2})_(\d{6})\.log$')
rows=[]
try:
    names=os.listdir(log_dir)
except FileNotFoundError:
    names=[]
for name in names:
    m2 = pat.match(name)
    if not m2:
        continue
    ts=f"{m2.group(1)} {m2.group(2)}"
    try:
        epoch=time.mktime(time.strptime(ts, "%Y-%m-%d %H%M%S"))
    except Exception:
        continue
    if epoch >= cutoff:
        rows.append((epoch, os.path.join(log_dir, name)))
rows.sort()
for _,p in rows:
    print(p)
PY
          [[ -f "$f" ]] && cat "$f" >> "$tmp_since"
        done
        summary_file="$tmp_since"
      fi

      python3 - "$MODE" "$status_file" "$summary_file" "$ONLY" "$PROB_N" "$HOST_FILTER" "$MONITOR_FILTER" "$MATCH_MODE" "$REASONS_N" <<'PY'
import json, os, re, sys

mode, status_path, summary_path, only, limit, host_filter, monitor_filter, match_mode, reasons_limit = sys.argv[1:10]
limit=int(limit)
reasons_limit=int(reasons_limit)

def read_kv(path):
    d={}
    if not path or not os.path.exists(path):
        return d
    with open(path,'r',encoding='utf-8',errors='ignore') as f:
        for line in f:
            line=line.strip()
            if not line or '=' not in line:
                continue
            k,v=line.split('=',1)
            d[k]=v
    return d

def get_kv(line, key):
    m=re.search(rf"\b{re.escape(key)}=([^ ]+)", line)
    return m.group(1) if m else None

def matched(value, flt):
    if not flt:
        return True
    if match_mode == 'contains':
        return flt in value
    if match_mode == 'exact':
        return value == flt
    try:
        return re.search(flt, value) is not None
    except re.error as e:
        print(f"ERROR: invalid regex for --match-mode regex: {e}", file=sys.stderr)
        sys.exit(2)

status=read_kv(status_path)

counts={}
problems=[]
reason_counts={}
runtime_warnings=[]
if summary_path and os.path.exists(summary_path):
    with open(summary_path,'r',encoding='utf-8',errors='ignore') as f:
        for line in f:
            line=line.strip()
            if not line.startswith('monitor='):
                continue
            st=get_kv(line,'status') or 'UNKNOWN'
            host=get_kv(line,'host') or ''
            monitor=get_kv(line,'monitor') or ''
            if only and st != only:
                continue
            if not matched(host, host_filter):
                continue
            if not matched(monitor, monitor_filter):
                continue
            counts[st]=counts.get(st,0)+1
            if monitor == 'runtime_guard':
                warn_entry={'status':st,'monitor':monitor,'host':host}
                for key in ('reason','target_monitor','runtime_ms','threshold_ms'):
                    val=get_kv(line,key)
                    if val is not None:
                        warn_entry[key]=val
                runtime_warnings.append(warn_entry)
            if st!='OK':
                mon=monitor or 'unknown_monitor'
                reason=get_kv(line,'reason')
                entry={'status':st,'monitor':mon,'host':host}
                if reason:
                    entry['reason']=reason
                    reason_counts[reason]=reason_counts.get(reason,0)+1
                problems.append(entry)

sev_order={'CRIT':0,'WARN':1,'UNKNOWN':2,'SKIP':3,'OK':4}
problems.sort(key=lambda e: sev_order.get(e.get('status','UNKNOWN'), 9))

out={
    'mode': mode,
    'status_json_contract_version': 1,
    'last_status': status,
    'summary_file': summary_path if summary_path and os.path.exists(summary_path) else None,
    'totals': {k: counts.get(k,0) for k in ['CRIT','WARN','UNKNOWN','SKIP','OK']},
    'problems': problems[:limit],
    'runtime_warnings': runtime_warnings,
}
if reasons_limit > 0:
    rollup=sorted(reason_counts.items(), key=lambda kv: (-kv[1], kv[0]))
    out['reason_rollup']=[{'reason':r,'count':c} for r,c in rollup[:reasons_limit]]
print(json.dumps(out, indent=2, sort_keys=True))
PY
      exit 0
    fi
    if [[ "$QUIET" -eq 0 && "$SHOW_META" -eq 1 ]]; then

      # Banner: overall health (best-effort)
      if [[ "$MODE" == "repo" ]]; then
        status_file="$REPO_STATUS_FILE"
      else
        status_file="/var/log/health/last_status_full"
      fi
      if [[ -f "$status_file" ]]; then
        overall_val="$(awk -F= '$1=="overall"{print $2}' "$status_file" 2>/dev/null || true)"
        exit_val="$(awk -F= '$1=="exit_code"{print $2}' "$status_file" 2>/dev/null || true)"
        banner="health=${overall_val:-UNKNOWN} exit_code=${exit_val:-3}"
        case "$overall_val" in
          CRIT) banner="${C_RED}${banner}${C_RESET}" ;;
          WARN) banner="${C_YELLOW}${banner}${C_RESET}" ;;
          OK)   banner="${C_GREEN}${banner}${C_RESET}" ;;
        esac
        echo "=== linux-maint status === $banner"
      else
        echo "=== linux-maint status ==="
      fi

    if [[ "$MODE" == "repo" ]]; then
      echo "=== Mode ==="
      echo "repo"
      echo "repo_root: $REPO_ROOT"
      echo "linux_maint_lib: ${LINUX_MAINT_LIB:-}"
      echo "logs: $REPO_LOG_DIR"
      echo ""; echo "=== Last run status ==="
      if [[ -f "$REPO_STATUS_FILE" ]]; then
        cat "$REPO_STATUS_FILE"
      else
        echo "No status file: $REPO_STATUS_FILE"
      fi
    else
      status_file="/var/log/health/last_status_full"
      echo "=== Mode ==="
      echo "installed"
      echo "prefix: $PREFIX"
      echo ""; echo "=== Installed paths ==="
      echo "wrapper: $SBIN/run_full_health_monitor.sh"
      echo "libexec: $LIBEXEC"
      echo "build_info: $SHARE/BUILD_INFO"
      [[ -f "$SHARE/BUILD_INFO" ]] && { echo ""; cat "$SHARE/BUILD_INFO"; }
      echo ""; echo "=== Last run status ==="
      if [[ -f "$status_file" ]]; then
        cat "$status_file"
      else
        echo "No status file: $status_file"
      fi
    fi

    fi

    # Default: compact summary (hide OK). Use --verbose to show full tail of summary file.
    VERBOSE=${VERBOSE:-0}

    if [[ "$QUIET" -eq 0 ]]; then
      echo ""; echo "=== Summary (compact) ==="
    fi
    summary_file=""
    if [[ "$MODE" == "repo" ]]; then
      summary_file="$REPO_SUMMARY_LATEST"
      log_dir="$REPO_LOG_DIR"
    else
      summary_file="$INST_SUMMARY_LATEST"
      log_dir="/var/log/health"
    fi

    if [[ -n "$SINCE" ]]; then
      tmp_since="$(mktemp -p "$TMPDIR" linux_maint_status_since.XXXXXX.log)"
      _run_tmpfiles+=("$tmp_since")
      python3 - "$log_dir" "$SINCE" <<'PY' | while IFS= read -r f; do
import os, re, sys, time
log_dir, since = sys.argv[1:3]
m = re.match(r'^(\d+)([smhd])$', since)
if not m:
    sys.exit(2)
num = int(m.group(1))
unit = m.group(2)
mult = {'s':1, 'm':60, 'h':3600, 'd':86400}[unit]
cutoff = time.time() - (num * mult)
pat = re.compile(r'^full_health_monitor_summary_(\d{4}-\d{2}-\d{2})_(\d{6})\.log$')
rows=[]
try:
    names=os.listdir(log_dir)
except FileNotFoundError:
    names=[]
for name in names:
    m2 = pat.match(name)
    if not m2:
        continue
    ts=f"{m2.group(1)} {m2.group(2)}"
    try:
        epoch=time.mktime(time.strptime(ts, "%Y-%m-%d %H%M%S"))
    except Exception:
        continue
    if epoch >= cutoff:
        rows.append((epoch, os.path.join(log_dir, name)))
rows.sort()
for _,p in rows:
    print(p)
PY
        [[ -f "$f" ]] && cat "$f" >> "$tmp_since"
      done
      summary_file="$tmp_since"
    fi

    if [[ -f "$summary_file" ]]; then
      if [[ "$VERBOSE" -eq 1 ]]; then
        echo "(verbose; last $TAIL_N lines from: $summary_file)"
        if [[ -n "$ONLY" || -n "$HOST_FILTER" || -n "$MONITOR_FILTER" ]]; then
          python3 - "$summary_file" "$TAIL_N" "$ONLY" "$HOST_FILTER" "$MONITOR_FILTER" "$MATCH_MODE" <<'PY'
import re, sys

path, tail_n, only, host_filter, monitor_filter, match_mode = sys.argv[1:7]
tail_n=int(tail_n)

def get_kv(line, key):
    m=re.search(rf"\b{re.escape(key)}=([^ ]+)", line)
    return m.group(1) if m else None

def matched(value, flt):
    if not flt:
        return True
    if match_mode == 'contains':
        return flt in value
    if match_mode == 'exact':
        return value == flt
    try:
        return re.search(flt, value) is not None
    except re.error as e:
        print(f"ERROR: invalid regex for --match-mode regex: {e}", file=sys.stderr)
        sys.exit(2)

matched=[]
with open(path, 'r', encoding='utf-8', errors='ignore') as f:
    for line in f:
        line=line.strip()
        if not line.startswith('monitor='):
            continue
        st=get_kv(line,'status') or 'UNKNOWN'
        host=get_kv(line,'host') or ''
        monitor=get_kv(line,'monitor') or ''
        if only and st != only:
            continue
        if not matched(host, host_filter):
            continue
        if not matched(monitor, monitor_filter):
            continue
        matched.append(line)

for line in matched[-tail_n:]:
    print(line)
PY
        else
          tail -n "$TAIL_N" "$summary_file" || true
        fi
      else
        [[ "$QUIET" -eq 0 ]] && echo "(from: $summary_file)"
      LM_COLOR="$LM_COLOR" python3 - "$summary_file" "$ONLY" "$PROB_N" "$HOST_FILTER" "$MONITOR_FILTER" "$MATCH_MODE" "$REASONS_N" "$TABLE" <<'PY'
import re, sys, os
path, only, limit, host_filter, monitor_filter, match_mode, reasons_limit, table = sys.argv[1:9]
limit=int(limit)
reasons_limit=int(reasons_limit)
color = os.environ.get("LM_COLOR","1") == "1"
table = table == "1"

def c(s, code):
    if not color:
        return s
    return f"\033[{code}m{s}\033[0m"

# Example line:
# monitor=config_validate host=localhost status=WARN node=localhost warn=1 crit=0 reason=...

def get_kv(line, key):
    m=re.search(rf"\b{re.escape(key)}=([^ ]+)", line)
    return m.group(1) if m else None

def matched(value, flt):
    if not flt:
        return True
    if match_mode == 'contains':
        return flt in value
    if match_mode == 'exact':
        return value == flt
    try:
        return re.search(flt, value) is not None
    except re.error as e:
        print(f"ERROR: invalid regex for --match-mode regex: {e}", file=sys.stderr)
        sys.exit(2)

counts={}
problems=[]
reason_counts={}
with open(path, 'r', encoding='utf-8', errors='ignore') as f:
    for line in f:
        line=line.strip()
        if not line:
            continue
        st=get_kv(line,'status') or 'UNKNOWN'
        host=get_kv(line,'host') or ''
        monitor=get_kv(line,'monitor') or ''
        if only and st != only:
            continue
        if not matched(host, host_filter):
            continue
        if not matched(monitor, monitor_filter):
            continue
        counts[st]=counts.get(st,0)+1
        if st == 'OK':
            continue
        mon=monitor or 'unknown_monitor'
        reason=get_kv(line,'reason')
        problems.append({
            "status": st,
            "monitor": mon,
            "host": host,
            "reason": reason or "",
        })
        if reason:
            reason_counts[reason]=reason_counts.get(reason,0)+1

def color_status(st, text=None):
    label = text if text is not None else st
    if st=="CRIT":
        return c(label,'1;31')
    if st=="WARN":
        return c(label,'1;33')
    if st=="OK":
        return c(label,'1;32')
    if st=="UNKNOWN":
        return c(label,'1;35')
    if st=="SKIP":
        return c(label,'1;36')
    return label

order=['CRIT','WARN','UNKNOWN','SKIP','OK']
if table:
    print("totals:")
    maxk=max(len(k) for k in order)
    maxv=max(len(str(counts.get(k,0))) for k in order)
    print(f"  {'STATUS':<{maxk}} {'COUNT':<{maxv}}")
    for k in order:
        v=str(counts.get(k,0))
        label = color_status(k, f"{k:<{maxk}}")
        count = f"{v:<{maxv}}"
        if v != "0":
            count = color_status(k, count)
        print(f"  {label} {count}")
else:
    parts=[]
    for k in order:
        v=str(counts.get(k,0))
        kv=f"{k}={v}"
        if v != "0":
            kv=color_status(k, kv)
        parts.append(kv)
    print('totals: ' + ' '.join(parts))

if problems:
    sev_order={'CRIT':0,'WARN':1,'UNKNOWN':2,'SKIP':3}
    problems.sort(key=lambda r: sev_order.get(r["status"], 9))
    show_n=min(limit, len(problems))
    print(f"\nproblems (top {show_n}):")
    if table:
        rows=[(p["status"], p["monitor"], p["host"], p["reason"]) for p in problems[:limit]]
        headers=("STATUS","MONITOR","HOST","REASON")
        w=[len(h) for h in headers]
        for r in rows:
            for i,v in enumerate(r):
                w[i]=max(w[i], len(str(v)))
        print(f"{headers[0]:<{w[0]}} {headers[1]:<{w[1]}} {headers[2]:<{w[2]}} {headers[3]}")
        for st,mon,host,reason in rows:
            s_pad=color_status(st, f"{st:<{w[0]}}")
            print(f"{s_pad} {mon:<{w[1]}} {host:<{w[2]}} {reason}")
    else:
        for p in problems[:limit]:
            st=color_status(p["status"])
            line=f"{st} {p['monitor']} host={p['host']}"
            if p["reason"]:
                line += f" reason={p['reason']}"
            print(line)
    print("\ntip: run 'linux-maint doctor' for fix suggestions")
else:
    print('\nproblems: none (all OK)')

if reasons_limit > 0:
    print(f"\nreasons (top {reasons_limit}):")
    if reason_counts:
        rollup=sorted(reason_counts.items(), key=lambda kv: (-kv[1], kv[0]))
        for reason, count in rollup[:reasons_limit]:
            print(f"{reason}={count}")
        hints_map = {
            "permission_denied": "Run with sudo or fix permissions for logs/state/config.",
            "missing_optional_cmd": "Install the optional dependency listed in the monitor output.",
            "missing_dependency": "Install the required dependency on the runner/host.",
            "kernel_log_unreadable": "Check journal/dmesg permissions and ensure kernel logs are readable.",
            "collect_failed": "Inventory export failed; verify /var/log/inventory and required tools (ip, lsblk, lscpu).",
            "ports_baseline_changed": "Review listening port changes and update the baseline if expected.",
            "config_drift_changed": "Review config changes and update the baseline if intended.",
            "user_anomalies": "Review new/removed users and sudoers changes.",
            "ntp_drift_high": "Check NTP/chrony sync and clock drift.",
            "ntp_not_synced": "Check NTP/chrony sync.",
            "missing_log_source": "Ensure journald/syslog is available and readable.",
            "security_updates_pending": "Apply security updates via your package manager.",
            "updates_pending": "Apply pending package updates.",
            "baseline_missing": "Create a baseline via linux-maint baseline.",
            "baseline_created": "Baseline created; rerun to compare changes.",
            "baseline_updated": "Baseline updated; rerun to check for drift.",
            "baseline_exists": "Baseline already exists; use --update if you want to overwrite it.",
            "baseline_collect_failed": "Baseline collection failed; check permissions/SSH and retry.",
            "timer_missing": "Install/enable linux-maint.timer if you want scheduled runs.",
            "timer_disabled": "Enable linux-maint.timer (systemctl enable --now linux-maint.timer).",
            "timer_inactive": "Start linux-maint.timer (systemctl start linux-maint.timer).",
            "ssh_unreachable": "Verify SSH connectivity and credentials for the target host.",
            "stale_run": "Check timers/cron; last run appears too old.",
        }
        hints=[]
        for reason, _count in rollup[:reasons_limit]:
            if reason in hints_map and reason not in hints:
                hints.append(reason)
        if hints:
            print("\nhints:")
            for reason in hints[:5]:
                print(f"- {reason}: {hints_map[reason]}")
    else:
        print('none')
PY
      fi
    else
      echo "No summary file: $summary_file"
      echo "Likely causes:"
      echo "- The wrapper has not been run yet"
      echo "- LOG_DIR/SUMMARY_DIR points elsewhere"
      echo "- Permission issue writing to /var/log/health (try sudo)"
      echo "Next steps:"
      echo "- Run: sudo linux-maint run"
      echo "- Check logs: sudo linux-maint logs 200"
      echo "- Diagnose: sudo linux-maint doctor"
      echo "Falling back to grepping latest wrapper log"
      log="/var/log/health/full_health_monitor_latest.log"
      [[ "$MODE" == "repo" ]] && log="$REPO_LATEST_LOG"
      if [[ -f "$log" ]]; then
        grep -E " status=(WARN|CRIT|UNKNOWN)|SKIP:|SUMMARY_RESULT|FINAL_STATUS_SUMMARY|^\\[.*\\] monitor=" "$log" | tail -n 120 || true
      else
        echo "No log found at: $log"
        echo "Hint: run linux-maint run to generate logs"
      fi
    fi
    ;;


  trend)
    if [[ "$MODE" == "installed" ]]; then
      need_root_for trend
    fi

    LAST_N=10
    JSON=0
    while [[ $# -gt 0 ]]; do
      case "$1" in
        --last) LAST_N="$2"; shift 2 ;;
        --json) JSON=1; shift 1 ;;
        -h|--help)
          echo "Usage: linux-maint trend [--last N] [--json]"
          exit 0 ;;
        *) echo "Unknown trend flag: $1" >&2; exit 2 ;;
      esac
    done

    if [[ ! "$LAST_N" =~ ^[0-9]+$ ]] || (( LAST_N <= 0 )); then
      echo "ERROR: --last must be a positive integer" >&2
      exit 2
    fi

    if [[ "$MODE" == "repo" ]]; then
      log_dir="$REPO_LOG_DIR"
    else
      log_dir="/var/log/health"
    fi

    TREND_COLOR=0
    color_enabled && TREND_COLOR=1
    LM_COLOR="$TREND_COLOR" python3 - "$log_dir" "$LAST_N" "$JSON" <<'PY'
import glob, json, os, re, sys

log_dir, last_n, json_mode = sys.argv[1:4]
last_n=int(last_n)
json_mode = json_mode == '1'
color = os.environ.get("LM_COLOR","1") == "1"

def c(s, code):
    if not color:
        return s
    return f"\033[{code}m{s}\033[0m"

def color_kv(k, v):
    text = f"{k}={v}"
    if not color or int(v) == 0:
        return text
    if k == "CRIT":
        return c(text, "1;31")
    if k == "WARN":
        return c(text, "1;33")
    if k == "UNKNOWN":
        return c(text, "1;35")
    if k == "SKIP":
        return c(text, "1;36")
    if k == "OK":
        return c(text, "1;32")
    return text

pat = os.path.join(log_dir, 'full_health_monitor_summary_[0-9][0-9][0-9][0-9]-[0-9][0-9]-[0-9][0-9]_[0-9][0-9][0-9][0-9][0-9][0-9].log')
files=sorted(glob.glob(pat), reverse=True)[:last_n]

if not files:
    if json_mode:
        print(json.dumps({'runs':[], 'totals':{'CRIT':0,'WARN':0,'UNKNOWN':0,'SKIP':0,'OK':0}, 'reasons':[]}, indent=2, sort_keys=True))
    else:
        print(f'No summary artifacts found in: {log_dir}')
    sys.exit(0)

order=['CRIT','WARN','UNKNOWN','SKIP','OK']
overall={k:0 for k in order}
reason_counts={}
runs=[]

def get_kv(line, key):
    m=re.search(rf"\b{re.escape(key)}=([^ ]+)", line)
    return m.group(1) if m else None

for fp in files:
    rc={k:0 for k in order}
    with open(fp,'r',encoding='utf-8',errors='ignore') as f:
        for line in f:
            line=line.strip()
            if not line.startswith('monitor='):
                continue
            st=get_kv(line,'status') or 'UNKNOWN'
            if st not in rc:
                st='UNKNOWN'
            rc[st]+=1
            overall[st]=overall.get(st,0)+1
            if st!='OK':
                reason=get_kv(line,'reason')
                if reason:
                    reason_counts[reason]=reason_counts.get(reason,0)+1
    runs.append({'file': fp, 'totals': rc})

rollup=sorted(reason_counts.items(), key=lambda kv: (-kv[1], kv[0]))
if json_mode:
    out={'runs':runs, 'totals':overall, 'reasons':[{'reason':r,'count':c} for r,c in rollup]}
    print(json.dumps(out, indent=2, sort_keys=True))
else:
    print(f'trend_runs={len(runs)} source_dir={log_dir}')
    print('totals: ' + ' '.join(color_kv(k, overall.get(k,0)) for k in order))
    print('')
    print('runs:')
    for r in runs:
      print(f"- {os.path.basename(r['file'])}: " + ' '.join(color_kv(k, r['totals'].get(k,0)) for k in order))
    print('')
    print('reasons:')
    if rollup:
      for reason, count in rollup[:20]:
          print(f"{reason}={count}")
    else:
      print('none')
PY
    ;;

  runtimes)
    if [[ "$MODE" == "installed" ]]; then
      need_root_for runtimes
    fi

    RT_JSON=0
    RT_LAST=1
    while [[ $# -gt 0 ]]; do
      case "$1" in
        --json) RT_JSON=1; shift ;;
        --last) RT_LAST="$2"; shift 2 ;;
        -h|--help)
          echo "Usage: linux-maint runtimes [--last N] [--json]"
          exit 0;;
        *) echo "Unknown runtimes flag: $1" >&2; exit 2;;
      esac
    done

    if [[ ! "$RT_LAST" =~ ^[0-9]+$ ]] || [[ "$RT_LAST" -lt 1 ]]; then
      echo "ERROR: invalid --last '$RT_LAST' (use positive integer)" >&2
      exit 2
    fi

    if [[ "$MODE" == "repo" ]]; then
      log_dir="${LOG_DIR:-$REPO_LOG_DIR}"
    else
      log_dir="${LOG_DIR:-/var/log/health}"
    fi

    # Gather last N wrapper logs
    mapfile -t rt_files < <(find "$log_dir" -maxdepth 1 -type f -name 'full_health_monitor_[0-9][0-9][0-9][0-9]-[0-9][0-9]-[0-9][0-9]_[0-9][0-9][0-9][0-9][0-9][0-9].log' -printf '%T@ %p\n' 2>/dev/null | sort -nr | head -n "$RT_LAST" | awk '{print $2}')

    if [[ "${#rt_files[@]}" -eq 0 ]]; then
      echo "No wrapper logs found in $log_dir" >&2
      exit 1
    fi

    if [[ "$RT_JSON" -eq 1 ]]; then
      python3 - "$RT_LAST" "${rt_files[@]}" <<'PY'
import json, sys, re

rt_last = int(sys.argv[1])
files = sys.argv[2:]
rows = []
pat = re.compile(r'RUNTIME\s+monitor=([^ ]+)\s+ms=([0-9]+)')

for f in files:
    try:
        with open(f, 'r', encoding='utf-8', errors='ignore') as fh:
            for line in fh:
                m = pat.search(line)
                if m:
                    rows.append({"monitor": m.group(1), "ms": int(m.group(2))})
    except FileNotFoundError:
        continue

# Sort desc by ms
rows.sort(key=lambda r: (-r["ms"], r["monitor"]))

print(json.dumps({"files": files, "rows": rows}, sort_keys=True))
PY
      exit 0
    fi

    echo "=== linux-maint runtimes ==="
    echo "files=${#rt_files[@]}"
    echo "log_dir=$log_dir"
    awk '
      /RUNTIME monitor=/ {
        for (i=1; i<=NF; i++) {
          if ($i ~ /^monitor=/) { split($i,a,"="); mon=a[2]; }
          if ($i ~ /^ms=/) { split($i,b,"="); ms=b[2]; }
        }
        if (mon != "" && ms != "") {
          print ms, mon
        }
        mon=""; ms=""
      }
    ' "${rt_files[@]}" | sort -rn | awk '{print "monitor="$2" ms="$1}'
    ;;

  export)
    if [[ "$MODE" == "installed" ]]; then
      need_root_for export
    fi

    EXPORT_JSON=0
    EXPORT_CSV=0
    case "${1:-}" in
      --json) EXPORT_JSON=1; shift ;;
      --csv) EXPORT_CSV=1; shift ;;
      -h|--help) EXPORT_JSON=0 ;;
      "") ;;
      *) echo "Unknown export flag: $1" >&2; exit 2 ;;
    esac

    if [[ "$EXPORT_JSON" -eq 0 && "$EXPORT_CSV" -eq 0 ]]; then
      echo "Usage: linux-maint export --json|--csv" >&2
      exit 2
    fi
    if [[ "$EXPORT_JSON" -eq 1 && "$EXPORT_CSV" -eq 1 ]]; then
      echo "ERROR: choose only one export format (--json or --csv)" >&2
      exit 2
    fi

    if [[ "$MODE" == "repo" ]]; then
      summary_file="$REPO_SUMMARY_LATEST"
      status_file="$REPO_STATUS_FILE"
      log_file="$REPO_LATEST_LOG"
      summary_json="$REPO_LOG_DIR/full_health_monitor_summary_latest.json"
    else
      summary_file="$INST_SUMMARY_LATEST"
      status_file="/var/log/health/last_status_full"
      log_file="/var/log/health/full_health_monitor_latest.log"
      summary_json="/var/log/health/full_health_monitor_summary_latest.json"
    fi

    python3 - "$MODE" "$EXPORT_CSV" "$status_file" "$summary_file" "$summary_json" "$log_file" <<'PY'
import json, os, re, sys

mode = sys.argv[1]
csv_mode = sys.argv[2] == "1"
status_path, summary_path, summary_json_path, log_path = sys.argv[3:7]

def read_kv(path):
    d={}
    if not path or not os.path.exists(path):
        return d
    with open(path,'r',encoding='utf-8',errors='ignore') as f:
        for line in f:
            line=line.strip()
            if not line or '=' not in line:
                continue
            k,v=line.split('=',1)
            d[k]=v
    return d

def parse_kv_line(line):
    d={}
    for p in line.strip().split():
        if '=' in p:
            k,v=p.split('=',1)
            d[k]=v
    return d

def redact_value(val: str) -> str:
    lower = val.lower()
    secret_keys = (
        "password","passwd","token","api_key","apikey","secret",
        "access_key","private_key","session","session_id","id_token",
        "refresh_token","x_auth_token"
    )
    if any(k in lower for k in secret_keys):
        return "REDACTED"
    if val.count(".") == 2 and all(len(p) >= 12 for p in val.split(".")):
        return "REDACTED_JWT"
    return val

def redact_kv_map(row):
    out = {}
    for k,v in row.items():
        kl = k.lower()
        if any(x in kl for x in ("password","passwd","token","api_key","apikey","secret","access_key","private_key","session","id_token","refresh_token","x_auth_token")):
            out[k] = "REDACTED"
        else:
            out[k] = redact_value(v)
    return out

def read_rows():
    if summary_json_path and os.path.exists(summary_json_path):
        try:
            with open(summary_json_path,'r',encoding='utf-8',errors='ignore') as f:
                payload=json.load(f)
            if isinstance(payload, dict) and 'rows' in payload:
                return payload.get('rows',[]), payload.get('meta',{})
            if isinstance(payload, list):
                return payload, {}
        except Exception:
            pass
    rows=[]
    if summary_path and os.path.exists(summary_path):
        with open(summary_path,'r',encoding='utf-8',errors='ignore') as f:
            for line in f:
                if line.startswith('monitor='):
                    rows.append(parse_kv_line(line))
    return rows, {}

def parse_log_summary(log_path):
    summary_result=None
    summary_hosts=None
    if not log_path or not os.path.exists(log_path):
        return summary_result, summary_hosts
    with open(log_path,'r',encoding='utf-8',errors='ignore') as f:
        for line in f:
            if 'SUMMARY_RESULT' in line:
                m=re.search(r'SUMMARY_RESULT\\s+(.*)$', line)
                if m:
                    summary_result=parse_kv_line(m.group(1))
            elif 'SUMMARY_HOSTS' in line:
                m=re.search(r'SUMMARY_HOSTS\\s+(.*)$', line)
                if m:
                    summary_hosts=parse_kv_line(m.group(1))
    return summary_result, summary_hosts

def worst_status(rows):
    order={'OK':0,'WARN':1,'CRIT':2,'UNKNOWN':3,'SKIP':3}
    worst='OK'
    for r in rows:
        st=r.get('status','UNKNOWN')
        if order.get(st,3) >= order.get(worst,0):
            worst=st
    return worst

def derive_hosts(rows):
    counts={'ok':0,'warn':0,'crit':0,'unknown':0,'skipped':0}
    for r in rows:
        st=(r.get('status') or 'UNKNOWN').upper()
        if st == 'OK':
            counts['ok']+=1
        elif st == 'WARN':
            counts['warn']+=1
        elif st == 'CRIT':
            counts['crit']+=1
        elif st == 'SKIP':
            counts['skipped']+=1
        else:
            counts['unknown']+=1
    return counts

rows, meta = read_rows()
if os.environ.get("LM_REDACT_LOGS","0") in ("1","true","TRUE","yes","YES"):
    rows = [redact_kv_map(r) for r in rows]
    if meta:
        meta = redact_kv_map(meta)
summary_result, summary_hosts = parse_log_summary(log_path)

summary_result_source = 'log' if summary_result else 'derived'
summary_hosts_source = 'log' if summary_hosts else 'derived'

if not summary_result:
    summary_result={'overall': worst_status(rows), 'derived': True}
if not summary_hosts:
    summary_hosts=derive_hosts(rows)
    summary_hosts['derived'] = True

if csv_mode:
    import csv
    writer = csv.writer(sys.stdout)
    writer.writerow(["monitor","host","status","reason"])
    for r in rows:
        writer.writerow([
            r.get("monitor",""),
            r.get("host",""),
            r.get("status",""),
            r.get("reason",""),
        ])
else:
    out={
        'mode': mode,
        'summary_file': summary_path if summary_path and os.path.exists(summary_path) else None,
        'summary_log': log_path if log_path and os.path.exists(log_path) else None,
        'summary_json': summary_json_path if summary_json_path and os.path.exists(summary_json_path) else None,
        'summary_result_source': summary_result_source,
        'summary_hosts_source': summary_hosts_source,
        'summary_result': summary_result,
        'summary_hosts': summary_hosts,
        'last_status': read_kv(status_path),
        'rows': rows,
    }
    if meta:
        out['meta']=meta

    print(json.dumps(out, indent=2, sort_keys=True))
PY
    ;;

  install)
    exec sudo ./install.sh "$@"
    ;;

  uninstall)
    exec sudo ./install.sh --uninstall "$@"
    ;;

  make-tarball)
    exec ./tools/make_tarball.sh "$@"
    ;;

  verify-release)
    exec ./tools/verify_release.sh "$@"
    ;;

  init)
    if [[ "$MODE" == "installed" ]]; then
      need_root_for init
    fi

    INIT_MINIMAL=0
    case "${1:-}" in
      --minimal) INIT_MINIMAL=1; shift ;;
      "") ;;
      *) echo "Unknown init flag: $1" >&2; exit 2 ;;
    esac

    CFG_DIR="${LM_CFG_DIR:-/etc/linux_maint}"
    # Prefer repo templates in repo mode; in installed mode use PREFIX share templates.
    SRC_DIR="$REPO_ROOT/etc/linux_maint"
    if [[ "$MODE" == "installed" ]]; then
      ALT="$SHARE/templates/linux_maint"
      [[ -d "$ALT" ]] && SRC_DIR="$ALT"
    fi
    if [[ -z "$SRC_DIR" || ! -d "$SRC_DIR" ]]; then
      echo "ERROR: templates not found at $SRC_DIR" >&2
      echo "Run init from a git checkout:" >&2
      echo "  git clone https://github.com/ShenhavHezi/Linux_Maint_ToolKit.git" >&2
      echo "  cd Linux_Maint_ToolKit" >&2
      echo "  sudo ./bin/linux-maint init" >&2
      exit 1
    fi

    sudo mkdir -p "$CFG_DIR"
    if [[ "$INIT_MINIMAL" -eq 0 ]]; then
      sudo mkdir -p "$CFG_DIR/baselines" "$CFG_DIR/baselines/ports" "$CFG_DIR/baselines/configs" "$CFG_DIR/baselines/users" "$CFG_DIR/baselines/sudoers"
    fi

    if [[ "$INIT_MINIMAL" -eq 1 ]]; then
      init_templates=(
        "$SRC_DIR/servers.txt.example"
        "$SRC_DIR/excluded.txt.example"
        "$SRC_DIR/services.txt.example"
      )
    else
      shopt -s nullglob
      init_templates=("$SRC_DIR"/*.example)
    fi

    for f in "${init_templates[@]}"; do
      [[ -f "$f" ]] || continue
      base="$(basename "$f" .example)"
      dest="$CFG_DIR/$base"
      if [[ -e "$dest" ]]; then
        echo "keep:   $dest (exists)"
      else
        if [[ "${LM_INIT_USE_CP:-0}" == "1" ]]; then
          # Some environments emit noisy SELinux warnings when using install(1).
          sudo cp -f "$f" "$dest"
          sudo chmod 0644 "$dest"
        else
          sudo install -m 0644 "$f" "$dest"
        fi
        echo "create: $dest"
      fi
    done

    echo ""
    echo "Next steps:"
    echo "  - Edit $CFG_DIR/servers.txt"
    echo "  - Run: sudo linux-maint doctor"
    if [[ "$INIT_MINIMAL" -eq 1 ]]; then
      echo "  - Optional later: run 'sudo linux-maint init' to install full optional templates"
    fi
    ;;

  tune)
    sub="${1:-}"; shift || true
    case "$sub" in
      dark-site)
        CFG_DIR="${LM_CFG_DIR:-/etc/linux_maint}"
        CONF="$CFG_DIR/linux-maint.conf"

        if [[ "$MODE" == "installed" ]]; then
          need_root_for tune
        fi

        if [[ ! -d "$CFG_DIR" ]]; then
          mkdir -p "$CFG_DIR" 2>/dev/null || { echo "ERROR: cannot create $CFG_DIR (try sudo)" >&2; exit 1; }
        fi
        if [[ ! -w "$CFG_DIR" ]]; then
          echo "ERROR: cannot write to $CFG_DIR (try sudo)" >&2
          exit 1
        fi

        SRC_DIR="$REPO_ROOT/etc/linux_maint"
        if [[ "$MODE" == "installed" ]]; then
          ALT="$SHARE/templates/linux_maint"
          [[ -d "$ALT" ]] && SRC_DIR="$ALT"
        fi
        tmpl="$SRC_DIR/linux-maint.conf.example"
        if [[ ! -f "$CONF" ]]; then
          if [[ -f "$tmpl" ]]; then
            cp -f "$tmpl" "$CONF"
          else
            cat > "$CONF" <<'EOF'
# linux-maint.conf - main configuration (KEY=VALUE)
# Generated by linux-maint tune dark-site
EOF
          fi
          echo "create: $CONF"
        fi

        python3 - "$CONF" <<'PY'
import os, re, sys, tempfile

conf_path = sys.argv[1]
settings = [
    ("LM_DARK_SITE", "true"),
    ("LM_LOCAL_ONLY", "true"),
    ("LM_NOTIFY_ONLY_ON_CHANGE", "1"),
    ("MONITOR_TIMEOUT_SECS", "300"),
    ("LM_LAST_RUN_MAX_AGE_MIN", "1800"),
    ("LM_LAST_RUN_LOG_DIR", "\"/var/log/health\""),
    ("LM_FS_RO_EXCLUDE_RE", "'^(proc|sysfs|devtmpfs|tmpfs|devpts|cgroup2?|cgroup|debugfs|tracefs|mqueue|hugetlbfs|pstore|squashfs|overlay|rpc_pipefs|autofs|fuse\\\\..*|binfmt_misc|iso9660)$'"),
]

with open(conf_path, "r", encoding="utf-8") as f:
    lines = f.readlines()

found = {k: False for k, _ in settings}
replaced = {k: False for k, _ in settings}
actions = []

for i, line in enumerate(lines):
    for key, val in settings:
        if found[key]:
            continue
        if re.match(r"\\s*#?\\s*%s\\s*=" % re.escape(key), line):
            if line.lstrip().startswith("#"):
                lines[i] = f"{key}={val}\n"
                replaced[key] = True
                actions.append(f"set: {key}={val} (was commented)")
            else:
                found[key] = True
                actions.append(f"keep: {key} (already set)")
            break

for key, val in settings:
    if found[key] or replaced[key]:
        continue
    lines.append(f"{key}={val}\n")
    actions.append(f"add: {key}={val}")

fd, tmp_path = tempfile.mkstemp(prefix="linux_maint_conf.", dir=os.path.dirname(conf_path))
with os.fdopen(fd, "w", encoding="utf-8") as f:
    f.writelines(lines)
os.replace(tmp_path, conf_path)

for a in actions:
    print(a)
PY
        ;;
      *)
        echo "Usage: linux-maint tune dark-site" >&2
        exit 2
        ;;
    esac
    ;;

  baseline)
    if [[ "$MODE" == "installed" ]]; then
      need_root_for baseline
    fi

    target="${1:-}"; shift || true
    BASELINE_UPDATE=0
    BASELINE_LOCAL=0
    BASELINE_DIFF=0
    BASELINE_SHOW=0
    while [[ $# -gt 0 ]]; do
      case "$1" in
        --update) BASELINE_UPDATE=1; shift 1;;
        --local-only) BASELINE_LOCAL=1; shift 1;;
        --diff) BASELINE_DIFF=1; shift 1;;
        --show) BASELINE_SHOW=1; shift 1;;
        -h|--help)
          echo "Usage: linux-maint baseline <ports|configs|users|sudoers> [--update] [--local-only] [--diff] [--show]"
          exit 0;;
        *) echo "Unknown baseline flag: $1" >&2; exit 2;;
      esac
    done

    if [[ -z "$target" ]]; then
      echo "Usage: linux-maint baseline <ports|configs|users|sudoers> [--update] [--local-only] [--diff] [--show]" >&2
      exit 2
    fi

    if [[ "$BASELINE_DIFF" -eq 1 && "$BASELINE_SHOW" -eq 1 ]]; then
      echo "ERROR: use only one of --diff or --show" >&2
      exit 2
    fi
    if [[ "$BASELINE_UPDATE" -eq 1 && ( "$BASELINE_DIFF" -eq 1 || "$BASELINE_SHOW" -eq 1 ) ]]; then
      echo "ERROR: --update cannot be combined with --diff or --show" >&2
      exit 2
    fi

    if [[ "$MODE" == "repo" ]]; then
      scripts_dir="$REPO_MONITORS"
    else
      scripts_dir="$LIBEXEC"
    fi

    case "$target" in
      ports)
        script="$scripts_dir/ports_baseline_monitor.sh"
        export LM_BASELINE_TARGET="ports"
        ;;
      configs|config)
        script="$scripts_dir/config_drift_monitor.sh"
        export LM_BASELINE_TARGET="configs"
        ;;
      users)
        script="$scripts_dir/user_monitor.sh"
        export LM_BASELINE_TARGET="users"
        ;;
      sudoers)
        script="$scripts_dir/user_monitor.sh"
        export LM_BASELINE_TARGET="sudoers"
        ;;
      *)
        echo "Unknown baseline target: $target" >&2
        exit 2
        ;;
    esac

    if [[ ! -x "$script" ]]; then
      echo "ERROR: baseline helper not found: $script" >&2
      exit 1
    fi

    export LM_BASELINE_ONLY=1
    if [[ "$BASELINE_UPDATE" -eq 1 ]]; then
      export BASELINE_UPDATE="true"
    fi
    if [[ "$BASELINE_LOCAL" -eq 1 ]]; then
      export LM_LOCAL_ONLY="true"
    fi
    if [[ "$BASELINE_DIFF" -eq 1 ]]; then
      export LM_BASELINE_DIFF=1
      export LM_BASELINE_ONLY=0
    fi
    if [[ "$BASELINE_SHOW" -eq 1 ]]; then
      export LM_BASELINE_SHOW=1
      export LM_BASELINE_ONLY=0
    fi

    exec bash "$script"
    ;;

  explain)
    sub="${1:-}"; shift || true
    case "$sub" in
      reason)
        token="${1:-}"
        if [[ -z "$token" ]]; then
          echo "Usage: linux-maint explain reason <token>" >&2
          exit 2
        fi
        f="$REPO_ROOT/docs/REASONS.md"
        if [[ ! -f "$f" ]]; then
          # installed mode: docs may be under share
          for alt in \
            "$SHARE/docs/REASONS.md" \
            "$PREFIX/share/Linux_Maint_ToolKit/docs/REASONS.md" \
            "$PREFIX/share/linux-maint/docs/REASONS.md" \
            "/usr/share/Linux_Maint_ToolKit/docs/REASONS.md" \
            "/usr/share/linux-maint/docs/REASONS.md" \
            "/usr/share/linux_maint/docs/REASONS.md" \
          ; do
            if [[ -f "$alt" ]]; then f="$alt"; break; fi
          done
        fi
        if [[ ! -f "$f" ]]; then
          echo "ERROR: reasons doc not found: $f" >&2
          exit 1
        fi
        # Look for a bullet line that contains `- token  ...` under any section.
        # Print the matching line(s) plus the section header immediately above.
        awk -v tok="$token" '
          BEGIN{sec=""; found=0}
          /^### /{sec=$0}
          $0 ~ "- `"tok"`" {
            if (sec!="") {print sec}
            print $0
            found=1
          }
          END{exit(found?0:1)}
        ' "$f" && exit 0

        # Fallback: substring search
        if grep -n -i -F "$token" "$f" >/dev/null 2>&1; then
          echo "No exact token match; showing closest lines:" >&2
          grep -n -i -F "$token" "$f" | head -n 20
          exit 0
        fi
        echo "Unknown reason token: $token" >&2
        exit 1
        ;;

      status)
        st="${1:-}"
        if [[ -z "$st" ]]; then
          echo "Usage: linux-maint explain status <OK|WARN|CRIT|UNKNOWN|SKIP>" >&2
          exit 2
        fi
        case "$st" in
          OK) echo "OK: check succeeded; no action required." ;;
          WARN) echo "WARN: potential issue; attention suggested." ;;
          CRIT) echo "CRIT: actionable failure; immediate attention required." ;;
          UNKNOWN) echo "UNKNOWN: check could not be completed reliably (missing tool/permission/unexpected error)." ;;
          SKIP) echo "SKIP: check intentionally did not run (missing optional config/baseline/unsupported environment)." ;;
          *) echo "Unknown status: $st" >&2; exit 2 ;;
        esac
        ;;

      *)
        echo "Usage: linux-maint explain <reason|status> ..." >&2
        exit 2
        ;;
    esac
    ;;


  pack-logs)
    OUT=""
    if [[ "${1:-}" == "--out" ]]; then
      OUT="${2:-}"; shift 2 || true
    fi

    # Default output directory:
    # - repo mode: repo root
    # - installed: current directory
    if [[ -z "$OUT" ]]; then
      if [[ "$MODE" == "repo" ]]; then
        OUT="$REPO_ROOT"
      else
        OUT="."
      fi
    fi

    # Determine log dir for mode
    if [[ "$MODE" == "repo" ]]; then
      _logdir="$REPO_LOG_DIR"
      _repo_root="$REPO_ROOT"
    else
      _logdir="${LOG_DIR:-/var/log/health}"
      _repo_root=""
    fi

    # Use best-effort state dir (where notify/summary diff stores state)
    _state_dir="${LM_NOTIFY_STATE_DIR:-${LM_STATE_DIR:-/var/lib/linux_maint}}"

    if [[ "$MODE" == "repo" ]]; then
      pack_logs_bin="$REPO_ROOT/tools/pack_logs.sh"
    else
      pack_logs_bin="$LIBEXEC/pack_logs.sh"
    fi
    if [[ ! -x "$pack_logs_bin" ]]; then
      echo "ERROR: pack-logs helper not found: $pack_logs_bin" >&2
      echo "Hint: reinstall or run from a git checkout." >&2
      exit 1
    fi
    OUTDIR="$OUT" LOG_DIR="$_logdir" CFG_DIR="${LM_CFG_DIR:-/etc/linux_maint}" STATE_DIR="$_state_dir" REPO_ROOT="$_repo_root" \
      "$pack_logs_bin"
    ;;
  verify-install)
    echo "=== linux-maint verify-install ==="
    echo "mode=$MODE"
    echo "prefix=$PREFIX"
    echo "wrapper=$wrapper"
    echo "lib=${LINUX_MAINT_LIB:-/usr/local/lib/linux_maint.sh}"

    fail=0

    check_file() {
      local label="$1" path="$2"
      if [[ -e "$path" ]]; then
        echo "${C_GREEN}OK${C_RESET}: $label: $path"
      else
        echo "${C_RED}MISSING${C_RESET}: $label: $path" >&2
        fail=1
      fi
    }

    check_exec() {
      local label="$1" path="$2"
      if [[ -x "$path" ]]; then
        echo "${C_GREEN}OK${C_RESET}: $label: $path"
      elif [[ -e "$path" ]]; then
        echo "${C_RED}NOT EXECUTABLE${C_RESET}: $label: $path" >&2
        fail=1
      else
        echo "${C_RED}MISSING${C_RESET}: $label: $path" >&2
        fail=1
      fi
    }

    check_writable_dir() {
      local label="$1" path="$2"
      if [[ -d "$path" ]]; then
        if ( : > "$path/.linux_maint_write_test" ) 2>/dev/null; then
          rm -f "$path/.linux_maint_write_test" 2>/dev/null || true
          echo "${C_GREEN}OK${C_RESET}: writable $label: $path"
        else
          echo "${C_YELLOW}WARN${C_RESET}: not writable $label: $path" >&2
        fi
      else
        echo "${C_YELLOW}WARN${C_RESET}: missing dir $label: $path" >&2
      fi
    }

    # Core files
    check_exec "wrapper" "$wrapper"
    check_file "library" "${LINUX_MAINT_LIB:-/usr/local/lib/linux_maint.sh}"

    if [[ "$MODE" == "repo" ]]; then
      check_file "monitors dir" "$REPO_MONITORS"
      check_file "tools dir" "$REPO_ROOT/tools"
    else
      check_file "libexec" "$LIBEXEC"
    fi

    echo "== Config =="
    CFG_DIR="${LM_CFG_DIR:-/etc/linux_maint}"
    echo "cfg_dir=$CFG_DIR"
    if [[ -d "$CFG_DIR" ]]; then
      check_file "servers" "$CFG_DIR/servers.txt"
      check_file "excluded" "$CFG_DIR/excluded.txt"
      check_file "services" "$CFG_DIR/services.txt"
    else
      echo "WARN: config dir missing: $CFG_DIR" >&2
    fi

    echo "== Writable locations =="
    check_writable_dir "lockdir" "${LM_LOCKDIR:-/var/lock}"
    check_writable_dir "state" "${LM_STATE_DIR:-/var/lib/linux_maint}"
    check_writable_dir "logs" "${LOG_DIR:-/var/log/health}"

    echo "== Version =="
    "$0" version || true

    echo "== systemd (best-effort) =="
    if command -v systemctl >/dev/null 2>&1; then
      # If unit files exist, report basic state; do not fail if systemd is not running.
      svc="/usr/lib/systemd/system/linux-maint.service"
      tmr="/usr/lib/systemd/system/linux-maint.timer"
      if [[ -f "$svc" || -f "$tmr" ]]; then
        [[ -f "$svc" ]] && echo "OK: unit file: $svc" || echo "WARN: missing unit file: $svc" >&2
        [[ -f "$tmr" ]] && echo "OK: unit file: $tmr" || echo "WARN: missing unit file: $tmr" >&2
        systemctl is-enabled linux-maint.timer >/dev/null 2>&1 && echo "OK: timer enabled" || echo "INFO: timer not enabled (or systemd unavailable)"
        systemctl is-active linux-maint.timer >/dev/null 2>&1 && echo "OK: timer active" || echo "INFO: timer not active (or systemd unavailable)"
      else
        echo "INFO: systemd unit files not present (ok if not installed with --with-timer)"
      fi
    else
      echo "INFO: systemctl not found"
    fi

    if [[ "$fail" -ne 0 ]]; then
      echo "verify-install FAIL" >&2
      exit 1
    fi

    if [[ "$fail" -eq 0 ]]; then
      echo "${C_GREEN}verify-install ok${C_RESET}"
    else
      echo "${C_RED}verify-install failed${C_RESET}" >&2
      exit 1
    fi
    ;;
  doctor)
    if [[ "$MODE" == "installed" ]]; then
      need_root_for doctor
    fi

    DOCTOR_JSON=0
    DOCTOR_COMPACT=0
    DOCTOR_FIX=0
    DOCTOR_FIX_DEPS=0
    DOCTOR_FIX_OPTIONAL=0
    DOCTOR_YES=0
    DOCTOR_DRY_RUN=0
    while [[ $# -gt 0 ]]; do
      case "$1" in
        --json) DOCTOR_JSON=1; shift 1;;
        --compact) DOCTOR_COMPACT=1; shift 1;;
        --fix) DOCTOR_FIX=1; shift 1;;
        --fix-deps) DOCTOR_FIX=1; DOCTOR_FIX_DEPS=1; shift 1;;
        --fix-deps-optional) DOCTOR_FIX=1; DOCTOR_FIX_DEPS=1; DOCTOR_FIX_OPTIONAL=1; shift 1;;
        --yes) DOCTOR_YES=1; shift 1;;
        --dry-run) DOCTOR_DRY_RUN=1; shift 1;;
        -h|--help)
          echo "Usage: linux-maint doctor [--json] [--compact] [--fix] [--fix-deps] [--fix-deps-optional] [--yes] [--dry-run]"
          exit 0;;
        *) echo "Unknown doctor flag: $1" >&2; exit 2;;
      esac
    done

    CFG_DIR="${LM_CFG_DIR:-/etc/linux_maint}"

    if [[ "$DOCTOR_FIX" -eq 1 && "${EUID:-$(id -u)}" -ne 0 ]]; then
      echo "ERROR: doctor --fix requires root" >&2
      exit 1
    fi

    if [[ "$DOCTOR_FIX" -eq 1 ]]; then
      if [[ "$DOCTOR_DRY_RUN" -eq 0 && "$DOCTOR_YES" -eq 0 ]]; then
        if [[ -t 1 ]]; then
          echo "About to apply fixes (dirs/perms${DOCTOR_FIX_DEPS:+, deps}). Proceed? [y/N]"
          read -r ans
          [[ "$ans" =~ ^[Yy]$ ]] || { echo "Aborted."; exit 1; }
        else
          echo "ERROR: doctor --fix requires --yes in non-interactive mode" >&2
          exit 1
        fi
      fi
      fix_actions=()
      ensure_dir() {
        local d="$1"
        if [[ ! -d "$d" ]]; then
          if [[ "$DOCTOR_DRY_RUN" -eq 1 ]]; then
            fix_actions+=("would create: $d")
          else
            install -d -m 0755 "$d" 2>/dev/null && fix_actions+=("create: $d") || fix_actions+=("failed: $d")
          fi
        elif [[ ! -w "$d" ]]; then
          if [[ "$DOCTOR_DRY_RUN" -eq 1 ]]; then
            fix_actions+=("would chmod: $d")
          else
            chmod 0755 "$d" 2>/dev/null && fix_actions+=("chmod: $d") || fix_actions+=("failed: $d")
          fi
        fi
      }
      ensure_dir "/var/log/health"
      ensure_dir "/var/log/inventory"
      ensure_dir "/var/lib/linux_maint"
      ensure_dir "/var/lock"
      if [[ ! -d "$CFG_DIR" ]]; then
        install -d -m 0755 "$CFG_DIR" 2>/dev/null && fix_actions+=("create: $CFG_DIR")
      fi

      if [[ "$DOCTOR_FIX_DEPS" -eq 1 ]]; then
        missing_pkgs=()
        add_pkg() {
          local pkg="$1"
          [[ -z "$pkg" ]] && return 0
          for p in "${missing_pkgs[@]:-}"; do
            [[ "$p" == "$pkg" ]] && return 0
          done
          missing_pkgs+=("$pkg")
        }
        # required deps
        command -v awk >/dev/null 2>&1 || add_pkg "gawk"
        command -v sed >/dev/null 2>&1 || add_pkg "sed"
        command -v grep >/dev/null 2>&1 || add_pkg "grep"
        command -v df >/dev/null 2>&1 || add_pkg "coreutils"
        command -v find >/dev/null 2>&1 || add_pkg "findutils"
        command -v timeout >/dev/null 2>&1 || add_pkg "coreutils"
        command -v curl >/dev/null 2>&1 || add_pkg "curl"
        command -v openssl >/dev/null 2>&1 || add_pkg "openssl"
        command -v ssh >/dev/null 2>&1 || add_pkg "openssh-clients"
        command -v systemctl >/dev/null 2>&1 || add_pkg "systemd"

        if [[ "$DOCTOR_FIX_OPTIONAL" -eq 1 ]]; then
          command -v chronyc >/dev/null 2>&1 || add_pkg "chrony"
          command -v ntpq >/dev/null 2>&1 || add_pkg "ntp"
          command -v smartctl >/dev/null 2>&1 || add_pkg "smartmontools"
          command -v nvme >/dev/null 2>&1 || add_pkg "nvme-cli"
          command -v netstat >/dev/null 2>&1 || add_pkg "net-tools"
          command -v ss >/dev/null 2>&1 || add_pkg "iproute"
          command -v journalctl >/dev/null 2>&1 || add_pkg "systemd"
        fi

        if [[ "${#missing_pkgs[@]:-0}" -gt 0 ]]; then
          if [[ "$DOCTOR_DRY_RUN" -eq 1 ]]; then
            fix_actions+=("deps: would install ${missing_pkgs[*]}")
          elif command -v dnf >/dev/null 2>&1; then
            dnf -y install "${missing_pkgs[@]}" && fix_actions+=("deps: installed via dnf") || fix_actions+=("deps: install failed (dnf)")
          elif command -v yum >/dev/null 2>&1; then
            yum -y install "${missing_pkgs[@]}" && fix_actions+=("deps: installed via yum") || fix_actions+=("deps: install failed (yum)")
          elif command -v apt-get >/dev/null 2>&1; then
            apt-get update >/dev/null 2>&1 || true
            apt-get -y install "${missing_pkgs[@]}" && fix_actions+=("deps: installed via apt-get") || fix_actions+=("deps: install failed (apt-get)")
          elif command -v zypper >/dev/null 2>&1; then
            zypper -n install "${missing_pkgs[@]}" && fix_actions+=("deps: installed via zypper") || fix_actions+=("deps: install failed (zypper)")
          else
            fix_actions+=("deps: no supported package manager found")
          fi
        else
          fix_actions+=("deps: none missing")
        fi
      fi
    fi

    if [[ "$DOCTOR_JSON" -eq 1 ]]; then
      MODE="$MODE" PREFIX="$PREFIX" WRAPPER="$wrapper" LIBEXEC="$LIBEXEC" LINUX_MAINT_LIB="${LINUX_MAINT_LIB:-/usr/local/lib/linux_maint.sh}" CFG_DIR="$CFG_DIR" python3 - <<'PYJSON'
import json
import os
import pathlib
import shutil

mode = os.environ.get("MODE", "")
prefix = os.environ.get("PREFIX", "")
wrapper = os.environ.get("WRAPPER", "")
libexec = os.environ.get("LIBEXEC", "")
lib = os.environ.get("LINUX_MAINT_LIB", "")
cfg_dir = os.environ.get("CFG_DIR", "/etc/linux_maint")

cfg_path = pathlib.Path(cfg_dir)


def has_cmd(cmd: str) -> bool:
    return shutil.which(cmd) is not None


def active_hosts_count(path: pathlib.Path) -> int:
    if not path.is_file():
        return 0
    count = 0
    for raw in path.read_text(errors="ignore").splitlines():
        line = raw.strip()
        if not line or line.startswith("#"):
            continue
        count += 1
    return count


config_files = ["servers.txt", "excluded.txt", "services.txt", "emails.txt"]
config = {
    "dir_exists": cfg_path.is_dir(),
    "files": {name: (cfg_path / name).exists() for name in config_files},
    "hosts_configured": active_hosts_count(cfg_path / "servers.txt"),
}

fix_suggestions = []
fix_seen = set()

def add_fix(msg: str) -> None:
    if msg in fix_seen:
        return
    fix_seen.add(msg)
    fix_suggestions.append(msg)

servers_path = cfg_path / "servers.txt"
services_path = cfg_path / "services.txt"
if not cfg_path.is_dir():
    add_fix("Initialize config templates: sudo linux-maint init")
else:
    if not servers_path.exists() or servers_path.stat().st_size == 0:
        add_fix(
            f"Create {cfg_dir}/servers.txt (example: printf '%s\\n' localhost | sudo tee {cfg_dir}/servers.txt)"
        )
    elif active_hosts_count(servers_path) == 0:
        add_fix(f"Add hosts to {cfg_dir}/servers.txt (one per line)")
    if services_path.exists() and services_path.stat().st_size == 0:
        add_fix(f"Populate {cfg_dir}/services.txt with critical services (one per line)")

gates = [
    ("cert_monitor", "certs.txt"),
    ("network_monitor", "network_targets.txt"),
    ("ports_baseline_monitor", "ports_baseline.txt"),
    ("config_drift_monitor", "config_paths.txt"),
    ("user_monitor", "baseline_users.txt"),
    ("user_monitor", "baseline_sudoers.txt"),
    ("backup_check", "backup_targets.csv"),
]
monitor_gates = []
for mon, fn in gates:
    p = cfg_path / fn
    monitor_gates.append(
        {
            "monitor": mon,
            "path": str(p),
            "present": p.exists() and p.stat().st_size > 0,
        }
    )
    if not (p.exists() and p.stat().st_size > 0):
        if fn == "certs.txt":
            add_fix(f"Add cert paths to {cfg_dir}/certs.txt")
        elif fn == "network_targets.txt":
            add_fix(f"Add network targets to {cfg_dir}/network_targets.txt")
        elif fn == "ports_baseline.txt":
            add_fix(f"Add baseline allowlist to {cfg_dir}/ports_baseline.txt")
        elif fn == "config_paths.txt":
            add_fix(f"Add config paths to {cfg_dir}/config_paths.txt")
        elif fn == "baseline_users.txt":
            add_fix(f"Generate baseline users list at {cfg_dir}/baseline_users.txt")
        elif fn == "baseline_sudoers.txt":
            add_fix(f"Generate baseline sudoers list at {cfg_dir}/baseline_sudoers.txt")
        elif fn == "backup_targets.csv":
            add_fix(f"Add backup targets to {cfg_dir}/backup_targets.csv")

dep_hints = [
    ("awk", "gawk"),
    ("sed", "sed"),
    ("grep", "grep"),
    ("df", "coreutils"),
    ("find", "findutils"),
    ("timeout", "coreutils"),
    ("curl", "curl"),
    ("openssl", "openssl"),
    ("ssh", "openssh-clients"),
    ("systemctl", "systemd"),
]
dependencies = []
for c, h in dep_hints:
    present = has_cmd(c)
    dependencies.append({"cmd": c, "present": present, "hint": h})
    if not present and h:
        add_fix(f"Install missing dependency: {h}")

writable_paths = ["/var/log/health", "/var/log/inventory", "/var/lib/linux_maint", "/var/lock"]
writable_locations = []
for d in writable_paths:
    p = pathlib.Path(d)
    exists = p.is_dir()
    writable = exists and os.access(d, os.W_OK)
    writable_locations.append({"path": d, "exists": exists, "writable": writable})
    if not exists:
        add_fix(f"Create missing dir: sudo install -d -m 0755 {d}")
    elif not writable:
        add_fix(f"Ensure {d} is writable (example: sudo install -d -m 0755 {d})")

result = {
    "mode": mode,
    "prefix": prefix,
    "wrapper": wrapper,
    "libexec": libexec,
    "lib": lib,
    "cfg_dir": cfg_dir,
    "config": config,
    "monitor_gates": monitor_gates,
    "dependencies": dependencies,
    "writable_locations": writable_locations,
    "fix_suggestions": fix_suggestions,
    "next_actions": [
        "linux-maint verify-install",
        "sudo linux-maint init",
        "sudo linux-maint preflight",
        "sudo linux-maint run",
        "linux-maint pack-logs --out .",
    ],
}

print(json.dumps(result, sort_keys=True))
PYJSON
      exit 0
    fi

    echo "=== linux-maint doctor ==="
    echo "mode=$MODE"
    echo "prefix=$PREFIX"
    if [[ "$DOCTOR_COMPACT" -eq 1 ]]; then
      echo "note=compact"
      echo ""
    fi
    echo "wrapper=$wrapper"
    echo "libexec=$LIBEXEC"
    echo "lib=${LINUX_MAINT_LIB:-/usr/local/lib/linux_maint.sh}"
    echo "cfg_dir=$CFG_DIR"

    if [[ "$DOCTOR_FIX" -eq 1 ]]; then
      echo ""
      echo "=== Fixes applied ==="
      if [[ "${#fix_actions[@]}" -eq 0 ]]; then
        echo "none"
      else
        for a in "${fix_actions[@]}"; do
          echo "- $a"
        done
      fi
    fi

    if [[ "$DOCTOR_COMPACT" -eq 0 ]]; then
      echo "== Files =="
      for path in "$wrapper" "${LINUX_MAINT_LIB:-/usr/local/lib/linux_maint.sh}"; do
        if [[ -e "$path" ]]; then ls -la "$path"; else echo "MISSING: $path"; fi
      done
      if [[ "$MODE" == "installed" ]]; then
        [[ -d "$LIBEXEC" ]] && ls -ld "$LIBEXEC" || echo "MISSING: $LIBEXEC"
      else
        [[ -d "$REPO_MONITORS" ]] && ls -ld "$REPO_MONITORS" || echo "MISSING: $REPO_MONITORS"
      fi
    fi

    echo ""
    echo "=== Config presence ==="
    fix_suggestions=()
    add_fix(){ fix_suggestions+=("$1"); }
    if [[ -d "$CFG_DIR" ]]; then
      printf "%-44s %s\n" "FILE" "STATUS"
      for f in "$CFG_DIR/servers.txt" "$CFG_DIR/excluded.txt" "$CFG_DIR/services.txt" "$CFG_DIR/emails.txt"; do
        if [[ -e "$f" ]]; then
          printf "%-44s %s\n" "$f" "${C_GREEN}OK${C_RESET}"
        else
          printf "%-44s %s\n" "$f" "${C_RED}MISSING${C_RESET}"
        fi
      done

      if [[ ! -s "$CFG_DIR/servers.txt" ]]; then
        echo "WARN: servers.txt missing/empty" >&2
        add_fix "Create $CFG_DIR/servers.txt (example: printf '%s\\n' localhost | sudo tee $CFG_DIR/servers.txt)"
      else
        n_hosts=$(grep -c -vE '^\s*(#|$)' "$CFG_DIR/servers.txt" 2>/dev/null || echo 0)
        echo "hosts_configured=$n_hosts"
        if [[ "$n_hosts" -eq 0 ]]; then
          echo "WARN: servers.txt has no active hosts (only comments/blank lines)" >&2
          add_fix "Add hosts to $CFG_DIR/servers.txt (one per line)"
        fi
      fi

      if [[ -f "$CFG_DIR/services.txt" && ! -s "$CFG_DIR/services.txt" ]]; then
        echo "WARN: services.txt is empty; service monitor may be ineffective" >&2
        add_fix "Populate $CFG_DIR/services.txt with critical services (one per line)"
      fi
    else
      echo "MISSING: config dir $CFG_DIR" >&2
      echo "Tip: sudo linux-maint init" >&2
      add_fix "Initialize config templates: sudo linux-maint init"
    fi

    echo ""
    echo "=== Monitor gates (what may SKIP) ==="
    printf "%-22s %-10s %s\n" "MONITOR" "STATUS" "PATH"
    if [[ -s "$CFG_DIR/certs.txt" ]]; then
      printf "%-22s %-10s %s\n" "cert_monitor" "${C_GREEN}OK${C_RESET}" "$CFG_DIR/certs.txt"
    else
      printf "%-22s %-10s %s\n" "cert_monitor" "${C_RED}MISSING${C_RESET}" "$CFG_DIR/certs.txt"
      add_fix "Add cert paths to $CFG_DIR/certs.txt"
    fi
    if [[ -s "$CFG_DIR/network_targets.txt" ]]; then
      printf "%-22s %-10s %s\n" "network_monitor" "${C_GREEN}OK${C_RESET}" "$CFG_DIR/network_targets.txt"
    else
      printf "%-22s %-10s %s\n" "network_monitor" "${C_RED}MISSING${C_RESET}" "$CFG_DIR/network_targets.txt"
      add_fix "Add network targets to $CFG_DIR/network_targets.txt"
    fi
    if [[ -s "$CFG_DIR/ports_baseline.txt" ]]; then
      printf "%-22s %-10s %s\n" "ports_baseline_monitor" "${C_GREEN}OK${C_RESET}" "$CFG_DIR/ports_baseline.txt"
    else
      printf "%-22s %-10s %s\n" "ports_baseline_monitor" "${C_RED}MISSING${C_RESET}" "$CFG_DIR/ports_baseline.txt"
      add_fix "Add baseline allowlist to $CFG_DIR/ports_baseline.txt"
    fi
    if [[ -s "$CFG_DIR/config_paths.txt" ]]; then
      printf "%-22s %-10s %s\n" "config_drift_monitor" "${C_GREEN}OK${C_RESET}" "$CFG_DIR/config_paths.txt"
    else
      printf "%-22s %-10s %s\n" "config_drift_monitor" "${C_RED}MISSING${C_RESET}" "$CFG_DIR/config_paths.txt"
      add_fix "Add config paths to $CFG_DIR/config_paths.txt"
    fi
    if [[ -s "$CFG_DIR/baseline_users.txt" ]]; then
      printf "%-22s %-10s %s\n" "user_monitor(users)" "${C_GREEN}OK${C_RESET}" "$CFG_DIR/baseline_users.txt"
    else
      printf "%-22s %-10s %s\n" "user_monitor(users)" "${C_RED}MISSING${C_RESET}" "$CFG_DIR/baseline_users.txt"
      add_fix "Generate baseline users list at $CFG_DIR/baseline_users.txt"
    fi
    if [[ -s "$CFG_DIR/baseline_sudoers.txt" ]]; then
      printf "%-22s %-10s %s\n" "user_monitor(sudoers)" "${C_GREEN}OK${C_RESET}" "$CFG_DIR/baseline_sudoers.txt"
    else
      printf "%-22s %-10s %s\n" "user_monitor(sudoers)" "${C_RED}MISSING${C_RESET}" "$CFG_DIR/baseline_sudoers.txt"
      add_fix "Generate baseline sudoers list at $CFG_DIR/baseline_sudoers.txt"
    fi
    if [[ -s "$CFG_DIR/backup_targets.csv" ]]; then
      printf "%-22s %-10s %s\n" "backup_check" "${C_GREEN}OK${C_RESET}" "$CFG_DIR/backup_targets.csv"
    else
      printf "%-22s %-10s %s\n" "backup_check" "${C_RED}MISSING${C_RESET}" "$CFG_DIR/backup_targets.csv"
      add_fix "Add backup targets to $CFG_DIR/backup_targets.csv"
    fi

    echo ""
    echo "=== Dependencies (best-effort) ==="
    need_cmd() {
      local cmd="$1" pkg_hint="$2"
      if command -v "$cmd" >/dev/null 2>&1; then
        printf "%-18s %s\n" "$cmd" "${C_GREEN}OK${C_RESET}"
      else
        printf "%-18s %s\n" "$cmd" "${C_RED}MISSING${C_RESET}"
        [[ -n "$pkg_hint" ]] && echo "  hint: install package: $pkg_hint" >&2
        [[ -n "$pkg_hint" ]] && add_fix "Install missing dependency: $pkg_hint"
      fi
    }

    need_cmd awk "gawk"
    need_cmd sed "sed"
    need_cmd grep "grep"
    need_cmd df "coreutils"
    need_cmd find "findutils"
    need_cmd timeout "coreutils"
    need_cmd curl "curl"
    need_cmd openssl "openssl"
    need_cmd ssh "openssh-clients"
    need_cmd systemctl "systemd"

    if [[ "$DOCTOR_COMPACT" -eq 0 ]]; then
      echo ""
      echo "=== systemd (best-effort) ==="
      if command -v systemctl >/dev/null 2>&1; then
        for unit in linux-maint.timer linux-maint.service; do
          if systemctl list-unit-files --no-legend "$unit" 2>/dev/null | grep -q "^$unit"; then
            echo "UNIT: $unit"
            systemctl is-enabled "$unit" 2>/dev/null || true
            systemctl is-active "$unit" 2>/dev/null || true
          else
            echo "INFO: unit not installed: $unit"
          fi
        done
        echo "-- timers (linux-maint) --"
        systemctl list-timers --all --no-pager 2>/dev/null | grep -E "linux-maint\.timer|NEXT|^$" || true
      else
        echo "INFO: systemctl not found"
      fi
    fi

    echo ""
    echo "=== Can write state/logs? ==="
    printf "%-24s %s\n" "PATH" "STATUS"
    for d in /var/log/health /var/log/inventory /var/lib/linux_maint /var/lock; do
      if [[ -d "$d" ]]; then
        if touch "$d/.lm_write_test" 2>/dev/null; then
          rm -f "$d/.lm_write_test" 2>/dev/null || true
          printf "%-24s %s\n" "$d" "${C_GREEN}OK${C_RESET}"
        else
          printf "%-24s %s\n" "$d" "${C_RED}NOT_WRITABLE${C_RESET}"
        fi
        if ! touch "$d/.lm_write_test" 2>/dev/null; then
          add_fix "Ensure $d is writable (example: sudo install -d -m 0755 $d)"
        fi
      else
        printf "%-24s %s\n" "$d" "${C_RED}MISSING${C_RESET}"
        add_fix "Create missing dir: sudo install -d -m 0755 $d"
      fi
    done

    echo ""
    echo "=== Fix suggestions ==="
    if [[ "${#fix_suggestions[@]}" -eq 0 ]]; then
      echo "- none"
    else
      for f in "${fix_suggestions[@]}"; do
        echo "- $f"
      done
    fi

    if [[ "$DOCTOR_COMPACT" -eq 0 ]]; then
      echo ""
      echo "=== Next recommended actions ==="
      echo "- linux-maint verify-install"
      echo "- sudo linux-maint init      # if config is missing"
      echo "- sudo linux-maint preflight"
      echo "- sudo linux-maint run"
      echo "- linux-maint pack-logs --out .  # create bundle for export"
    fi
    ;;

  self-check)
    SC_JSON=0
    SC_COMPACT=0
    while [[ $# -gt 0 ]]; do
      case "$1" in
        --json) SC_JSON=1; shift 1;;
        --compact) SC_COMPACT=1; shift 1;;
        -h|--help)
          echo "Usage: linux-maint self-check [--json] [--compact]"
          exit 0;;
        *) echo "Unknown self-check flag: $1" >&2; exit 2;;
      esac
    done

    CFG_DIR="${LM_CFG_DIR:-/etc/linux_maint}"
    if [[ "$MODE" == "repo" ]]; then
      LOG_DIR_SC="${LOG_DIR:-$REPO_LOG_DIR}"
      STATE_DIR_SC="${LM_STATE_DIR:-/tmp}"
      LOCK_DIR_SC="${LM_LOCKDIR:-/tmp}"
    else
      LOG_DIR_SC="${LOG_DIR:-/var/log/health}"
      STATE_DIR_SC="${LM_STATE_DIR:-/var/lib/linux_maint}"
      LOCK_DIR_SC="${LM_LOCKDIR:-/var/lock}"
    fi

    if [[ "$SC_JSON" -eq 1 ]]; then
      MODE="$MODE" CFG_DIR="$CFG_DIR" LOG_DIR_SC="$LOG_DIR_SC" STATE_DIR_SC="$STATE_DIR_SC" LOCK_DIR_SC="$LOCK_DIR_SC" python3 - <<'PY'
import json, os, pathlib, shutil

mode = os.environ.get("MODE","")
cfg_dir = os.environ.get("CFG_DIR","/etc/linux_maint")
log_dir = os.environ.get("LOG_DIR_SC","/var/log/health")
state_dir = os.environ.get("STATE_DIR_SC","/var/lib/linux_maint")
lock_dir = os.environ.get("LOCK_DIR_SC","/var/lock")

cfg_path = pathlib.Path(cfg_dir)
config_files = ["servers.txt", "excluded.txt", "services.txt"]
config = {
    "dir_exists": cfg_path.is_dir(),
    "files": {name: (cfg_path / name).exists() for name in config_files},
}

def writable(path: str) -> bool:
    p = pathlib.Path(path)
    if not p.is_dir():
        return False
    return os.access(path, os.W_OK)

paths = [
    {"purpose": "logs", "path": log_dir, "exists": pathlib.Path(log_dir).is_dir(), "writable": writable(log_dir)},
    {"purpose": "state", "path": state_dir, "exists": pathlib.Path(state_dir).is_dir(), "writable": writable(state_dir)},
    {"purpose": "lock", "path": lock_dir, "exists": pathlib.Path(lock_dir).is_dir(), "writable": writable(lock_dir)},
]

deps_list = ["bash","awk","sed","grep","df","find","timeout","ssh"]
deps = [{"cmd": d, "present": shutil.which(d) is not None} for d in deps_list]

out = {
    "mode": mode,
    "cfg_dir": cfg_dir,
    "config": config,
    "paths": paths,
    "dependencies": deps,
}

print(json.dumps(out, sort_keys=True))
PY
      exit 0
    fi

    echo "=== linux-maint self-check ==="
    echo "mode=$MODE"
    echo "cfg_dir=$CFG_DIR"
    if [[ "$SC_COMPACT" -eq 1 ]]; then
      echo "note=compact"
      echo ""
    fi
    echo "=== Config files ==="
    printf "%-44s %s\n" "FILE" "STATUS"
    for f in "$CFG_DIR/servers.txt" "$CFG_DIR/excluded.txt" "$CFG_DIR/services.txt"; do
      if [[ -e "$f" ]]; then
        printf "%-44s %s\n" "$f" "${C_GREEN}OK${C_RESET}"
      else
        printf "%-44s %s\n" "$f" "${C_RED}MISSING${C_RESET}"
      fi
    done
    if [[ "$SC_COMPACT" -eq 0 ]]; then
      echo ""
      echo "=== Paths (writable) ==="
      printf "%-10s %-44s %s\n" "PURPOSE" "PATH" "STATUS"
      for purpose in logs state lock; do
        case "$purpose" in
          logs) d="$LOG_DIR_SC" ;;
          state) d="$STATE_DIR_SC" ;;
          lock) d="$LOCK_DIR_SC" ;;
        esac
        if [[ -d "$d" ]]; then
          if [[ -w "$d" ]]; then
            printf "%-10s %-44s %s\n" "$purpose" "$d" "${C_GREEN}OK${C_RESET}"
          else
            printf "%-10s %-44s %s\n" "$purpose" "$d" "${C_RED}NOT_WRITABLE${C_RESET}"
          fi
        else
          printf "%-10s %-44s %s\n" "$purpose" "$d" "${C_RED}MISSING${C_RESET}"
        fi
      done
      echo ""
      echo "=== Dependencies ==="
      for cmd in bash awk sed grep df find timeout ssh; do
        command -v "$cmd" >/dev/null 2>&1 && printf "%-18s %s\n" "$cmd" "${C_GREEN}OK${C_RESET}" || printf "%-18s %s\n" "$cmd" "${C_RED}MISSING${C_RESET}"
      done
    fi
    ;;

  deps)
    if [[ "$MODE" == "installed" ]]; then
      need_root_for deps
    fi

    has_cmd() { command -v "$1" >/dev/null 2>&1 && echo yes || echo no; }

    echo "=== linux-maint deps ==="
    echo "mode=$MODE"
    echo "format: monitor|required|optional|available_required|available_optional"

    # monitor|required_cmds(optional space-separated)|optional_cmds(space-separated)
    while IFS='|' read -r mon req opt; do
      [[ -z "$mon" ]] && continue
      req_avail=0; req_total=0
      opt_avail=0; opt_total=0

      for c in $req; do
        req_total=$((req_total+1))
        [[ "$(has_cmd "$c")" == "yes" ]] && req_avail=$((req_avail+1))
      done
      for c in $opt; do
        opt_total=$((opt_total+1))
        [[ "$(has_cmd "$c")" == "yes" ]] && opt_avail=$((opt_avail+1))
      done

      echo "monitor=$mon|required=${req:-none}|optional=${opt:-none}|available_required=${req_avail}/${req_total}|available_optional=${opt_avail}/${opt_total}"
    done <<'EOF_DEPS'
preflight_check|awk sed grep df timeout ssh|curl openssl
config_validate|awk sed grep|none
health_monitor|awk sed grep ps df|none
inode_monitor|awk sed grep df|none
disk_trend_monitor|awk sed grep df|none
network_monitor|awk sed grep|curl
service_monitor|awk sed grep|systemctl
ntp_drift_monitor|awk sed grep|chronyc ntpq
patch_monitor|awk sed grep|apt yum dnf zypper
storage_health_monitor|awk sed grep|smartctl nvme
kernel_events_monitor|awk sed grep|journalctl dmesg
cert_monitor|awk sed grep|openssl
nfs_mount_monitor|awk sed grep|showmount
ports_baseline_monitor|awk sed grep|ss netstat
config_drift_monitor|awk sed grep|sha256sum md5sum
user_monitor|awk sed grep|id getent
backup_check|awk sed grep|none
inventory_export|awk sed grep hostname|ip lsblk lscpu
EOF_DEPS
    ;;


  *)
    echo "Unknown command: $cmd" >&2
    usage
    exit 2
    ;;
esac
